// -----------------------------------------------------------------------
// <copyright file="ClassGenerationContext.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Sqlx;

using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;

internal class ClassGenerationContext : GenerationContextBase
{
    private GeneratorExecutionContext _generatorExecutionContext;
    private NullableContextOptions _nullableContextOptions;

    public ClassGenerationContext(
        INamedTypeSymbol classSymbol,
        List<IMethodSymbol> methods,
        INamedTypeSymbol attributeSymbol)
    {
        ClassSymbol = classSymbol;
        Methods = methods.Select(_ => new MethodGenerationContext(this, _)).ToList();
        AttributeSymbol = attributeSymbol;
        _nullableContextOptions = NullableContextOptions.Disable;
    }

    // Parameterless constructor for testing/mocking
    internal ClassGenerationContext()
    {
        ClassSymbol = default!;
        Methods = new List<MethodGenerationContext>();
        AttributeSymbol = default!;
        _nullableContextOptions = NullableContextOptions.Disable;
    }

    public INamedTypeSymbol ClassSymbol { get; }

    public List<MethodGenerationContext> Methods { get; }

    public INamedTypeSymbol AttributeSymbol { get; }

    public GeneratorExecutionContext GeneratorExecutionContext => _generatorExecutionContext;

    /// <summary>
    /// Sets the generator execution context and nullable options
    /// </summary>
    public void SetExecutionContext(GeneratorExecutionContext context)
    {
        _generatorExecutionContext = context;
        _nullableContextOptions = context.Compilation.Options.NullableContextOptions;
    }

    internal override ISymbol? DbConnection => GetSymbol(ClassSymbol, x => x.IsDbConnection());

    internal override ISymbol? TransactionParameter => GetSymbol(ClassSymbol, x => x.IsDbTransaction());

    internal override ISymbol? DbContext => GetSymbol(ClassSymbol, x => x.IsDbContext());

    public bool CreateSource(IndentedStringBuilder sb)
    {
        sb.AppendLine(@"// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>");

        sb.AppendLine("#nullable disable");
        sb.AppendLine("#pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669, CS8628, CS0266");
        sb.AppendLine();
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();
        var hasNamespace = !ClassSymbol.ContainingNamespace.IsGlobalNamespace;
        if (hasNamespace)
        {
            sb.AppendLine($"namespace {ClassSymbol.ContainingNamespace.ToDisplayString()}");
            sb.AppendLine("{");
            sb.PushIndent();
        }

        var staticKeyword = ClassSymbol.IsStatic ? "static " : string.Empty;
        sb.AppendLine($"{ClassSymbol.DeclaredAccessibility.GetAccessibility()} {staticKeyword}partial class {ClassSymbol.Name}");
        sb.AppendLine("{");
        sb.PushIndent();

        foreach (var item in Methods)
        {
            var ok = item.DeclareCommand(sb);
            if (!ok) return false;
            sb.AppendLine();
        }

        WriteInterceptMethods(sb);

        sb.PopIndent();
        sb.AppendLine("}");

        if (hasNamespace)
        {
            sb.PopIndent();
            sb.AppendLine("}");
        }

        return true;
    }

    public ISymbol? GetFieldOrProperty(Func<ISymbol, bool> check)
    {
        return GetFieldOrPropertyInternal(ClassSymbol, check) ?? GetFieldOrPropertyInternal(ClassSymbol.BaseType, check);
    }

    public AttributeData? GetAttribute(Func<AttributeData, bool> check)
    {
        return GetAttribute(ClassSymbol, check) ?? GetAttribute(ClassSymbol.BaseType, check);
    }

    private ISymbol? GetFieldOrPropertyInternal(INamedTypeSymbol? symbol, Func<ISymbol, bool> check)
    {
        if (symbol == null) return null;

        return symbol.GetMembers().OfType<IFieldSymbol>().FirstOrDefault(check) ??
            (ISymbol?)symbol.GetMembers().OfType<IPropertySymbol>().FirstOrDefault(check);
    }

    private AttributeData? GetAttribute(INamedTypeSymbol? symbol, Func<AttributeData, bool> check)
    {
        if (symbol == null) return null;

        return symbol.GetAttributes().FirstOrDefault(check);
    }

    private void WriteInterceptMethods(IndentedStringBuilder sb)
    {
        var staticKeyword = ClassSymbol.IsStatic ? "static " : string.Empty;

        sb.AppendLine($"{staticKeyword}partial void {MethodGenerationContext.MethodExecuting}(global::System.String methodName, ");
        sb.AppendLine($"    global::System.Data.Common.DbCommand command);");
        sb.AppendLine();

        sb.AppendLine($"{staticKeyword}partial void {MethodGenerationContext.MethodExecuted}(global::System.String methodName, ");
        sb.AppendLine($"    global::System.Data.Common.DbCommand command, global::System.Object? result, ");
        sb.AppendLine($"    global::System.Int64 elpased);");
        sb.AppendLine();

        sb.AppendLine($"{staticKeyword}partial void {MethodGenerationContext.MethodExecuteFail}(global::System.String methodName, ");
        sb.AppendLine($"    global::System.Data.Common.DbCommand command, global::System.Exception exception, ");
        sb.AppendLine($"    global::System.Int64 elpased);");
        sb.AppendLine();
    }
}
