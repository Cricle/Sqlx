// -----------------------------------------------------------------------
// <copyright file="ClassGenerationContext.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Sqlx;

using Microsoft.CodeAnalysis;
using Sqlx.Generator.Core;
using System;
using System.Collections.Generic;
using System.Linq;

internal class ClassGenerationContext : GenerationContextBase
{
    private GeneratorExecutionContext _generatorExecutionContext;

    public ClassGenerationContext(
        INamedTypeSymbol classSymbol,
        List<IMethodSymbol> methods,
        INamedTypeSymbol attributeSymbol)
    {
        ClassSymbol = classSymbol;
        Methods = methods.Select(_ => new MethodGenerationContext(this, _)).ToList();
        AttributeSymbol = attributeSymbol;
    }

    // Parameterless constructor for testing/mocking
    internal ClassGenerationContext()
    {
        ClassSymbol = default!;
        Methods = new List<MethodGenerationContext>();
        AttributeSymbol = default!;
    }

    public INamedTypeSymbol ClassSymbol { get; }

    public List<MethodGenerationContext> Methods { get; }

    public INamedTypeSymbol AttributeSymbol { get; }

    public GeneratorExecutionContext GeneratorExecutionContext => _generatorExecutionContext;

    /// <summary>
    /// Sets the generator execution context and nullable options
    /// </summary>
    public void SetExecutionContext(GeneratorExecutionContext context)
    {
        _generatorExecutionContext = context;
    }

    internal override ISymbol? DbConnection => GetSymbolWithPrimaryConstructor(ClassSymbol, x => x.IsDbConnection());

    internal override ISymbol? TransactionParameter => GetSymbolWithPrimaryConstructor(ClassSymbol, x => x.IsDbTransaction());

    internal override ISymbol? DbContext => GetSymbolWithPrimaryConstructor(ClassSymbol, x => x.IsDbContext());

    public bool CreateSource(IndentedStringBuilder sb)
    {
        sb.AppendLine(@"// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>");

        sb.AppendLine("#nullable disable");
        sb.AppendLine("#pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669, CS8628, CS0266, CS0219");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Data.Common;");
        sb.AppendLine("using Sqlx.Annotations;");
        sb.AppendLine();
        var hasNamespace = !ClassSymbol.ContainingNamespace.IsGlobalNamespace;
        if (hasNamespace)
        {
            sb.AppendLine($"namespace {ClassSymbol.ContainingNamespace.ToDisplayString()}");
            sb.AppendLine("{");
            sb.PushIndent();
        }

        var staticKeyword = ClassSymbol.IsStatic ? "static " : string.Empty;
        sb.AppendLine($"{ClassSymbol.DeclaredAccessibility.GetAccessibility()} {staticKeyword}partial class {ClassSymbol.Name}");
        sb.AppendLine("{");
        sb.PushIndent();

        foreach (var item in Methods)
        {
            var ok = item.DeclareCommand(sb);
            if (!ok) return false;
            sb.AppendLine();
        }

        WriteInterceptMethods(sb);

        sb.PopIndent();
        sb.AppendLine("}");

        if (hasNamespace)
        {
            sb.PopIndent();
            sb.AppendLine("}");
        }

        return true;
    }

    public ISymbol? GetFieldOrProperty(Func<ISymbol, bool> check)
    {
        return GetFieldOrPropertyInternal(ClassSymbol, check) ?? GetFieldOrPropertyInternal(ClassSymbol.BaseType, check);
    }

    public AttributeData? GetAttribute(Func<AttributeData, bool> check)
    {
        return GetAttribute(ClassSymbol, check) ?? GetAttribute(ClassSymbol.BaseType, check);
    }

    private ISymbol? GetFieldOrPropertyInternal(INamedTypeSymbol? symbol, Func<ISymbol, bool> check)
    {
        if (symbol == null) return null;

        return symbol.GetMembers().OfType<IFieldSymbol>().FirstOrDefault(check) ??
            (ISymbol?)symbol.GetMembers().OfType<IPropertySymbol>().FirstOrDefault(check);
    }

    private AttributeData? GetAttribute(INamedTypeSymbol? symbol, Func<AttributeData, bool> check)
    {
        if (symbol == null) return null;

        return symbol.GetAttributes().FirstOrDefault(check);
    }

    /// <summary>
    /// Gets a symbol (field, property, or primary constructor parameter) that matches the check condition
    /// </summary>
    private ISymbol? GetSymbolWithPrimaryConstructor(INamedTypeSymbol? symbol, Func<ISymbol, bool> check)
    {
        if (symbol == null) return null;

        return FindInMembers(symbol, check) ??
               FindInConstructors(symbol, check) ??
               GetSymbolWithPrimaryConstructor(symbol.BaseType, check);
    }

    private ISymbol? FindInMembers(INamedTypeSymbol symbol, Func<ISymbol, bool> check)
    {
        // Check fields and properties
        var field = symbol.GetMembers().OfType<IFieldSymbol>().FirstOrDefault(check);
        if (field != null) return field;

        return symbol.GetMembers().OfType<IPropertySymbol>().FirstOrDefault(check);
    }

    private ISymbol? FindInConstructors(INamedTypeSymbol symbol, Func<ISymbol, bool> check)
    {
        // Check primary constructor parameters first
        var primaryConstructor = PrimaryConstructorAnalyzer.GetPrimaryConstructor(symbol);
        var primaryParam = primaryConstructor?.Parameters.FirstOrDefault(p => check(p));
        if (primaryParam != null) return primaryParam;

        // Check regular constructor parameters for backward compatibility
        return symbol.InstanceConstructors
            .SelectMany(c => c.Parameters)
            .FirstOrDefault(p => check(p));
    }

    private void WriteInterceptMethods(IndentedStringBuilder sb)
    {
        var staticKeyword = ClassSymbol.IsStatic ? "static " : string.Empty;

        sb.AppendLine($"{staticKeyword}partial void {MethodGenerationContext.MethodExecuting}(global::System.String methodName, ");
        sb.AppendLine($"    global::System.Data.Common.DbCommand command);");
        sb.AppendLine();

        sb.AppendLine($"{staticKeyword}partial void {MethodGenerationContext.MethodExecuted}(global::System.String methodName, ");
        sb.AppendLine($"    global::System.Data.Common.DbCommand command, global::System.Object? result, ");
        sb.AppendLine($"    global::System.Int64 elapsed);");
        sb.AppendLine();

        sb.AppendLine($"{staticKeyword}partial void {MethodGenerationContext.MethodExecuteFail}(global::System.String methodName, ");
        sb.AppendLine($"    global::System.Data.Common.DbCommand? command, global::System.Exception exception, ");
        sb.AppendLine($"    global::System.Int64 elapsed);");
        sb.AppendLine();
    }
}
