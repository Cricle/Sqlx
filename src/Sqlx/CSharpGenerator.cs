// -----------------------------------------------------------------------
// <copyright file="CSharpGenerator.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Sqlx;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

/// <summary>
/// Stored procedures generator for C#.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class CSharpGenerator : AbstractGenerator
{
    private const string CSharpAttributeSource = @"// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;
using System.Text;

namespace Sqlx.Annotations
{
    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    sealed class SqlxAttribute : global::System.Attribute
    {
        public SqlxAttribute()
            => StoredProcedureName = string.Empty;

        public SqlxAttribute(string name)
            => StoredProcedureName = name;

        public string StoredProcedureName { get; }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter| global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class RawSqlAttribute : global::System.Attribute
    {
        public RawSqlAttribute() { }
        public RawSqlAttribute(global::System.String sql) { }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
        public ExpressionToSqlAttribute() { }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class ExecuteNoQueryAttribute : global::System.Attribute { }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method
        | global::System.AttributeTargets.Class
        | global::System.AttributeTargets.Field
        | global::System.AttributeTargets.Property
        | global::System.AttributeTargets.Method
        | global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class TimeoutAttribute : global::System.Attribute
    {
        public TimeoutAttribute() { }

        public TimeoutAttribute(int timeout) => Timeout = timeout;

        public int Timeout { get; }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class DbColumnAttribute : global::System.Attribute
    {
        public DbColumnAttribute() { }

        public DbColumnAttribute(string? name) => Name = name;

        public string? Name { get; }

        public byte Precision { get; }
        public byte Scale { get; }
        public byte Size { get; }
        public global::System.Data.ParameterDirection Direction { get; }
    }

    /// <summary>
    /// Tag to paramter make it as <see cref=""Func{DbDataReader, Task}""/> or <see cref=""Action{DbDataReader}""/> for read data
    /// </summary>
    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class ReadHandlerAttribute : global::System.Attribute { }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class DbSetTypeAttribute : global::System.Attribute
    {
        public DbSetTypeAttribute(global::System.Type type) => Type = type;

        public global::System.Type Type { get; }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Class, AllowMultiple = false)]
    sealed class SqlDefineAttribute : global::System.Attribute
    {
        public SqlDefineAttribute(SqlDefineTypes type) { }

        public SqlDefineAttribute(global::System.String columnLeft,
                                  global::System.String columnRight,
                                  global::System.String stringLeft,
                                  global::System.String stringRight,
                                  global::System.String ParamterPrefx) { }
    }

    enum SqlDefineTypes
    {
        MySql = 0,
        SqlServer = 1,
        Postgresql = 2,
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        public SqlExecuteTypeAttribute(SqlExecuteTypes Type, string TableName) { }
    }

    internal enum SqlExecuteTypes
    {
        Select = 0,
        Update = 1,
        Insert = 2,
        Delete = 3,
    }

    /// <summary>
    /// Represents a SQL template with parameters for efficient query execution.
    /// This class is designed for high performance and security by pre-parsing SQL and parameters.
    /// </summary>
    public record SqlTemplate(string Sql, IReadOnlyList<DbParameter> Parameters)
    {
        /// <summary>
        /// Creates a SQL template with the specified SQL and parameters.
        /// Parameters are validated to prevent SQL injection attacks.
        /// </summary>
        public SqlTemplate(string sql, params DbParameter[] parameters) : this(sql, (IReadOnlyList<DbParameter>)parameters) { }
        
        /// <summary>
        /// Creates a SQL template with no parameters.
        /// </summary>
        public SqlTemplate(string sql) : this(sql, Array.Empty<DbParameter>()) { }
    }

    /// <summary>
    /// Provides predefined SQL dialects for different database systems.
    /// Each dialect includes proper column wrapping and parameter prefixes for security.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft, string StringRight, string ParameterPrefix) 
            MySql = (""`"", ""`"", ""'"", ""'"", ""@"");

        /// <summary>
        /// SQL Server dialect configuration with bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft, string StringRight, string ParameterPrefix) 
            SqlServer = (""["", ""]"", ""'"", ""'"", ""@"");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft, string StringRight, string ParameterPrefix) 
            PgSql = (""\u0022"", ""\u0022"", ""'"", ""'"", ""$"");
    }

    /// <summary>
    /// High-performance LINQ expression to SQL converter with type safety and caching.
    /// Provides both direct SQL composition and parameterized query generation.
    /// </summary>
    public class ExpressionToSql<T> : IDisposable
    {
        private readonly List<Expression<Func<T, bool>>> _whereConditions = new List<Expression<Func<T, bool>>>();
        private readonly List<(LambdaExpression Expression, bool Descending)> _orderByExpressions = new List<(LambdaExpression, bool)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(Expression<Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(Expression<Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(Expression<Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;

            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, Array.Empty<DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new StringBuilder();
            sql.Append(""SELECT * FROM "");
            sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);

            if (_whereConditions.Count > 0)
            {
                sql.Append("" WHERE "");
                var conditions = new List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($""({conditionSql})"");
                }
                sql.Append(string.Join("" AND "", conditions));
            }

            if (_orderByExpressions.Count > 0)
            {
                sql.Append("" ORDER BY "");
                var orderClauses = new List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? "" DESC"" : "" ASC"";
                    orderClauses.Add(columnName + direction);
                }
                sql.Append(string.Join("", "", orderClauses));
            }

            if (_skip.HasValue)
            {
                sql.Append($"" OFFSET {_skip.Value}"");
            }

            if (_take.HasValue)
            {
                sql.Append($"" LIMIT {_take.Value}"");
            }

            return sql.ToString();
        }

        private string ParseExpression(Expression expression)
        {
            switch (expression)
            {
                case BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case MemberExpression member:
                    return GetColumnName(member);
                case ConstantExpression constant:
                    return GetConstantValue(constant);
                case UnaryExpression unary when unary.NodeType == ExpressionType.Not:
                    return $""NOT ({ParseExpression(unary.Operand)})"";
                default:
                    return ""1=1""; // Fallback for unsupported expressions
            }
        }

        private string ParseBinaryExpression(BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            
            return binary.NodeType switch
            {
                ExpressionType.Equal => $""{left} = {right}"",
                ExpressionType.NotEqual => $""{left} <> {right}"",
                ExpressionType.GreaterThan => $""{left} > {right}"",
                ExpressionType.GreaterThanOrEqual => $""{left} >= {right}"",
                ExpressionType.LessThan => $""{left} < {right}"",
                ExpressionType.LessThanOrEqual => $""{left} <= {right}"",
                ExpressionType.AndAlso => $""({left}) AND ({right})"",
                ExpressionType.OrElse => $""({left}) OR ({right})"",
                _ => $""{left} = {right}"" // Fallback
            };
        }

        private string GetColumnName(Expression expression)
        {
            if (expression is MemberExpression member)
            {
                return _dialect.ColumnLeft + member.Member.Name + _dialect.ColumnRight;
            }
            if (expression is UnaryExpression unary && unary.Operand is MemberExpression unaryMember)
            {
                return _dialect.ColumnLeft + unaryMember.Member.Name + _dialect.ColumnRight;
            }
            return ""UnknownColumn"";
        }

        private string GetConstantValue(ConstantExpression constant)
        {
            if (constant.Value == null)
                return ""NULL"";
            
            if (constant.Type == typeof(string))
                return _dialect.StringLeft + constant.Value?.ToString() + _dialect.StringRight;
            
            if (constant.Type == typeof(int) || constant.Type == typeof(long) || 
                constant.Type == typeof(double) || constant.Type == typeof(decimal))
                return constant.Value?.ToString() ?? ""0"";
            
            if (constant.Type == typeof(bool))
                return (bool)constant.Value! ? ""1"" : ""0"";
            
            return _dialect.StringLeft + (constant.Value?.ToString() ?? """") + _dialect.StringRight;
        }

        /// <summary>
        /// Directly generates SQL string for the built query.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }
    }
}
";

    /// <inheritdoc/>
    public override void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization((pi) =>
        {
            pi.AddSource("SqlxAttribute.g.cs", SourceText.From(CSharpAttributeSource, Encoding.UTF8));
        });
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    internal class SyntaxReceiver : ISqlxSyntaxReceiver
    {
        public List<IMethodSymbol> Methods { get; } = new List<IMethodSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // Check method declarations for Sqlx attributes
            if (context.Node is MethodDeclarationSyntax methodDeclarationSyntax)
            {
                // Get the symbol being declared by the method, and keep it if its annotated
                if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not IMethodSymbol methodSymbol) return;

                // Check for method-level attributes
                var hasMethodAttribute = methodSymbol.GetAttributes().Any(ad =>
                    ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.SqlxAttribute" ||
                    ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.RawSqlAttribute");

                // Check for parameter-level attributes that require code generation
                var hasParameterAttribute = methodSymbol.Parameters.Any(param =>
                    param.GetAttributes().Any(ad =>
                        ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.ExpressionToSqlAttribute" ||
                        ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.RawSqlAttribute" ||
                        ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.DbSetTypeAttribute"));

                if (hasMethodAttribute || hasParameterAttribute)
                {
                    Methods.Add(methodSymbol);
                }
            }
        }
    }
}
