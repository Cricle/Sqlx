# SqlxContext - Getting Started Guide

## Overview

SqlxContext is a lightweight context manager for Sqlx that simplifies multi-repository management and unified transaction handling. It provides an EF Core-style API while maintaining Sqlx's core principles of high performance, zero reflection, and AOT compatibility.

## Key Features

- **EF Core-style API**: Access repositories through direct properties (e.g., `context.Users`, `context.Orders`)
- **Unified Transaction Management**: Automatically propagate transactions to all repositories
- **Zero Reflection**: All code is generated at compile time
- **AOT Compatible**: Fully supports Native AOT compilation
- **Minimal Overhead**: Thin wrapper around repository instances
- **Optional**: Existing code continues to work without changes

## Quick Start

### 1. Define Your Entities

```csharp
public class User
{
    public long Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
}

public class Order
{
    public long Id { get; set; }
    public long UserId { get; set; }
    public decimal Total { get; set; }
}
```

### 2. Define Repository Interfaces

```csharp
public interface IUserRepository : ICrudRepository<User, long> { }
public interface IOrderRepository : ICrudRepository<Order, long> { }
```

### 3. Define Repository Implementations

```csharp
[RepositoryFor(typeof(IUserRepository))]
[TableName("users")]
public partial class UserRepository { }

[RepositoryFor(typeof(IOrderRepository))]
[TableName("orders")]
public partial class OrderRepository { }
```

### 4. Define Your Context

Use the `[SqlxContext]` attribute and specify which repositories to include:

```csharp
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
[IncludeRepository(typeof(OrderRepository))]
public partial class AppDbContext : SqlxContext
{
    // Constructor will be auto-generated by source generator
}
```

The source generator will automatically create:
- **Service Provider Field**: Stores `IServiceProvider` for lazy resolution
- **Constructor**: Accepts `DbConnection` and `IServiceProvider`
- **Repository Properties**: `Users` and `Orders` with lazy initialization (created on first access)
- **Transaction Propagation**: Automatically sets Transaction on all initialized repositories
- **Transaction Cleanup**: Automatically clears Transaction on all initialized repositories

**Generated Code Preview:**
```csharp
public partial class AppDbContext
{
    private UserRepository? _users;
    private OrderRepository? _orders;
    private readonly System.IServiceProvider _serviceProvider;

    public AppDbContext(DbConnection connection, IServiceProvider serviceProvider)
        : base(connection, ownsConnection: false)
    {
        _serviceProvider = serviceProvider;
    }

    public UserRepository Users
    {
        get
        {
            if (_users == null)
            {
                _users = _serviceProvider.GetRequiredService<UserRepository>();
                ((ISqlxRepository)_users).Connection = Connection;
                _users.Transaction = Transaction;
            }
            return _users;
        }
    }
    
    // Similar for Orders...
}
```

**Key Features:**
- **Lazy Initialization**: Repositories are only created when first accessed
- **Single Instance**: Each repository is created only once and cached
- **Performance**: Unused repositories are never instantiated
- **Automatic Configuration**: Connection and Transaction are set automatically

### 5. Register with Dependency Injection

```csharp
// Register repositories
services.AddScoped<UserRepository>();
services.AddScoped<OrderRepository>();

// Register context with options
services.AddSqlxContext<AppDbContext>((sp, options) =>
{
    var connection = sp.GetRequiredService<DbConnection>();
    var logger = sp.GetRequiredService<ILogger<AppDbContext>>();
    
    // Configure exception handling
    options.Logger = logger;
    options.EnableRetry = true;
    
    return new AppDbContext(connection, options, sp);
});
```

### 6. Use the Context

```csharp
public class UserService
{
    private readonly AppDbContext _context;
    
    public UserService(AppDbContext context)
    {
        _context = context;
    }
    
    public async Task<User?> GetUserWithOrdersAsync(long userId)
    {
        // Repositories are automatically resolved and configured
        var user = await _context.Users.GetByIdAsync(userId);
        if (user == null) return null;
        
        var orders = await _context.Orders.GetWhereAsync(o => o.UserId == userId);
        return user;
    }
}
```

## Transaction Management

### Basic Transaction Usage

```csharp
await using var context = new AppDbContext(connection, users, orders);

// Begin transaction
await using var transaction = await context.BeginTransactionAsync();

try
{
    // All repository operations participate in the transaction
    var userId = await context.Users.InsertAndGetIdAsync(newUser);
    await context.Orders.InsertAsync(new Order { UserId = userId });
    
    // Commit transaction
    await transaction.CommitAsync();
}
catch
{
    // Transaction is automatically rolled back on dispose
    throw;
}
```

### Using External Transactions

```csharp
await using var connection = new SqliteConnection("Data Source=app.db");
await connection.OpenAsync();

// Create transaction externally
await using var transaction = await connection.BeginTransactionAsync();

await using var context = new AppDbContext(connection, users, orders);
context.UseTransaction(transaction);

try
{
    // All repository operations participate in the external transaction
    var userId = await context.Users.InsertAndGetIdAsync(newUser);
    await context.Orders.InsertAsync(new Order { UserId = userId });
    
    // Commit external transaction
    await transaction.CommitAsync();
}
catch
{
    // Rollback external transaction
    await transaction.RollbackAsync();
    throw;
}
// Context won't dispose the external transaction
```

### Checking Transaction State

```csharp
if (context.HasActiveTransaction)
{
    Console.WriteLine("Transaction is active");
}
```

## Dependency Injection

### ASP.NET Core Registration

```csharp
// Program.cs or Startup.cs
services.AddScoped<DbConnection>(sp => 
    new SqliteConnection("Data Source=app.db"));

// Register repositories
services.AddScoped<UserRepository>();
services.AddScoped<OrderRepository>();

// Register context with options (required)
services.AddSqlxContext<AppDbContext>((sp, options) =>
{
    var connection = sp.GetRequiredService<DbConnection>();
    var logger = sp.GetRequiredService<ILogger<AppDbContext>>();
    
    // Configure exception handling
    options.Logger = logger;
    options.EnableRetry = true;
    
    return new AppDbContext(connection, options, sp);
});
```

### Using with Factory

```csharp
services.AddSqlxContext<AppDbContext>((sp, options) =>
{
    var connection = sp.GetRequiredService<DbConnection>();
    var logger = sp.GetRequiredService<ILogger<AppDbContext>>();
    
    // Configure options
    options.Logger = logger;
    options.EnableRetry = true;
    options.MaxRetryCount = 3;
    
    return new AppDbContext(connection, options, sp);
});
```

### Usage in Controllers

```csharp
public class UsersController : ControllerBase
{
    private readonly AppDbContext _context;
    
    public UsersController(AppDbContext context)
    {
        _context = context;
    }
    
    [HttpGet("{id}")]
    public async Task<IActionResult> GetUser(long id)
    {
        var user = await _context.Users.GetByIdAsync(id);
        return user != null ? Ok(user) : NotFound();
    }
    
    [HttpPost]
    public async Task<IActionResult> CreateUserWithOrder([FromBody] CreateUserRequest request)
    {
        await using var transaction = await _context.BeginTransactionAsync();
        
        try
        {
            var userId = await _context.Users.InsertAndGetIdAsync(request.User);
            request.Order.UserId = userId;
            await _context.Orders.InsertAsync(request.Order);
            
            await transaction.CommitAsync();
            return Ok(new { userId });
        }
        catch
        {
            // Automatic rollback
            throw;
        }
    }
}
```

## Multiple Contexts

You can create multiple contexts with different repository sets:

```csharp
// Application context (includes both repositories)
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
[IncludeRepository(typeof(OrderRepository))]
public partial class AppDbContext : SqlxContext
{
    public AppDbContext(DbConnection connection, 
                       UserRepository users, 
                       OrderRepository orders) 
        : base(connection)
    {
    }
}

// Admin context (includes only UserRepository)
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
public partial class AdminDbContext : SqlxContext
{
    public AdminDbContext(DbConnection connection, 
                         UserRepository users) 
        : base(connection)
    {
    }
}
```

## Manual Context (Without Source Generator)

If you prefer not to use source generation, you can manually create a context:

```csharp
public class ManualDbContext : SqlxContext
{
    private readonly UserRepository _users;
    private readonly OrderRepository _orders;
    
    public ManualDbContext(
        DbConnection connection,
        UserRepository users,
        OrderRepository orders) 
        : base(connection)
    {
        _users = users;
        _orders = orders;
        
        _users.Connection = connection;
        _users.Transaction = Transaction;
        _orders.Connection = connection;
        _orders.Transaction = Transaction;
    }
    
    public UserRepository Users => _users;
    public OrderRepository Orders => _orders;
    
    protected override void PropagateTransactionToRepositories()
    {
        _users.Transaction = Transaction;
        _orders.Transaction = Transaction;
    }
    
    protected override void ClearRepositoryTransactions()
    {
        _users.Transaction = null;
        _orders.Transaction = null;
    }
}
```

## Exception Handling

SqlxContext provides comprehensive exception handling capabilities including automatic logging, retry for transient failures, and custom exception callbacks.

### Basic Exception Handling

All exceptions from repository operations are automatically enriched with context information:

```csharp
try
{
    var user = await context.Users.GetByIdAsync(userId);
}
catch (SqlxException ex)
{
    // Exception includes:
    // - SQL statement that failed
    // - Parameter values (sensitive data redacted)
    // - Method name
    // - Execution duration
    // - Correlation ID for distributed tracing
    // - Transaction isolation level (if in transaction)
    
    Console.WriteLine($"SQL: {ex.Sql}");
    Console.WriteLine($"Method: {ex.MethodName}");
    Console.WriteLine($"Duration: {ex.Duration}");
    Console.WriteLine($"Correlation ID: {ex.CorrelationId}");
}
```

### Configuring Exception Handling

Use `SqlxContextOptions` to configure exception handling behavior:

```csharp
var options = new SqlxContextOptions
{
    // Enable automatic logging
    Logger = loggerFactory.CreateLogger<AppDbContext>(),
    
    // Enable automatic retry for transient failures
    EnableRetry = true,
    MaxRetryCount = 3,
    InitialRetryDelay = TimeSpan.FromMilliseconds(100),
    RetryBackoffMultiplier = 2.0,
    
    // Custom exception callback
    OnException = async (ex) =>
    {
        await telemetry.RecordException(ex);
        await notificationService.NotifyAdmins(ex);
    }
};

var context = new AppDbContext(connection, options, serviceProvider);
```

### Automatic Logging

When a logger is configured, exceptions are automatically logged with structured data:

```csharp
var options = new SqlxContextOptions
{
    Logger = loggerFactory.CreateLogger<AppDbContext>()
};

var context = new AppDbContext(connection, options, serviceProvider);

// Exceptions are automatically logged with:
// - SQL statement
// - Parameters (sanitized)
// - Method name
// - Execution duration
// - Correlation ID
// - Attempt number (for retries)
```

### Automatic Retry

Enable automatic retry for transient database errors:

```csharp
var options = new SqlxContextOptions
{
    EnableRetry = true,
    MaxRetryCount = 3,
    InitialRetryDelay = TimeSpan.FromMilliseconds(100),
    RetryBackoffMultiplier = 2.0,
    Logger = logger
};

// Automatically retries on:
// - Connection timeouts
// - Deadlocks
// - Azure SQL transient errors
// - Other transient database errors

// Uses exponential backoff:
// Retry 1: 100ms delay
// Retry 2: 200ms delay
// Retry 3: 400ms delay
```

### Custom Exception Handling

Use the `OnException` callback for custom error handling:

```csharp
var options = new SqlxContextOptions
{
    OnException = async (ex) =>
    {
        // Send to telemetry
        await telemetry.RecordException(ex);
        
        // Send alerts for critical errors
        if (ex.Severity == ExceptionSeverity.Critical)
        {
            await alertService.SendAlert(ex);
        }
        
        // Log to external service
        await externalLogger.LogAsync(new
        {
            ex.Sql,
            ex.Parameters,
            ex.MethodName,
            ex.Duration,
            ex.CorrelationId
        });
    },
    Logger = logger
};
```

### Sensitive Data Sanitization

Sensitive parameter values are automatically redacted:

```csharp
// Parameters with these names are automatically redacted:
// - password, pwd
// - secret
// - token, apikey, api_key

var user = await context.Users.GetByCredentialsAsync(
    email: "user@example.com",
    password: "secret123"  // Will be redacted in exceptions/logs
);

// Exception will show:
// Parameters: { email: "user@example.com", password: "***REDACTED***" }
```

### Dependency Injection with Options

Register context with exception handling in DI:

```csharp
services.AddSqlxContext<AppDbContext>((sp, options) =>
{
    var connection = sp.GetRequiredService<DbConnection>();
    var logger = sp.GetRequiredService<ILogger<AppDbContext>>();
    
    // Configure exception handling
    options.Logger = logger;
    options.EnableRetry = true;
    options.MaxRetryCount = 3;
    options.OnException = async (ex) =>
    {
        var telemetry = sp.GetRequiredService<ITelemetryService>();
        await telemetry.RecordException(ex);
    };
    
    return new AppDbContext(connection, options, sp);
});
```

### Distributed Tracing

Exceptions automatically include correlation IDs from `Activity.Current`:

```csharp
using var activity = new Activity("ProcessOrder").Start();

try
{
    await context.Orders.InsertAsync(order);
}
catch (SqlxException ex)
{
    // ex.CorrelationId will match activity.Id
    // Enables tracing across distributed systems
    Console.WriteLine($"Trace ID: {ex.CorrelationId}");
}
```

### Transaction Context in Exceptions

Exceptions during transactions include transaction information:

```csharp
await using var transaction = await context.BeginTransactionAsync(
    IsolationLevel.ReadCommitted);

try
{
    await context.Users.InsertAsync(user);
}
catch (SqlxException ex)
{
    // ex.TransactionIsolationLevel will be ReadCommitted
    Console.WriteLine($"Transaction Level: {ex.TransactionIsolationLevel}");
}
```

### Best Practices

1. **Always configure logging in production**
   ```csharp
   options.Logger = loggerFactory.CreateLogger<AppDbContext>();
   ```

2. **Enable retry for transient failures**
   ```csharp
   options.EnableRetry = true;
   options.MaxRetryCount = 3;
   ```

3. **Use OnException for telemetry**
   ```csharp
   options.OnException = async (ex) => await telemetry.RecordException(ex);
   ```

4. **Handle SqlxException specifically**
   ```csharp
   try
   {
       await context.Users.InsertAsync(user);
   }
   catch (SqlxException ex)
   {
       // Rich context available
       logger.LogError(ex, "Failed to insert user: {Sql}", ex.Sql);
   }
   ```

5. **Use correlation IDs for distributed tracing**
   ```csharp
   using var activity = new Activity("Operation").Start();
   // Exceptions will include activity.Id as CorrelationId
   ```

## When to Use SqlxContext

### Use SqlxContext When:

- You have multiple repositories that need to work together
- You need unified transaction management across repositories
- You want an EF Core-style API with lazy repository resolution
- You're building an ASP.NET Core application with DI
- You want performance optimization (only create repositories you actually use)

### Use Manual Repository Management When:

- You only have one or two repositories
- You don't need transaction coordination
- You want maximum control over repository lifecycle
- You're building a simple console application

## Best Practices

1. **Always use transactions for multi-repository operations**
   ```csharp
   await using var transaction = await context.BeginTransactionAsync();
   // ... operations ...
   await transaction.CommitAsync();
   ```

2. **Dispose contexts properly**
   ```csharp
   await using var context = new AppDbContext(connection, users, orders);
   // ... use context ...
   // Automatic disposal
   ```

3. **Use scoped lifetime in ASP.NET Core**
   ```csharp
   services.AddSqlxContext<AppDbContext>(ServiceLifetime.Scoped);
   ```

4. **Check transaction state before operations**
   ```csharp
   if (!context.HasActiveTransaction)
   {
       await using var transaction = await context.BeginTransactionAsync();
       // ... operations ...
       await transaction.CommitAsync();
   }
   ```

5. **Use external transactions for complex scenarios**
   ```csharp
   await using var transaction = await connection.BeginTransactionAsync();
   context.UseTransaction(transaction);
   // ... operations ...
   await transaction.CommitAsync();
   ```

## Migration from Manual Repository Management

### Before (Manual Management)

```csharp
await using var connection = new SqliteConnection("Data Source=app.db");
await connection.OpenAsync();

var userRepo = new UserRepository { Connection = connection };
var orderRepo = new OrderRepository { Connection = connection };

await using var transaction = await connection.BeginTransactionAsync();
userRepo.Transaction = transaction;
orderRepo.Transaction = transaction;

try
{
    await userRepo.InsertAsync(user);
    await orderRepo.InsertAsync(order);
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

### After (SqlxContext)

```csharp
await using var connection = new SqliteConnection("Data Source=app.db");
await connection.OpenAsync();

var users = new UserRepository { Connection = connection };
var orders = new OrderRepository { Connection = connection };

await using var context = new AppDbContext(connection, users, orders);

await using var transaction = await context.BeginTransactionAsync();

try
{
    await context.Users.InsertAsync(user);
    await context.Orders.InsertAsync(order);
    await transaction.CommitAsync();
}
catch
{
    // Automatic rollback on dispose
    throw;
}
```

### Benefits

- **Less boilerplate**: No need to manually set Transaction on each repository
- **Automatic cleanup**: Transaction is automatically rolled back on error
- **Type-safe**: Direct property access with IntelliSense support
- **Cleaner code**: More readable and maintainable

## API Reference

### SqlxContext Class

#### Properties

- `DbConnection Connection` - Gets the database connection
- `DbTransaction? Transaction` - Gets the current transaction (null if no transaction is active)
- `bool HasActiveTransaction` - Gets whether a transaction is currently active

#### Methods

- `Task<DbTransaction> BeginTransactionAsync(IsolationLevel, CancellationToken)` - Begins a new transaction asynchronously
- `DbTransaction BeginTransaction(IsolationLevel)` - Begins a new transaction synchronously
- `void UseTransaction(DbTransaction?)` - Sets an external transaction for the context to use
- `void Dispose()` - Disposes the context and its resources
- `ValueTask DisposeAsync()` - Disposes the context and its resources asynchronously

### Attributes

#### SqlxContextAttribute

Marks a class as a SqlxContext for source generation.

```csharp
[SqlxContext]
public partial class AppDbContext : SqlxContext { }
```

#### IncludeRepositoryAttribute

Specifies a repository implementation to include in a SqlxContext.

```csharp
[IncludeRepository(typeof(UserRepository))]
[IncludeRepository(typeof(OrderRepository))]
public partial class AppDbContext : SqlxContext { }
```

### Extension Methods

#### AddSqlxContext<TContext>(factory)

Registers a SqlxContext with a factory function that provides SqlxContextOptions.

```csharp
services.AddSqlxContext<AppDbContext>((sp, options) =>
{
    var connection = sp.GetRequiredService<DbConnection>();
    var logger = sp.GetRequiredService<ILogger<AppDbContext>>();
    options.Logger = logger;
    options.EnableRetry = true;
    return new AppDbContext(connection, options, sp);
});
```

## Troubleshooting

### "Repository has not been initialized" Error

This error occurs when a repository property is accessed but the repository was not injected via the constructor.

**Solution**: Ensure all repositories are passed to the context constructor:

```csharp
var context = new AppDbContext(connection, users, orders);
```

### "A transaction is already active" Error

This error occurs when trying to begin a new transaction while one is already active.

**Solution**: Check if a transaction is active before beginning a new one:

```csharp
if (!context.HasActiveTransaction)
{
    await using var transaction = await context.BeginTransactionAsync();
    // ...
}
```

### "Cannot set external transaction when an owned transaction is active" Error

This error occurs when trying to use an external transaction while the context owns an active transaction.

**Solution**: Commit or rollback the current transaction before using an external one:

```csharp
// Wrong
await using var tx1 = await context.BeginTransactionAsync();
context.UseTransaction(externalTransaction); // Error!

// Right
await using var tx1 = await context.BeginTransactionAsync();
await tx1.CommitAsync();
context.UseTransaction(externalTransaction); // OK
```

## Real-World Example: TodoWebApi

The [TodoWebApi sample](../samples/TodoWebApi) demonstrates SqlxContext in a production-ready ASP.NET Core application.

### Context Definition

```csharp
/// <summary>
/// Database context for the Todo application.
/// Demonstrates SqlxContext usage with automatic repository resolution via IServiceProvider.
/// </summary>
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(TodoRepository))]
public partial class TodoDbContext : SqlxContext
{
    // Constructor auto-generated by source generator:
    // public TodoDbContext(DbConnection connection, IServiceProvider serviceProvider)
    //     : base(connection, serviceProvider, ownsConnection: false)
    
    // Property auto-generated with lazy resolution:
    // public TodoRepository Todos { get { ... } }
}
```

### DI Registration

```csharp
// Program.cs
var sqliteConnection = new SqliteConnection("Data Source=todos.db;Cache=Shared;Foreign Keys=true");
sqliteConnection.Open();

builder.Services.AddSingleton(_ => sqliteConnection);
builder.Services.AddSingleton<TodoRepository>();
builder.Services.AddSqlxContext<TodoDbContext>(ServiceLifetime.Singleton);

// Expose repository interface for backward compatibility
builder.Services.AddSingleton<ITodoRepository>(sp => 
    sp.GetRequiredService<TodoDbContext>().Todos);
```

### Simple Endpoint (Repository Interface)

```csharp
// Single-repository operations use the interface
app.MapGet("/api/todos", async (ITodoRepository repo) => 
    await repo.GetAllAsync(limit: 100));

app.MapGet("/api/todos/{id}", async (long id, ITodoRepository repo) =>
{
    var todo = await repo.GetByIdAsync(id);
    return todo is not null ? Results.Ok(todo) : Results.NotFound();
});
```

### Transactional Endpoint (Context Injection)

```csharp
// Multi-operation transactions inject the context directly
app.MapPost("/api/todos/bulk", async (List<CreateTodoRequest> requests, TodoDbContext context) =>
{
    if (requests == null || requests.Count == 0)
    {
        return Results.BadRequest(new { Error = "Request list cannot be empty" });
    }

    await using var transaction = await context.BeginTransactionAsync();
    try
    {
        var ids = new List<long>();
        var now = DateTime.UtcNow;
        
        foreach (var request in requests)
        {
            var todo = new Todo 
            { 
                Title = request.Title,
                Description = request.Description,
                Priority = request.Priority,
                CreatedAt = now,
                UpdatedAt = now
            };
            
            // All operations automatically participate in the transaction
            var newId = await context.Todos.InsertAndGetIdAsync(todo, default);
            ids.Add(newId);
        }
        
        // Commit all changes atomically
        await transaction.CommitAsync();
        
        return Results.Json(new 
        { 
            Success = true,
            Count = ids.Count, 
            Ids = ids,
            Message = $"Successfully created {ids.Count} todos in a single transaction"
        });
    }
    catch (Exception ex)
    {
        // Transaction automatically rolled back on dispose
        return Results.Json(new 
        { 
            Success = false,
            Error = ex.Message,
            Message = "Transaction rolled back due to error"
        }, statusCode: 500);
    }
});
```

### Testing the Endpoint

```bash
# Create multiple todos in a single transaction
curl -X POST http://localhost:5000/api/todos/bulk \
  -H "Content-Type: application/json" \
  -d '[
    {"title": "Task 1", "priority": 3},
    {"title": "Task 2", "priority": 4},
    {"title": "Task 3", "priority": 5}
  ]'

# Response:
# {
#   "success": true,
#   "count": 3,
#   "ids": [1, 2, 3],
#   "message": "Successfully created 3 todos in a single transaction"
# }
```

### Key Benefits Demonstrated

1. **Automatic Resolution** - No manual repository injection needed
2. **Lazy Loading** - Repository resolved only when accessed
3. **Transaction Safety** - All operations in one atomic transaction
4. **Error Handling** - Automatic rollback on exceptions
5. **Backward Compatible** - Existing endpoints using `ITodoRepository` continue to work
6. **Type-Safe** - Direct property access with IntelliSense support

For complete source code and more examples, see the [TodoWebApi sample](../samples/TodoWebApi) and [SqlxContext example documentation](../samples/TodoWebApi/SQLXCONTEXT_EXAMPLE.md).

## Next Steps

- Explore the [API Reference](api-reference.md) for detailed documentation
- Check out the [TodoWebApi sample](../samples/TodoWebApi) for a complete example
- Learn about [SQL Templates](sql-templates.md) for custom queries
- Read about [Source Generators](source-generators.md) for advanced usage
