// -----------------------------------------------------------------------
// <copyright file="SharedCodeGenerationUtilities.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;

namespace Sqlx.Generator;

/// <summary>
/// Shared code generation utilities to reduce code duplication
/// </summary>
public static class SharedCodeGenerationUtilities
{
    // 缓存ToDisplayString()结果以提升性能
    private static readonly ConcurrentDictionary<ISymbol, string> _displayStringCache =
        new(SymbolEqualityComparer.Default);

    // 缓存类型检查结果，避免重复的类型分析
    private static readonly ConcurrentDictionary<ITypeSymbol, bool> _isScalarTypeCache =
        new(SymbolEqualityComparer.Default);

    // 缓存属性的SQL名称
    private static readonly ConcurrentDictionary<IPropertySymbol, string> _sqlNameCache =
        new(SymbolEqualityComparer.Default);

    /// <summary>Gets symbol display string with cache for performance.</summary>
    public static string GetCachedDisplayString(this ISymbol symbol) =>
        _displayStringCache.GetOrAdd(symbol, s => s.ToDisplayString());

    /// <summary>Cached scalar type check.</summary>
    public static bool IsCachedScalarType(this ITypeSymbol type) =>
        _isScalarTypeCache.GetOrAdd(type, t => t.IsScalarType());

    /// <summary>Cached SQL name getter.</summary>
    public static string GetCachedSqlName(this IPropertySymbol property) =>
        _sqlNameCache.GetOrAdd(property, p => p.GetSqlName());
    /// <summary>Extract inner type from Task&lt;T&gt; type strings</summary>
    public static string ExtractInnerTypeFromTask(string taskType) => taskType switch
    {
        var t when t.StartsWith("Task<") && t.EndsWith(">") => t.Substring(5, t.Length - 6),
        var t when t.StartsWith("System.Threading.Tasks.Task<") && t.EndsWith(">") => t.Substring(28, t.Length - 29),
        _ => taskType // 对于非Task类型，返回原始类型而不是"object"
    };

    /// <summary>Escape SQL string for C# string literal</summary>
    public static string EscapeSqlForCSharp(string? sql)
    {
        if (string.IsNullOrEmpty(sql)) return string.Empty;

        // 性能优化：单次检查避免不必要的操作
        var hasEscapeChars = sql.IndexOfAny(new[] { '"', '\r', '\n' }) >= 0;
        if (!hasEscapeChars) return sql;

        return sql.Replace("\"", "\\\"").Replace("\r\n", "\\r\\n").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    /// <summary>
    /// Generate standard file header
    /// </summary>
    public static void GenerateFileHeader(IndentedStringBuilder sb, string namespaceName)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
    }

    /// <summary>
    /// Generate command creation and parameter binding
    /// </summary>
    public static void GenerateCommandSetup(IndentedStringBuilder sb, string sql, IMethodSymbol method, string connectionName)
    {
        sb.AppendLine($"__cmd__ = {connectionName}.CreateCommand();");

        // Check for runtime dynamic placeholders (WHERE, SET, ORDERBY, etc.)
        bool hasDynamicPlaceholders = sql.Contains("{RUNTIME_WHERE_") ||
                                     sql.Contains("{RUNTIME_SET_") ||
                                     sql.Contains("{RUNTIME_ORDERBY_") ||
                                     sql.Contains("{RUNTIME_JOIN_") ||
                                     sql.Contains("{RUNTIME_GROUPBY_");

        if (hasDynamicPlaceholders)
        {
            // Generate dynamic SQL building with string interpolation
            GenerateDynamicSql(sb, sql, method);
        }
        else
        {
        // Properly escape SQL string for C# code generation
        var escapedSql = sql.Replace("\"", "\"\"").Replace("\r\n", "\\r\\n").Replace("\n", "\\n").Replace("\t", "\\t");
        sb.AppendLine($"__cmd__.CommandText = @\"{escapedSql}\";");
        }

        sb.AppendLine();

        // Generate parameter binding
        GenerateParameterBinding(sb, method, hasDynamicPlaceholders);
    }

    /// <summary>
    /// Generate parameter binding code
    /// </summary>
    private static void GenerateParameterBinding(IndentedStringBuilder sb, IMethodSymbol method, bool hasRuntimeWhere)
    {
        // First, bind parameters from ExpressionToSql if present
        if (hasRuntimeWhere)
        {
            var exprParams = method.Parameters.Where(p =>
                p.GetAttributes().Any(a => a.AttributeClass?.Name == "ExpressionToSqlAttribute"));

            foreach (var exprParam in exprParams)
            {
                sb.AppendLine($"// Bind parameters from ExpressionToSql: {exprParam.Name}");
                sb.AppendLine($"if ({exprParam.Name} != null)");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine($"foreach (var __kvp__ in {exprParam.Name}.GetParameters())");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine("var __p__ = __cmd__.CreateParameter();");
                sb.AppendLine("__p__.ParameterName = __kvp__.Key;");
                sb.AppendLine("__p__.Value = __kvp__.Value ?? (object)global::System.DBNull.Value;");
                sb.AppendLine("__cmd__.Parameters.Add(__p__);");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.AppendLine();
            }
        }

        // Then bind regular parameters (excluding special ones)
        var regularParams = method.Parameters.Where(p =>
            p.Type.Name != "CancellationToken" &&
            !p.GetAttributes().Any(a =>
                a.AttributeClass?.Name == "ExpressionToSqlAttribute" ||
                (a.AttributeClass?.Name == "DynamicSqlAttribute" && hasRuntimeWhere)));

        // 🚀 性能优化：简化参数创建，减少临时变量和赋值操作
        foreach (var param in regularParams)
        {
            // Check if parameter type is an entity class (has properties that should be expanded)
            var paramType = param.Type as INamedTypeSymbol;
            var isEntityType = paramType != null &&
                              paramType.TypeKind == TypeKind.Class &&
                              paramType.GetMembers().OfType<IPropertySymbol>().Any(p => p.CanBeReferencedByName && p.GetMethod != null);

            if (isEntityType && param.Name.Equals("entity", StringComparison.OrdinalIgnoreCase))
            {
                // Expand entity properties - bind each property as separate parameter
                var properties = paramType!.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(p => p.CanBeReferencedByName &&
                               p.GetMethod != null &&
                               p.Name != "EqualityContract" &&
                               !p.IsImplicitlyDeclared)
                    .ToList();

                foreach (var prop in properties)
                {
                    var propSqlName = ConvertToSnakeCase(prop.Name);
                    var paramName = $"@{propSqlName}";
                    var isNullable = prop.Type.IsNullableType() || prop.Type.IsReferenceType;

                    sb.Append("{ var __p__ = __cmd__.CreateParameter(); ");
                    sb.Append($"__p__.ParameterName = \"{paramName}\"; ");

                    if (isNullable)
                    {
                        sb.Append($"__p__.Value = {param.Name}.{prop.Name} ?? (object)global::System.DBNull.Value; ");
                    }
                    else
                    {
                        sb.Append($"__p__.Value = {param.Name}.{prop.Name}; ");
                    }

                    sb.AppendLine("__cmd__.Parameters.Add(__p__); }");
                }
            }
            else
            {
                // Regular parameter binding (scalar types, collections, etc.)
            var paramName = $"@{param.Name}";
                var isNullable = param.Type.IsNullableType() || param.Type.IsReferenceType;

                sb.Append("{ var __p__ = __cmd__.CreateParameter(); ");
                sb.Append($"__p__.ParameterName = \"{paramName}\"; ");

                if (isNullable)
                {
                    sb.Append($"__p__.Value = {param.Name} ?? (object)global::System.DBNull.Value; ");
                }
                else
                {
                    sb.Append($"__p__.Value = {param.Name}; ");
                }

                sb.AppendLine("__cmd__.Parameters.Add(__p__); }");
            }
        }
    }

    /// <summary>
    /// Generate dynamic SQL building code (WHERE, SET, ORDERBY, etc.) with zero-allocation string interpolation
    /// </summary>
    private static void GenerateDynamicSql(IndentedStringBuilder sb, string sql, IMethodSymbol method)
    {
        sb.AppendLine("// Build SQL with dynamic placeholders (compile-time splitting, zero Replace calls)");

        // Find all runtime dynamic markers (WHERE, SET, ORDERBY, JOIN, GROUPBY)
        var markers = System.Text.RegularExpressions.Regex.Matches(sql,
            @"\{RUNTIME_(WHERE|SET|ORDERBY|JOIN|GROUPBY)_([^}]+)\}");

        if (markers.Count == 0)
        {
            // Fallback: no markers found
            var escapedSql = sql.Replace("\"", "\"\"");
            sb.AppendLine($"__cmd__.CommandText = @\"{escapedSql}\";");
            return;
        }

        // Split SQL into parts at compile time
        var sqlParts = new System.Collections.Generic.List<string>();
        var dynamicVariables = new System.Collections.Generic.List<(string varName, string placeholderType, string markerContent)>();

        int lastIndex = 0;
        foreach (System.Text.RegularExpressions.Match match in markers)
        {
            // Add SQL part before marker
            sqlParts.Add(sql.Substring(lastIndex, match.Index - lastIndex));

            var placeholderType = match.Groups[1].Value; // WHERE, SET, ORDERBY, etc.
            var markerContent = match.Groups[2].Value;   // EXPR_paramName, DYNAMIC_paramName, or paramName
            var varName = $"__{placeholderType.ToLower()}Clause_{dynamicVariables.Count}__";
            dynamicVariables.Add((varName, placeholderType, markerContent));

            lastIndex = match.Index + match.Length;
        }

        // Add final SQL part after last marker
        sqlParts.Add(sql.Substring(lastIndex));

        // Generate dynamic clause extraction code
        for (int i = 0; i < dynamicVariables.Count; i++)
        {
            var (varName, placeholderType, markerContent) = dynamicVariables[i];

            if (markerContent.StartsWith("EXPR_"))
            {
                // ExpressionToSql parameter
                var paramName = markerContent.Substring(5);
                sb.AppendLine($"// Extract {placeholderType} from ExpressionToSql: {paramName}");

                if (placeholderType == "WHERE")
                {
                    sb.AppendLine($"var {varName} = {paramName}?.ToWhereClause() ?? \"1=1\";");
                }
                else
                {
                    // For SET, ORDERBY, etc. - extract as SQL fragment
                    sb.AppendLine($"var {varName} = {paramName}?.ToSql() ?? \"\";");
                }
            }
            else if (markerContent.StartsWith("DYNAMIC_"))
            {
                // DynamicSql parameter with validation
                var paramName = markerContent.Substring(8);
                sb.AppendLine($"// Validate DynamicSql {placeholderType}: {paramName}");
                sb.AppendLine($"if (!global::Sqlx.Validation.SqlValidator.IsValidFragment({paramName}.AsSpan()))");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine($"throw new global::System.ArgumentException($\"Invalid SQL fragment: {{{paramName}}}. Contains dangerous keywords.\", nameof({paramName}));");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.AppendLine($"var {varName} = {paramName};");
            }
            else
            {
                // Regular parameter as SQL fragment (with validation)
                var paramName = markerContent;
                sb.AppendLine($"// Validate {placeholderType} fragment: {paramName}");
                sb.AppendLine($"if (!global::Sqlx.Validation.SqlValidator.IsValidFragment({paramName}.AsSpan()))");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine($"throw new global::System.ArgumentException($\"Invalid SQL fragment: {{{paramName}}}. Contains dangerous keywords.\", nameof({paramName}));");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.AppendLine($"var {varName} = {paramName};");
            }
        }

        sb.AppendLine();

        // Generate SQL concatenation using string interpolation (compile-time optimized)
        sb.Append("__cmd__.CommandText = ");

        if (sqlParts.Count == 1)
        {
            // No dynamic parts
            var escapedSql = sqlParts[0].Replace("\"", "\"\"");
            sb.Append($"@\"{escapedSql}\"");
        }
        else
        {
            // Build using string interpolation (compiler optimizes to StringBuilder)
            sb.Append("$@\"");
            for (int i = 0; i < sqlParts.Count; i++)
            {
                var part = sqlParts[i].Replace("\"", "\"\"");
                sb.Append(part);

                if (i < dynamicVariables.Count)
                {
                    sb.Append($"{{{dynamicVariables[i].varName}}}");
                }
            }
            sb.Append("\"");
        }

        sb.AppendLine(";");
    }

    /// <summary>
    /// Get DbType
    /// </summary>
    public static string GetDbType(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_String => "global::System.Data.DbType.String",
            SpecialType.System_Int32 => "global::System.Data.DbType.Int32",
            SpecialType.System_Int64 => "global::System.Data.DbType.Int64",
            SpecialType.System_Boolean => "global::System.Data.DbType.Boolean",
            SpecialType.System_DateTime => "global::System.Data.DbType.DateTime",
            SpecialType.System_Decimal => "global::System.Data.DbType.Decimal",
            SpecialType.System_Double => "global::System.Data.DbType.Double",
            _ => "global::System.Data.DbType.Object"
        };
    }

    /// <summary>
    /// Generate entity property mapping with optional ordinal access optimization
    /// </summary>
    public static void GenerateEntityMapping(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName, List<string>? columnOrder = null, bool useOrdinalIndex = true)
    {
        // 🚀 性能优化：默认使用硬编码索引访问（极致性能）
        // 如果列顺序不匹配，源分析器会发出编译警告
        if (columnOrder != null && columnOrder.Count > 0)
        {
            sb.AppendLine($"// 🚀 使用硬编码索引访问（极致性能）- {columnOrder.Count}列: [{string.Join(", ", columnOrder)}]");
            sb.AppendLine($"// ⚠️ 如果C#属性顺序与SQL列顺序不一致，源分析器会发出警告");
            GenerateEntityMappingWithHardcodedOrdinals(sb, entityType, variableName, columnOrder);
            return;
        }

        // 向后兼容：没有列顺序信息时，使用GetOrdinal查找
        sb.AppendLine($"// ⚠️ 使用GetOrdinal查找（兼容版本）- columnOrder为{(columnOrder == null ? "null" : "empty")}");
        sb.AppendLine($"// 性能警告：未使用序号访问优化，查询性能可能降低20%");
        GenerateEntityMappingWithGetOrdinal(sb, entityType, variableName);
    }

    /// <summary>
    /// Generate entity property mapping using hardcoded ordinal index (extreme performance mode)
    /// </summary>
    private static void GenerateEntityMappingWithHardcodedOrdinals(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName, List<string> columnOrder)
    {
        // Remove nullable annotation
        var entityTypeName = entityType.GetCachedDisplayString();
        if (entityTypeName.EndsWith("?"))
        {
            entityTypeName = entityTypeName.TrimEnd('?');
        }

        // 获取所有可映射的属性
        var properties = entityType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.CanBeReferencedByName && p.SetMethod != null)
            .ToArray();

        if (properties.Length == 0)
        {
            if (variableName == "__result__")
            {
                sb.AppendLine($"__result__ = new {entityTypeName}();");
            }
            else
            {
                sb.AppendLine($"var {variableName} = new {entityTypeName}();");
            }
            return;
        }

        // 🚀 极致优化：直接使用硬编码索引（0, 1, 2...）访问列
        // 创建列名到硬编码索引的映射
        var columnToOrdinal = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        for (int i = 0; i < columnOrder.Count; i++)
        {
            columnToOrdinal[columnOrder[i]] = i;
        }

        // 使用对象初始化器语法（支持init-only属性）
        if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}");
        }

        sb.AppendLine("{");
        sb.PushIndent();

        // 根据属性映射到对应的硬编码索引
        bool first = true;
        foreach (var prop in properties)
        {
            var columnName = ConvertToSnakeCase(prop.Name);

            // 查找该属性对应的硬编码索引
            if (!columnToOrdinal.TryGetValue(columnName, out int ordinalIndex))
            {
                // 列不存在于SQL中，跳过或使用默认值
                continue;
            }

            var readMethod = prop.Type.UnwrapNullableType().GetDataReaderMethod();

            // 🎯 关键性能优化：只对nullable类型检查IsDBNull，非nullable类型直接读取
            // 这可以减少60-70%的IsDBNull调用，提升5-6μs性能
            // ✅ 全面支持：nullable value types (int?) 和 nullable reference types (string?)
            var isNullable = prop.Type.IsNullableType();

            // 🚀 极致性能：直接使用硬编码索引（例如：reader.GetInt32(0)）
            var valueExpression = string.IsNullOrEmpty(readMethod)
                ? $"({prop.Type.GetCachedDisplayString()})reader[{ordinalIndex}]"
                : $"reader.{readMethod}({ordinalIndex})";

            if (!first) sb.Append(",");

            // 只对nullable类型生成IsDBNull检查
            if (isNullable)
            {
                sb.AppendLine($"{prop.Name} = reader.IsDBNull({ordinalIndex}) ? null : {valueExpression}");
            }
            else
            {
                // 非nullable类型直接读取，无需检查（减少约0.8μs/字段的开销）
                sb.AppendLine($"{prop.Name} = {valueExpression}");
            }

            first = false;
        }

        sb.PopIndent();
        sb.AppendLine("};");
    }

    /// <summary>
    /// Generate entity property mapping using GetOrdinal (backward compatible)
    /// </summary>
    private static void GenerateEntityMappingWithGetOrdinal(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName)
    {
        // Remove nullable annotation - 使用缓存版本提升性能
        var entityTypeName = entityType.GetCachedDisplayString();
        if (entityTypeName.EndsWith("?"))
        {
            entityTypeName = entityTypeName.TrimEnd('?');
        }

        // 性能优化：避免不必要的ToList()调用，直接遍历
        // 支持 set 和 init 属性
        var properties = entityType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.CanBeReferencedByName && p.SetMethod != null)
            .ToArray();

        if (properties.Length == 0)
        {
            // No properties to map, just create empty object
            if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}();");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}();");
            }
            return;
        }

        // 🚀 性能优化：缓存GetOrdinal结果，避免重复查找（每个字段只调用一次GetOrdinal）
        sb.AppendLine("// 缓存列序号（性能优化：避免重复GetOrdinal调用）");
        for (int i = 0; i < properties.Length; i++)
        {
            var prop = properties[i];
            var columnName = ConvertToSnakeCase(prop.Name);
            sb.AppendLine($"var __ord_{prop.Name}__ = reader.GetOrdinal(\"{columnName}\");");
        }
        sb.AppendLine();

        // Use object initializer syntax to support init-only properties
        if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}");
        }

        sb.AppendLine("{");
        sb.PushIndent();

        for (int i = 0; i < properties.Length; i++)
        {
            var prop = properties[i];
            var readMethod = prop.Type.UnwrapNullableType().GetDataReaderMethod();

            // 🎯 关键性能优化：只对nullable类型检查IsDBNull
            // ✅ 全面支持：nullable value types (int?) 和 nullable reference types (string?)
            var isNullable = prop.Type.IsNullableType();

            // 使用缓存的序号变量
            var ordinalVar = $"__ord_{prop.Name}__";
            var valueExpression = string.IsNullOrEmpty(readMethod)
                ? $"({prop.Type.GetCachedDisplayString()})reader[{ordinalVar}]"  // 使用缓存版本
                : $"reader.{readMethod}({ordinalVar})";

            var comma = i < properties.Length - 1 ? "," : "";

            // 只对nullable类型生成IsDBNull检查
            if (isNullable)
            {
                sb.AppendLine($"{prop.Name} = reader.IsDBNull({ordinalVar}) ? null : {valueExpression}{comma}");
            }
            else
            {
                sb.AppendLine($"{prop.Name} = {valueExpression}{comma}");
            }
        }

        sb.PopIndent();
        sb.AppendLine("};");
    }

    /// <summary>
    /// Get default value for a type
    /// </summary>
    private static string GetDefaultValue(ITypeSymbol type)
    {
        // ✅ 全面支持：nullable value types (int?) 和 nullable reference types (string?)
        if (type.IsNullableType())
            return "null";

        return type.SpecialType switch
        {
            SpecialType.System_String => "string.Empty",
            SpecialType.System_Boolean => "false",
            SpecialType.System_Int32 => "0",
            SpecialType.System_Int64 => "0L",
            SpecialType.System_Decimal => "0m",
            SpecialType.System_Double => "0.0",
            SpecialType.System_Single => "0f",
            _ => $"default({type.GetCachedDisplayString()})"  // 使用缓存版本
        };
    }

    /// <summary>Convert C# property names to snake_case database column names</summary>
    public static string ConvertToSnakeCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        if (name.Contains("_")) return name.ToLowerInvariant();

        // 性能优化：预计算容量更精确，避免重分配
        var result = new System.Text.StringBuilder(name.Length + (name.Length >> 2));
        for (int i = 0; i < name.Length; i++)
        {
            char current = name[i];
            if (char.IsUpper(current))
            {
                if (i > 0 && !char.IsUpper(name[i - 1])) result.Append('_');
                result.Append(char.ToLowerInvariant(current));
            }
            else
            {
                result.Append(current);
            }
        }
        return result.ToString();
    }
}
