using System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using Sqlx;
using Sqlx.Annotations;
using TodoWebApi.Models;

namespace TodoWebApi.Services;

/// <summary>
/// Demonstrates dynamic SET clause with string interpolation optimization.
/// Shows 3 ways to build UPDATE statements.
/// </summary>
public interface IDynamicSetRepository
{
    // ========================================
    // 1. Static SET (compile-time known columns)
    // ========================================
    /// <summary>Update specific columns - most efficient.</summary>
    [SqlxAttribute("UPDATE {{table}} SET title = @title, priority = @priority WHERE id = @id")]
    Task<int> UpdateTitleAndPriorityAsync(long id, string title, int priority);
    
    // ========================================
    // 2. Entity-based SET (from entity type)
    // ========================================
    /// <summary>Update all columns except Id - uses entity properties.</summary>
    /// <remarks>
    /// Generated SQL: UPDATE todos SET title = @title, description = @description, 
    /// priority = @priority, is_completed = @is_completed, ... WHERE id = @id
    /// </remarks>
    [SqlxAttribute("UPDATE {{table}} SET {{set --exclude Id}} WHERE id = @id")]
    Task<int> UpdateAllFieldsAsync(long id, Todo entity);
    
    // ========================================
    // 3. DynamicSql SET (runtime-defined columns)
    // ========================================
    /// <summary>Update with dynamic SET clause - advanced use.</summary>
    /// <remarks>
    /// ⚠️ Use with caution! Must validate input to prevent SQL injection.
    /// The framework validates fragment safety using SqlValidator.
    /// 
    /// Usage:
    /// <code>
    /// await repo.DynamicUpdateAsync(123, "priority = 5, updated_at = datetime('now')");
    /// </code>
    /// 
    /// Generated code (optimized with string interpolation):
    /// <code>
    /// // Validate DynamicSql SET: customSet
    /// if (!SqlValidator.IsValidFragment(customSet.AsSpan()))
    ///     throw new ArgumentException("Invalid SQL fragment...");
    /// var __setClause_0__ = customSet;
    /// 
    /// // Zero Replace calls - direct string interpolation
    /// __cmd__.CommandText = $@"UPDATE todos SET {__setClause_0__} WHERE id = @id";
    /// </code>
    /// </remarks>
    [SqlxAttribute("UPDATE {{table}} SET {{set @customSet}} WHERE id = @id")]
    Task<int> DynamicUpdateAsync(long id, [DynamicSql(Type = DynamicSqlType.Fragment)] string customSet);
    
    // ========================================
    // 4. Batch UPDATE with WHERE + SET
    // ========================================
    /// <summary>Batch update with dynamic WHERE and static SET.</summary>
    [SqlxAttribute("UPDATE {{table}} SET is_completed = 1, completed_at = @completedAt WHERE {{where}}")]
    Task<int> BatchCompleteAsync(System.DateTime completedAt, [ExpressionToSql] ExpressionToSqlBase whereExpression);
}

[TableName("todos")]
[SqlDefine(SqlDefineTypes.SQLite)]
[RepositoryFor(typeof(IDynamicSetRepository))]
public partial class DynamicSetRepository(SqliteConnection connection) : IDynamicSetRepository
{
    // Implementation auto-generated by Sqlx
    
    // Optional: monitor generated SQL
    partial void OnExecuting(string operationName, global::System.Data.IDbCommand command)
    {
        System.Diagnostics.Debug.WriteLine($"[{operationName}] SQL: {command.CommandText}");
        foreach (global::System.Data.IDataParameter p in command.Parameters)
        {
            System.Diagnostics.Debug.WriteLine($"  {p.ParameterName} = {p.Value}");
        }
    }
}

