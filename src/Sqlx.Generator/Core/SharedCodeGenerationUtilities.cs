// -----------------------------------------------------------------------
// <copyright file="SharedCodeGenerationUtilities.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;

namespace Sqlx.Generator;

/// <summary>
/// Shared code generation utilities to reduce code duplication
/// </summary>
public static class SharedCodeGenerationUtilities
{
    // ç¼“å­˜ToDisplayString()ç»“æœä»¥æå‡æ€§èƒ½
    private static readonly ConcurrentDictionary<ISymbol, string> _displayStringCache =
        new(SymbolEqualityComparer.Default);

    // ç¼“å­˜ç±»å‹æ£€æŸ¥ç»“æœï¼Œé¿å…é‡å¤çš„ç±»å‹åˆ†æ
    private static readonly ConcurrentDictionary<ITypeSymbol, bool> _isScalarTypeCache =
        new(SymbolEqualityComparer.Default);

    // ç¼“å­˜å±æ€§çš„SQLåç§°
    private static readonly ConcurrentDictionary<IPropertySymbol, string> _sqlNameCache =
        new(SymbolEqualityComparer.Default);

    // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„SymbolDisplayFormatæ¥æ˜¾ç¤ºå¯ç©ºç±»å‹
    // è¿™ç¡®ä¿ int? æ˜¾ç¤ºä¸º "int?" è€Œä¸æ˜¯ "int" æˆ– "Nullable<int>"
    // æ³¨æ„ï¼šä¸ä½¿ç”¨ GlobalNamespaceStyle.Included ä»¥é¿å…åœ¨æ–‡ä»¶åä¸­äº§ç”Ÿæ— æ•ˆå­—ç¬¦ ":"
    private static readonly SymbolDisplayFormat _nullableAwareFormat = new SymbolDisplayFormat(
        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes |
                              SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    /// <summary>Gets symbol display string with cache for performance.</summary>
    public static string GetCachedDisplayString(this ISymbol symbol) =>
        _displayStringCache.GetOrAdd(symbol, s => GetDisplayStringWithNullable(s));

    /// <summary>
    /// Gets display string with proper nullable type handling.
    /// Ensures int? is displayed as "int?" not "int" or "Nullable&lt;int&gt;".
    /// </summary>
    private static string GetDisplayStringWithNullable(ISymbol symbol)
    {
        if (symbol is ITypeSymbol typeSymbol)
        {
            // æ£€æŸ¥æ˜¯å¦æ˜¯ Nullable<T> å€¼ç±»å‹ (å¦‚ int?, long?, bool? ç­‰)
            if (typeSymbol is INamedTypeSymbol namedType &&
                namedType.IsGenericType &&
                namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
            {
                // è·å–å†…éƒ¨ç±»å‹å¹¶æ·»åŠ  ? åç¼€
                var innerType = namedType.TypeArguments[0];
                var innerTypeString = innerType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                return innerTypeString + "?";
            }

            // å¯¹äºå¼•ç”¨ç±»å‹çš„å¯ç©ºæ³¨è§£ï¼Œä½¿ç”¨æ ‡å‡†æ ¼å¼ï¼ˆä¸åŒ…å« global:: å‰ç¼€ï¼‰
            return typeSymbol.ToDisplayString(_nullableAwareFormat);
        }

        return symbol.ToDisplayString();
    }

    /// <summary>Cached scalar type check.</summary>
    public static bool IsCachedScalarType(this ITypeSymbol type) =>
        _isScalarTypeCache.GetOrAdd(type, t => t.IsScalarType());

    /// <summary>Cached SQL name getter.</summary>
    public static string GetCachedSqlName(this IPropertySymbol property) =>
        _sqlNameCache.GetOrAdd(property, p => p.GetSqlName());
    /// <summary>Extract inner type from Task&lt;T&gt; type strings</summary>
    public static string ExtractInnerTypeFromTask(string taskType) => taskType switch
    {
        var t when t.StartsWith("Task<") && t.EndsWith(">") => t.Substring(5, t.Length - 6),
        var t when t.StartsWith("System.Threading.Tasks.Task<") && t.EndsWith(">") => t.Substring(28, t.Length - 29),
        _ => taskType // å¯¹äºéTaskç±»å‹ï¼Œè¿”å›åŸå§‹ç±»å‹è€Œä¸æ˜¯"object"
    };

    /// <summary>Escape SQL string for C# string literal</summary>
    public static string EscapeSqlForCSharp(string? sql)
    {
        if (string.IsNullOrEmpty(sql)) return string.Empty;

        // æ€§èƒ½ä¼˜åŒ–ï¼šå•æ¬¡æ£€æŸ¥é¿å…ä¸å¿…è¦çš„æ“ä½œ
        var hasEscapeChars = sql.IndexOfAny(new[] { '"', '\r', '\n' }) >= 0;
        if (!hasEscapeChars) return sql;

        return sql.Replace("\"", "\\\"").Replace("\r\n", "\\r\\n").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    /// <summary>
    /// Generate standard file header
    /// </summary>
    public static void GenerateFileHeader(IndentedStringBuilder sb, string namespaceName)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
    }

    /// <summary>
    /// Generate command creation and parameter binding
    /// </summary>
    public static void GenerateCommandSetup(IndentedStringBuilder sb, string sql, IMethodSymbol method, string connectionName, INamedTypeSymbol? classSymbol = null)
    {
        sb.AppendLine($"__cmd__ = (global::System.Data.Common.DbCommand){connectionName}.CreateCommand();");

        // ğŸ”§ Transactionæ”¯æŒï¼šå¦‚æœRepositoryè®¾ç½®äº†Transactionå±æ€§ï¼Œå°†å…¶è®¾ç½®åˆ°commandä¸Š
        // è¿™å…è®¸Repositoryçš„æ‰€æœ‰æ“ä½œå‚ä¸åŒä¸€ä¸ªäº‹åŠ¡
        sb.AppendLine("if (Transaction != null)");
        sb.AppendLine("{");
        sb.PushIndent();
        sb.AppendLine("__cmd__.Transaction = Transaction;");
        sb.PopIndent();
        sb.AppendLine("}");
        sb.AppendLine();

        // Extract exclusion list from SQL template for parameter binding
        var excludedProperties = ExtractExcludedPropertiesFromSql(sql);

        // Check for runtime dynamic placeholders (WHERE, SET, ORDERBY, LIMIT, LOGICAL, etc.)
        bool hasDynamicPlaceholders = sql.Contains("{RUNTIME_WHERE_") ||
                                     sql.Contains("{RUNTIME_SET_") ||
                                     sql.Contains("{RUNTIME_ORDERBY_") ||
                                     sql.Contains("{RUNTIME_LIMIT_") ||
                                     sql.Contains("{RUNTIME_OFFSET_") ||
                                     sql.Contains("{RUNTIME_JOIN_") ||
                                     sql.Contains("{RUNTIME_GROUPBY_") ||
                                     sql.Contains("{RUNTIME_NULLABLE_LIMIT_") ||
                                     sql.Contains("{RUNTIME_NULLABLE_OFFSET_") ||
                                     sql.Contains("{RUNTIME_LOGICAL_");

        if (hasDynamicPlaceholders)
        {
            // Generate dynamic SQL building with string interpolation
            GenerateDynamicSql(sb, sql, method, classSymbol);
        }
        else
        {
            // Check if we have collection parameters that need IN clause expansion
            var collectionParams = method.Parameters.Where(IsEnumerableParameter).ToList();

            if (collectionParams.Any())
            {
                // Dynamic SQL with IN clause expansion
                // For verbatim string (@"..."), only double quotes need escaping
                var escapedSql = sql.Replace("\"", "\"\"");
                sb.AppendLine($"var __sql__ = @\"{escapedSql}\";");

                foreach (var param in collectionParams)
                {
                    sb.AppendLine();
                    sb.AppendLine($"// Replace IN (@{param.Name}) or IN @{param.Name} with expanded parameter list");
                    sb.AppendLine($"if ({param.Name} != null && {param.Name}.Any())");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"var __inClause_{param.Name}__ = string.Join(\", \", ");
                    sb.AppendLine($"    global::System.Linq.Enumerable.Range(0, global::System.Linq.Enumerable.Count({param.Name}))");
                    sb.AppendLine($"    .Select(i => $\"@{param.Name}{{i}}\"));");
                    sb.AppendLine($"// Try both formats: IN (@param) and IN @param");
                    sb.AppendLine($"if (__sql__.Contains(\"IN (@{param.Name})\"))");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"__sql__ = __sql__.Replace(\"IN (@{param.Name})\", $\"IN ({{__inClause_{param.Name}__}})\");");
                    sb.PopIndent();
                    sb.AppendLine("}");
                    sb.AppendLine($"else if (__sql__.Contains(\"IN @{param.Name}\"))");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"__sql__ = __sql__.Replace(\"IN @{param.Name}\", $\"IN ({{__inClause_{param.Name}__}})\");");
                    sb.PopIndent();
                    sb.AppendLine("}");
                    sb.PopIndent();
                    sb.AppendLine("}");
                    sb.AppendLine("else");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"// Empty collection - use NULL to return no results");
                    sb.AppendLine($"if (__sql__.Contains(\"IN (@{param.Name})\"))");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"__sql__ = __sql__.Replace(\"IN (@{param.Name})\", \"IN (NULL)\");");
                    sb.PopIndent();
                    sb.AppendLine("}");
                    sb.AppendLine($"else if (__sql__.Contains(\"IN @{param.Name}\"))");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"__sql__ = __sql__.Replace(\"IN @{param.Name}\", \"IN (NULL)\");");
                    sb.PopIndent();
                    sb.AppendLine("}");
                    sb.PopIndent();
                    sb.AppendLine("}");
                }

                sb.AppendLine();
                sb.AppendLine("__cmd__.CommandText = __sql__;");
            }
            else
            {
                // Static SQL (no dynamic placeholders, no collection parameters)
                // For verbatim string (@"..."), only double quotes need escaping
                var escapedSql = sql.Replace("\"", "\"\"");
        sb.AppendLine($"__cmd__.CommandText = @\"{escapedSql}\";");
            }
        }

        sb.AppendLine();

        // Generate parameter binding with exclusion list
        GenerateParameterBinding(sb, method, hasDynamicPlaceholders, excludedProperties);
    }

    /// <summary>
    /// Extract excluded properties from SQL template (e.g., {{values --exclude Id}})
    /// </summary>
    private static HashSet<string> ExtractExcludedPropertiesFromSql(string sql)
    {
        var excluded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        
        // Match {{values --exclude PropertyName}} or {{values --exclude Prop1 Prop2}}
        var valuesRegex = new System.Text.RegularExpressions.Regex(
            @"\{\{values\s+--exclude\s+([^}]+)\}\}", 
            System.Text.RegularExpressions.RegexOptions.IgnoreCase);
        
        var matches = valuesRegex.Matches(sql);
        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            var excludeList = match.Groups[1].Value;
            // Split by space or comma
            foreach (var prop in excludeList.Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries))
            {
                var trimmed = prop.Trim();
                if (!string.IsNullOrEmpty(trimmed))
                {
                    excluded.Add(trimmed);
                    // Also add snake_case version
                    excluded.Add(ConvertToSnakeCase(trimmed));
                }
            }
        }
        
        return excluded;
    }

    /// <summary>
    /// å¤„ç†é€»è¾‘æ ‡è®°å¹¶ç”Ÿæˆæ¡ä»¶ä»£ç 
    /// å¯æ‰©å±•è®¾è®¡ï¼šé€šè¿‡å­—å…¸æ˜ å°„æ¡ä»¶ç±»å‹åˆ°ç”Ÿæˆå™¨å‡½æ•°
    /// </summary>
    private static string ProcessLogicalMarkersInGeneration(IndentedStringBuilder sb, string sql, IMethodSymbol method)
    {
        // å®šä¹‰é€»è¾‘æ¡ä»¶ç”Ÿæˆå™¨ï¼ˆå¯æ‰©å±•ï¼‰
        var logicalGenerators = new Dictionary<string, System.Func<string, IMethodSymbol, IndentedStringBuilder, string>>
        {
            ["IFNULL"] = GenerateIfNullCondition,
            ["IFNOTNULL"] = GenerateIfNotNullCondition,
            ["IFEMPTY"] = GenerateIfEmptyCondition,
            ["IFNOTEMPTY"] = GenerateIfNotEmptyCondition
        };

        // åŒ¹é…é€»è¾‘æ ‡è®°ï¼š{{RUNTIME_LOGICAL_IFNULL_paramName_guid}}{{CONTENT:...}}{{/RUNTIME_LOGICAL}}
        var logicalRegex = new System.Text.RegularExpressions.Regex(
            @"\{\{RUNTIME_LOGICAL_([A-Z]+)_(\w+)_([a-f0-9]+)\}\}\{\{CONTENT:(.*?)\}\}\{\{/RUNTIME_LOGICAL\}\}",
            System.Text.RegularExpressions.RegexOptions.Singleline);

        var sqlBuilder = new System.Text.StringBuilder();
        int lastIndex = 0;
        int conditionIndex = 0;

        foreach (System.Text.RegularExpressions.Match match in logicalRegex.Matches(sql))
        {
            // Add SQL before this logical block
            sqlBuilder.Append(sql.Substring(lastIndex, match.Index - lastIndex));

            var conditionType = match.Groups[1].Value; // IFNULL, IFNOTNULL, etc.
            var paramName = match.Groups[2].Value;
            var content = UnescapeLogicalContent(match.Groups[4].Value);

            // Generate condition code using extensible generator
            if (logicalGenerators.TryGetValue(conditionType, out var generator))
            {
                var placeholder = generator(paramName, method, sb);
                sqlBuilder.Append(placeholder);
            }
            else
            {
                // Unknown condition type - skip
                sb.AppendLine($"// Warning: Unknown logical condition type: {conditionType}");
            }

            // Store content for this condition
            var contentVar = $"__logicalContent_{conditionIndex}__";
            sb.AppendLine($"var {contentVar} = @\"{content.Replace("\"", "\"\"")}\";");
            conditionIndex++;

            lastIndex = match.Index + match.Length;
        }

        // Add remaining SQL
        sqlBuilder.Append(sql.Substring(lastIndex));

        return sqlBuilder.ToString();
    }

    /// <summary>
    /// ç”Ÿæˆ ifnull æ¡ä»¶ä»£ç ï¼ˆå¦‚æœå‚æ•°ä¸º nullï¼ŒåŒ…å«å†…å®¹ï¼‰
    /// </summary>
    private static string GenerateIfNullCondition(string paramName, IMethodSymbol method, IndentedStringBuilder sb)
    {
        var param = method.Parameters.FirstOrDefault(p => 
            p.Name.Equals(paramName, StringComparison.OrdinalIgnoreCase));

        if (param == null)
        {
            return ""; // å‚æ•°ä¸å­˜åœ¨
        }

        var placeholder = $"{{__LOGICAL_IFNULL_{paramName}__}}";
        
        // ç”Ÿæˆæ¡ä»¶å˜é‡
        var varName = $"__ifnull_{paramName}__";
        sb.AppendLine($"// Logical: ifnull {paramName}");
        sb.AppendLine($"var {varName} = {paramName} == null ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        
        return placeholder;
    }

    /// <summary>
    /// ç”Ÿæˆ ifnotnull æ¡ä»¶ä»£ç ï¼ˆå¦‚æœå‚æ•°ä¸ä¸º nullï¼ŒåŒ…å«å†…å®¹ï¼‰
    /// </summary>
    private static string GenerateIfNotNullCondition(string paramName, IMethodSymbol method, IndentedStringBuilder sb)
    {
        var param = method.Parameters.FirstOrDefault(p => 
            p.Name.Equals(paramName, StringComparison.OrdinalIgnoreCase));

        if (param == null)
        {
            return "";
        }

        var placeholder = $"{{__LOGICAL_IFNOTNULL_{paramName}__}}";
        
        var varName = $"__ifnotnull_{paramName}__";
        sb.AppendLine($"// Logical: ifnotnull {paramName}");
        sb.AppendLine($"var {varName} = {paramName} != null ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        
        return placeholder;
    }

    /// <summary>
    /// ç”Ÿæˆ ifempty æ¡ä»¶ä»£ç ï¼ˆå¦‚æœå‚æ•°ä¸ºç©ºï¼ŒåŒ…å«å†…å®¹ï¼‰
    /// ç©ºçš„å®šä¹‰ï¼šnullã€ç©ºå­—ç¬¦ä¸²ã€ç©ºé›†åˆ
    /// </summary>
    private static string GenerateIfEmptyCondition(string paramName, IMethodSymbol method, IndentedStringBuilder sb)
    {
        var param = method.Parameters.FirstOrDefault(p => 
            p.Name.Equals(paramName, StringComparison.OrdinalIgnoreCase));

        if (param == null)
        {
            return "";
        }

        var placeholder = $"{{__LOGICAL_IFEMPTY_{paramName}__}}";
        var varName = $"__ifempty_{paramName}__";
        
        sb.AppendLine($"// Logical: ifempty {paramName}");
        
        // æ ¹æ®å‚æ•°ç±»å‹ç”Ÿæˆä¸åŒçš„ç©ºæ£€æŸ¥
        if (param.Type.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_String)
        {
            sb.AppendLine($"var {varName} = string.IsNullOrEmpty({paramName}) ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        }
        else if (IsEnumerableParameter(param))
        {
            sb.AppendLine($"var {varName} = ({paramName} == null || !{paramName}.Any()) ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        }
        else
        {
            sb.AppendLine($"var {varName} = {paramName} == null ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        }
        
        return placeholder;
    }

    /// <summary>
    /// ç”Ÿæˆ ifnotempty æ¡ä»¶ä»£ç ï¼ˆå¦‚æœå‚æ•°ä¸ä¸ºç©ºï¼ŒåŒ…å«å†…å®¹ï¼‰
    /// </summary>
    private static string GenerateIfNotEmptyCondition(string paramName, IMethodSymbol method, IndentedStringBuilder sb)
    {
        var param = method.Parameters.FirstOrDefault(p => 
            p.Name.Equals(paramName, StringComparison.OrdinalIgnoreCase));

        if (param == null)
        {
            return "";
        }

        var placeholder = $"{{__LOGICAL_IFNOTEMPTY_{paramName}__}}";
        var varName = $"__ifnotempty_{paramName}__";
        
        sb.AppendLine($"// Logical: ifnotempty {paramName}");
        
        // æ ¹æ®å‚æ•°ç±»å‹ç”Ÿæˆä¸åŒçš„éç©ºæ£€æŸ¥
        if (param.Type.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_String)
        {
            sb.AppendLine($"var {varName} = !string.IsNullOrEmpty({paramName}) ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        }
        else if (IsEnumerableParameter(param))
        {
            sb.AppendLine($"var {varName} = ({paramName} != null && {paramName}.Any()) ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        }
        else
        {
            sb.AppendLine($"var {varName} = {paramName} != null ? __logicalContent_{sb.GetHashCode() % 1000}__ : \"\";");
        }
        
        return placeholder;
    }

    /// <summary>
    /// åè½¬ä¹‰é€»è¾‘å†…å®¹
    /// </summary>
    private static string UnescapeLogicalContent(string content)
    {
        return content.Replace("âŸªâŸª", "{{").Replace("âŸ«âŸ«", "}}");
    }

    /// <summary>
    /// Generate parameter binding code
    /// </summary>
    private static void GenerateParameterBinding(IndentedStringBuilder sb, IMethodSymbol method, bool hasRuntimeWhere, HashSet<string>? excludedProperties = null)
    {
        excludedProperties ??= new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        // First, bind parameters from ExpressionToSql if present
        if (hasRuntimeWhere)
        {
            var exprParams = method.Parameters.Where(p =>
                p.GetAttributes().Any(a => a.AttributeClass?.Name == "ExpressionToSqlAttribute"));

            foreach (var exprParam in exprParams)
            {
                sb.AppendLine($"// Bind parameters from ExpressionToSql: {exprParam.Name}");
                sb.AppendLine($"if ({exprParam.Name} != null)");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine($"foreach (var __kvp__ in {exprParam.Name}.GetParameters())");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine("var __p__ = __cmd__.CreateParameter();");
                sb.AppendLine("__p__.ParameterName = __kvp__.Key;");
                sb.AppendLine("__p__.Value = __kvp__.Value ?? (object)global::System.DBNull.Value;");
                sb.AppendLine("__cmd__.Parameters.Add(__p__);");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.AppendLine();
            }
        }

        // Then bind regular parameters (excluding special ones)
        var regularParams = method.Parameters.Where(p =>
            p.Type.Name != "CancellationToken" &&
            !p.GetAttributes().Any(a =>
                a.AttributeClass?.Name == "ExpressionToSqlAttribute" ||
                (a.AttributeClass?.Name == "DynamicSqlAttribute" && hasRuntimeWhere)));

        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç®€åŒ–å‚æ•°åˆ›å»ºï¼Œå‡å°‘ä¸´æ—¶å˜é‡å’Œèµ‹å€¼æ“ä½œ
        foreach (var param in regularParams)
        {
            // Check if parameter type is an entity class (has properties that should be expanded)
            // Exclude: string, primitive types, system types, collections
            var paramType = param.Type as INamedTypeSymbol;
            var isEntityType = paramType != null &&
                              paramType.TypeKind == TypeKind.Class &&
                              paramType.SpecialType == SpecialType.None && // Exclude string, object, etc.
                              !paramType.ContainingNamespace.ToDisplayString().StartsWith("System") && // Exclude System.* types
                              paramType.GetMembers().OfType<IPropertySymbol>().Any(p => p.CanBeReferencedByName && p.GetMethod != null);

            if (isEntityType)
            {
                // Expand entity properties - bind each property as separate parameter
                var properties = paramType!.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(p => p.CanBeReferencedByName &&
                               p.GetMethod != null &&
                               p.Name != "EqualityContract" &&
                               !p.IsImplicitlyDeclared)
                    .ToList();

                foreach (var prop in properties)
                {
                    // ğŸ”§ FIX: Skip excluded properties (e.g., from {{values --exclude Id}})
                    if (excludedProperties.Contains(prop.Name) || 
                        excludedProperties.Contains(ConvertToSnakeCase(prop.Name)))
                    {
                        continue;
                    }

                    var propSqlName = ConvertToSnakeCase(prop.Name);
                    var paramName = $"@{propSqlName}";
                    var isNullable = prop.Type.IsNullableType() || prop.Type.IsReferenceType;

                    sb.Append("{ var __p__ = __cmd__.CreateParameter(); ");
                    sb.Append($"__p__.ParameterName = \"{paramName}\"; ");

                    if (isNullable)
                    {
                        sb.Append($"__p__.Value = {param.Name}.{prop.Name} ?? (object)global::System.DBNull.Value; ");
                    }
                    else
                    {
                        sb.Append($"__p__.Value = {param.Name}.{prop.Name}; ");
                    }

                    sb.AppendLine("__cmd__.Parameters.Add(__p__); }");
                }
            }
            else if (IsEnumerableParameter(param))
            {
                // Collection parameter - expand to multiple parameters for IN queries
                // Get element type to determine if nullable
                var elementType = param.Type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0
                    ? namedType.TypeArguments[0]
                    : null;
                var isElementNullable = elementType != null &&
                                      (elementType.IsNullableType() || elementType.IsReferenceType);

                sb.AppendLine($"// Expand collection parameter: {param.Name} for IN clause");
                sb.AppendLine($"int __index_{param.Name}__ = 0;");
                sb.AppendLine($"foreach (var __item__ in {param.Name})");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine("var __p__ = __cmd__.CreateParameter();");
                sb.AppendLine($"__p__.ParameterName = $\"@{param.Name}{{__index_{param.Name}__}}\";");

                if (isElementNullable)
                {
                    sb.AppendLine("__p__.Value = __item__ ?? (object)global::System.DBNull.Value;");
                }
                else
                {
                    sb.AppendLine("__p__.Value = __item__;");
                }

                sb.AppendLine("__cmd__.Parameters.Add(__p__);");
                sb.AppendLine($"__index_{param.Name}__++;");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.AppendLine();
            }
            else
            {
                // Regular parameter binding (scalar types)
            var paramName = $"@{param.Name}";
                var isNullable = param.Type.IsNullableType() || param.Type.IsReferenceType;

                sb.Append("{ var __p__ = __cmd__.CreateParameter(); ");
                sb.Append($"__p__.ParameterName = \"{paramName}\"; ");

                if (isNullable)
                {
                    sb.Append($"__p__.Value = {param.Name} ?? (object)global::System.DBNull.Value; ");
                }
                else
                {
                    sb.Append($"__p__.Value = {param.Name}; ");
                }

                sb.AppendLine("__cmd__.Parameters.Add(__p__); }");
            }
        }
    }

    /// <summary>
    /// Generate dynamic SQL building code (WHERE, SET, ORDERBY, LOGICAL, etc.) with zero-allocation string interpolation
    /// </summary>
    private static void GenerateDynamicSql(IndentedStringBuilder sb, string sql, IMethodSymbol method, INamedTypeSymbol? classSymbol = null)
    {
        sb.AppendLine("// Build SQL with dynamic placeholders (compile-time splitting, zero Replace calls)");

        // Find all runtime dynamic markers (WHERE, SET, ORDERBY, LIMIT, OFFSET, JOIN, GROUPBY, NULLABLE_LIMIT, NULLABLE_OFFSET, LOGICAL)
        var allMarkers = System.Text.RegularExpressions.Regex.Matches(sql,
            @"\{RUNTIME_(WHERE|SET|ORDERBY|LIMIT|OFFSET|JOIN|GROUPBY|NULLABLE_LIMIT|NULLABLE_OFFSET)_([^}]+)\}|\{RUNTIME_LOGICAL_([^}]+)\}");

        if (allMarkers.Count == 0)
        {
            // Fallback: no markers found
            var escapedSql = sql.Replace("\"", "\"\"");
            sb.AppendLine($"__cmd__.CommandText = @\"{escapedSql}\";");
            return;
        }

        // Process logical placeholders first (they need special handling)
        sql = ProcessLogicalMarkersInGeneration(sb, sql, method);

        // Now find remaining runtime markers (after logical processing)
        var markers = System.Text.RegularExpressions.Regex.Matches(sql,
            @"\{RUNTIME_(WHERE|SET|ORDERBY|LIMIT|OFFSET|JOIN|GROUPBY|NULLABLE_LIMIT|NULLABLE_OFFSET)_([^}]+)\}");

        if (markers.Count == 0)
        {
            // Only logical markers were present, SQL is already built
            return;
        }

        // Split SQL into parts at compile time
        var sqlParts = new System.Collections.Generic.List<string>();
        var dynamicVariables = new System.Collections.Generic.List<(string varName, string placeholderType, string markerContent)>();

        int lastIndex = 0;
        foreach (System.Text.RegularExpressions.Match match in markers)
        {
            // Add SQL part before marker
            sqlParts.Add(sql.Substring(lastIndex, match.Index - lastIndex));

            var placeholderType = match.Groups[1].Value; // WHERE, SET, ORDERBY, etc.
            var markerContent = match.Groups[2].Value;   // EXPR_paramName, DYNAMIC_paramName, or paramName
            var varName = $"__{placeholderType.ToLower()}Clause_{dynamicVariables.Count}__";
            dynamicVariables.Add((varName, placeholderType, markerContent));

            lastIndex = match.Index + match.Length;
        }

        // Add final SQL part after last marker
        sqlParts.Add(sql.Substring(lastIndex));

        // Generate dynamic clause extraction code
        for (int i = 0; i < dynamicVariables.Count; i++)
        {
            var (varName, placeholderType, markerContent) = dynamicVariables[i];

            if (markerContent.StartsWith("NATIVE_EXPR_"))
            {
                // Native Expression<Func<T, bool>> parameter - generate bridge code
                var paramName = markerContent.Substring(12);
                var param = method.Parameters.FirstOrDefault(p => p.Name == paramName);

                if (param != null)
                {
                    // Extract entity type from Expression<Func<TEntity, bool>>
                    var entityType = ExtractEntityTypeFromExpression(param.Type);
                    var dialectValue = GetDialectForMethod(method);

                    sb.AppendLine($"// Bridge: Convert Expression<Func<{entityType.Name}, bool>> to SQL");
                    sb.AppendLine($"var __expr_{paramName}__ = new global::Sqlx.ExpressionToSql<{entityType.ToDisplayString()}>(global::Sqlx.SqlDialect.{dialectValue});");
                    sb.AppendLine($"__expr_{paramName}__.Where({paramName});");
                    sb.AppendLine($"var __{paramName}_clause__ = __expr_{paramName}__.ToWhereClause();");
                    // Add WHERE keyword prefix when condition exists
                    sb.AppendLine($"var {varName} = string.IsNullOrEmpty(__{paramName}_clause__) ? \"\" : \"WHERE \" + __{paramName}_clause__;");
                    sb.AppendLine();

                    // Bind parameters from the expression
                    sb.AppendLine($"// Bind parameters from Expression: {paramName}");
                    sb.AppendLine($"foreach (var __p__ in __expr_{paramName}__.GetParameters())");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine("var __param__ = __cmd__.CreateParameter();");
                    sb.AppendLine("__param__.ParameterName = __p__.Key;");
                    sb.AppendLine("__param__.Value = __p__.Value ?? global::System.DBNull.Value;");
                    sb.AppendLine("__cmd__.Parameters.Add(__param__);");
                    sb.PopIndent();
                    sb.AppendLine("}");
                }
                else
                {
                    sb.AppendLine($"var {varName} = \"\"; // Expression parameter not found");
                }
            }
            else if (markerContent.StartsWith("EXPR_"))
            {
                // ExpressionToSql parameter - need to pass correct dialect
                var paramName = markerContent.Substring(5);
                var dialectValue = classSymbol != null ? GetDialectForClass(classSymbol) : GetDialectForMethod(method);
                
                sb.AppendLine($"// Extract {placeholderType} from ExpressionToSql: {paramName}");

                if (placeholderType == "WHERE")
                {
                    // Add WHERE keyword prefix when condition exists
                    // Pass the correct dialect to ToWhereClause extension method
                    sb.AppendLine($"var __{paramName}_clause__ = {paramName}?.ToWhereClause(global::Sqlx.SqlDefine.{dialectValue}) ?? \"\";");
                    sb.AppendLine($"var {varName} = string.IsNullOrEmpty(__{paramName}_clause__) ? \"\" : \"WHERE \" + __{paramName}_clause__;");
                }
                else if (placeholderType == "SET")
                {
                    // For SET - use ToSetClause() to get SET clause without SET keyword
                    sb.AppendLine($"var {varName} = {paramName}?.ToSetClause() ?? \"\";");
                }
                else
                {
                    // For ORDERBY, etc. - extract as SQL fragment
                    sb.AppendLine($"var {varName} = {paramName}?.ToSql() ?? \"\";");
                }
            }
            else if (markerContent.StartsWith("DYNAMIC_"))
            {
                // DynamicSql parameter with validation
                var paramName = markerContent.Substring(8);
                sb.AppendLine($"// Validate DynamicSql {placeholderType}: {paramName}");
                sb.AppendLine($"if (!global::Sqlx.Validation.SqlValidator.IsValidFragment({paramName}.AsSpan()))");
                sb.AppendLine("{");
                sb.PushIndent();
                sb.AppendLine($"throw new global::System.ArgumentException($\"Invalid SQL fragment: {{{paramName}}}. Contains dangerous keywords.\", nameof({paramName}));");
                sb.PopIndent();
                sb.AppendLine("}");
                sb.AppendLine($"var {varName} = {paramName};");
            }
            else if (placeholderType == "LIMIT" || placeholderType == "OFFSET")
            {
                // LIMIT/OFFSET parameter - ç›´æ¥æ‹¼æ¥ int å€¼åˆ° SQLï¼ˆæ—  SQL æ³¨å…¥é£é™©ï¼‰
                var paramName = markerContent;
                var param = method.Parameters.FirstOrDefault(p => p.Name == paramName);
                
                // è·å–æ•°æ®åº“æ–¹è¨€
                var dialectValue = classSymbol != null ? GetDialectForClass(classSymbol) : GetDialectForMethod(method);

                if (param != null && param.Type.Name.Contains("Nullable"))
                {
                    // å¯ç©ºå‚æ•° - ç”Ÿæˆæ¡ä»¶ä»£ç 
                    if (placeholderType == "LIMIT")
                    {
                        sb.AppendLine($"// Generate LIMIT clause for nullable {paramName} (direct value concatenation)");
                        if (dialectValue == "SqlServer")
                        {
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET 0 ROWS FETCH NEXT {{{paramName}.Value}} ROWS ONLY\" : \"\";");
                        }
                        else if (dialectValue == "Oracle")
                        {
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"FETCH FIRST {{{paramName}.Value}} ROWS ONLY\" : \"\";");
                        }
                        else
                        {
                            // MySQL, PostgreSQL, SQLite
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"LIMIT {{{paramName}.Value}}\" : \"\";");
                        }
                    }
                    else // OFFSET
                    {
                        sb.AppendLine($"// Generate OFFSET clause for nullable {paramName} (direct value concatenation)");
                        if (dialectValue == "SqlServer" || dialectValue == "Oracle")
                        {
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET {{{paramName}.Value}} ROWS\" : \"\";");
                        }
                        else
                        {
                            // MySQL, PostgreSQL, SQLite
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET {{{paramName}.Value}}\" : \"\";");
                        }
                    }
                }
                else
                {
                    // éå¯ç©ºå‚æ•° - ç›´æ¥æ‹¼æ¥å€¼
                    if (placeholderType == "LIMIT")
                    {
                        sb.AppendLine($"// Generate LIMIT clause for {paramName} (direct value concatenation)");
                        if (dialectValue == "SqlServer")
                        {
                            sb.AppendLine($"var {varName} = $\"OFFSET 0 ROWS FETCH NEXT {{{paramName}}} ROWS ONLY\";");
                        }
                        else if (dialectValue == "Oracle")
                        {
                            sb.AppendLine($"var {varName} = $\"FETCH FIRST {{{paramName}}} ROWS ONLY\";");
                        }
                        else
                        {
                            // MySQL, PostgreSQL, SQLite
                            sb.AppendLine($"var {varName} = $\"LIMIT {{{paramName}}}\";");
                        }
                    }
                    else // OFFSET
                    {
                        sb.AppendLine($"// Generate OFFSET clause for {paramName} (direct value concatenation)");
                        if (dialectValue == "SqlServer" || dialectValue == "Oracle")
                        {
                            sb.AppendLine($"var {varName} = $\"OFFSET {{{paramName}}} ROWS\";");
                        }
                        else
                        {
                            // MySQL, PostgreSQL, SQLite
                            sb.AppendLine($"var {varName} = $\"OFFSET {{{paramName}}}\";");
                        }
                    }
                }
            }
            else if (placeholderType == "NULLABLE_LIMIT" || placeholderType == "NULLABLE_OFFSET")
            {
                // ğŸ”§ ä¿®å¤ï¼šå¤„ç†å¯ç©ºçš„ LIMIT/OFFSET å‚æ•°
                // ç”Ÿæˆæ¡ä»¶ä»£ç ï¼šåªæœ‰å½“å‚æ•°æœ‰å€¼æ—¶æ‰æ·»åŠ  LIMIT/OFFSET å­å¥
                var paramName = markerContent;
                var param = method.Parameters.FirstOrDefault(p => p.Name == paramName);

                // è·å–æ–¹è¨€ç±»å‹ä»¥ç”Ÿæˆæ­£ç¡®çš„ SQL è¯­æ³•
                // ä½¿ç”¨ classSymbolï¼ˆå¦‚æœæä¾›ï¼‰è€Œä¸æ˜¯ method.ContainingTypeï¼Œå› ä¸ºæ–¹æ³•å¯èƒ½æ¥è‡ªæ¥å£
                var dialectValue = classSymbol != null ? GetDialectForClass(classSymbol) : GetDialectForMethod(method);

                // æ£€æŸ¥æ˜¯å¦åŒæ—¶å­˜åœ¨ NULLABLE_OFFSET å’Œ NULLABLE_LIMIT
                var hasNullableOffset = dynamicVariables.Any(v => v.placeholderType == "NULLABLE_OFFSET");
                var hasNullableLimit = dynamicVariables.Any(v => v.placeholderType == "NULLABLE_LIMIT");
                
                // ğŸ”§ ä¿®å¤ï¼šæ£€æŸ¥ SQL ä¸­æ˜¯å¦æœ‰éå¯ç©ºçš„ OFFSETï¼ˆç›´æ¥ç”Ÿæˆçš„ OFFSET @xxxï¼‰
                // è¿™ç§æƒ…å†µä¸‹ï¼Œå½“ LIMIT ä¸º null æ—¶ä¹Ÿéœ€è¦ç”Ÿæˆé»˜è®¤çš„ LIMIT å€¼
                var hasNonNullableOffset = sql.Contains("OFFSET @") || sql.Contains("OFFSET $") || sql.Contains("OFFSET :");

                if (placeholderType == "NULLABLE_LIMIT")
                {
                    sb.AppendLine($"// ğŸ”§ Generate conditional LIMIT clause for nullable parameter: {paramName} (direct value concatenation, dialect: {dialectValue})");
                    if (dialectValue == "SqlServer")
                    {
                        // SQL Server éœ€è¦ OFFSET...FETCH è¯­æ³•
                        // å¦‚æœæ²¡æœ‰ OFFSET å‚æ•°ï¼Œéœ€è¦æ·»åŠ  OFFSET 0 ROWS
                        if (hasNullableOffset)
                        {
                            // æœ‰ OFFSET å‚æ•°ï¼Œåªç”Ÿæˆ FETCH éƒ¨åˆ†
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"FETCH NEXT {{{paramName}.Value}} ROWS ONLY\" : \"\";");
                        }
                        else
                        {
                            // æ²¡æœ‰ OFFSET å‚æ•°ï¼Œéœ€è¦æ·»åŠ  OFFSET 0 ROWS
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET 0 ROWS FETCH NEXT {{{paramName}.Value}} ROWS ONLY\" : \"\";");
                        }
                    }
                    else if (dialectValue == "Oracle")
                    {
                        sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"FETCH FIRST {{{paramName}.Value}} ROWS ONLY\" : \"\";");
                    }
                    else
                    {
                        // MySQL, PostgreSQL, SQLite ä½¿ç”¨ LIMIT è¯­æ³•
                        // ğŸ”§ ä¿®å¤ï¼šå¦‚æœæœ‰ OFFSET å‚æ•°ï¼ˆå¯ç©ºæˆ–éå¯ç©ºï¼‰ï¼Œå½“ LIMIT ä¸º null æ—¶éœ€è¦ç”Ÿæˆä¸€ä¸ªå¾ˆå¤§çš„é»˜è®¤å€¼
                        // å› ä¸º SQLite/MySQL/PostgreSQL çš„ OFFSET å¿…é¡»é…åˆ LIMIT ä½¿ç”¨
                        if (hasNullableOffset || hasNonNullableOffset)
                        {
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"LIMIT {{{paramName}.Value}}\" : \"LIMIT 2147483647\";");
                        }
                        else
                        {
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"LIMIT {{{paramName}.Value}}\" : \"\";");
                        }
                    }
                }
                else // NULLABLE_OFFSET
                {
                    sb.AppendLine($"// ğŸ”§ Generate conditional OFFSET clause for nullable parameter: {paramName} (direct value concatenation, dialect: {dialectValue})");
                    if (dialectValue == "SqlServer")
                    {
                        // SQL Server: OFFSET x ROWS (FETCH ç”± LIMIT ç”Ÿæˆ)
                        // å¦‚æœæœ‰ LIMITï¼Œå½“ OFFSET ä¸º null æ—¶éœ€è¦ç”Ÿæˆ OFFSET 0 ROWS
                        if (hasNullableLimit)
                        {
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET {{{paramName}.Value}} ROWS\" : \"OFFSET 0 ROWS\";");
                        }
                        else
                        {
                            sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET {{{paramName}.Value}} ROWS\" : \"\";");
                        }
                    }
                    else if (dialectValue == "Oracle")
                    {
                        sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET {{{paramName}.Value}} ROWS\" : \"\";");
                    }
                    else
                    {
                        // MySQL, PostgreSQL, SQLite
                        sb.AppendLine($"var {varName} = {paramName}.HasValue ? $\"OFFSET {{{paramName}.Value}}\" : \"\";");
                    }
                }
            }
            else
            {
                // Regular parameter as SQL fragment (with validation)
                var paramName = markerContent;
                var param = method.Parameters.FirstOrDefault(p => p.Name == paramName);
                
                // Check if parameter is nullable (string? or Nullable<T>)
                bool isNullable = param != null && (
                    param.Type.NullableAnnotation == Microsoft.CodeAnalysis.NullableAnnotation.Annotated ||
                    param.Type.Name.Contains("Nullable"));
                
                if (isNullable)
                {
                    // For nullable parameters, only validate if not null/empty
                    sb.AppendLine($"// Validate {placeholderType} fragment: {paramName} (nullable)");
                    sb.AppendLine($"if (!string.IsNullOrEmpty({paramName}) && !global::Sqlx.Validation.SqlValidator.IsValidFragment({paramName}.AsSpan()))");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"throw new global::System.ArgumentException($\"Invalid SQL fragment: {{{paramName}}}. Contains dangerous keywords.\", nameof({paramName}));");
                    sb.PopIndent();
                    sb.AppendLine("}");
                    sb.AppendLine($"var {varName} = {paramName} ?? \"\";");
                }
                else
                {
                    // For non-nullable parameters, always validate
                    sb.AppendLine($"// Validate {placeholderType} fragment: {paramName}");
                    sb.AppendLine($"if (!global::Sqlx.Validation.SqlValidator.IsValidFragment({paramName}.AsSpan()))");
                    sb.AppendLine("{");
                    sb.PushIndent();
                    sb.AppendLine($"throw new global::System.ArgumentException($\"Invalid SQL fragment: {{{paramName}}}. Contains dangerous keywords.\", nameof({paramName}));");
                    sb.PopIndent();
                    sb.AppendLine("}");
                    sb.AppendLine($"var {varName} = {paramName};");
                }
            }
        }

        sb.AppendLine();

        // Generate SQL concatenation using string interpolation (compile-time optimized)
        sb.Append("__cmd__.CommandText = ");

        if (sqlParts.Count == 1)
        {
            // No dynamic parts
            var escapedSql = sqlParts[0].Replace("\"", "\"\"");
            sb.Append($"@\"{escapedSql}\"");
        }
        else
        {
            // Build using string interpolation (compiler optimizes to StringBuilder)
            sb.Append("$@\"");
            for (int i = 0; i < sqlParts.Count; i++)
            {
                var part = sqlParts[i].Replace("\"", "\"\"");
                sb.Append(part);

                if (i < dynamicVariables.Count)
                {
                    sb.Append($"{{{dynamicVariables[i].varName}}}");
                }
            }
            sb.Append("\"");
        }

        sb.AppendLine(";");
    }

    /// <summary>
    /// Get DbType
    /// </summary>
    public static string GetDbType(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_String => "global::System.Data.DbType.String",
            SpecialType.System_Int32 => "global::System.Data.DbType.Int32",
            SpecialType.System_Int64 => "global::System.Data.DbType.Int64",
            SpecialType.System_Boolean => "global::System.Data.DbType.Boolean",
            SpecialType.System_DateTime => "global::System.Data.DbType.DateTime",
            SpecialType.System_Decimal => "global::System.Data.DbType.Decimal",
            SpecialType.System_Double => "global::System.Data.DbType.Double",
            _ => "global::System.Data.DbType.Object"
        };
    }

    /// <summary>
    /// Generate entity property mapping with optional ordinal access optimization
    /// </summary>
    public static void GenerateEntityMapping(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName, List<string>? columnOrder = null, bool useOrdinalIndex = true)
    {
        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šé»˜è®¤ä½¿ç”¨ç¡¬ç¼–ç ç´¢å¼•è®¿é—®ï¼ˆæè‡´æ€§èƒ½ï¼‰
        // å¦‚æœåˆ—é¡ºåºä¸åŒ¹é…ï¼Œæºåˆ†æå™¨ä¼šå‘å‡ºç¼–è¯‘è­¦å‘Š
        if (columnOrder != null && columnOrder.Count > 0)
        {
            sb.AppendLine($"// ğŸš€ Access using hardcoded indices- {columnOrder.Count}åˆ—: [{string.Join(", ", columnOrder)}]");
            sb.AppendLine($"// âš ï¸ If the order of C# properties does not match the order of SQL columns, the source analyzer will issue a warning");
            GenerateEntityMappingWithHardcodedOrdinals(sb, entityType, variableName, columnOrder);
            return;
        }

        // å‘åå…¼å®¹ï¼šæ²¡æœ‰åˆ—é¡ºåºä¿¡æ¯æ—¶ï¼Œä½¿ç”¨GetOrdinalæŸ¥æ‰¾
        sb.AppendLine($"// âš ï¸ Use GetOrdinal to search for compatible versions- columnOrder is {(columnOrder == null ? "null" : "empty")}");
        sb.AppendLine($"// Performance warning: Without using serial number access optimization, query performance may decrease by 20%");
        GenerateEntityMappingWithGetOrdinal(sb, entityType, variableName);
    }

    /// <summary>
    /// Generate entity property mapping using hardcoded ordinal index (extreme performance mode)
    /// </summary>
    private static void GenerateEntityMappingWithHardcodedOrdinals(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName, List<string> columnOrder)
    {
        // Remove nullable annotation
        var entityTypeName = entityType.GetCachedDisplayString();
        if (entityTypeName.EndsWith("?"))
        {
            entityTypeName = entityTypeName.TrimEnd('?');
        }

        // è·å–æ‰€æœ‰å¯æ˜ å°„çš„å±æ€§ï¼ˆæ’é™¤ record çš„ EqualityContractï¼‰
        var properties = entityType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.CanBeReferencedByName && p.SetMethod != null && p.Name != "EqualityContract")
            .ToArray();

        if (properties.Length == 0)
        {
            if (variableName == "__result__")
            {
                sb.AppendLine($"__result__ = new {entityTypeName}();");
            }
            else
            {
                sb.AppendLine($"var {variableName} = new {entityTypeName}();");
            }
            return;
        }

        // ğŸš€ æè‡´ä¼˜åŒ–ï¼šç›´æ¥ä½¿ç”¨ç¡¬ç¼–ç ç´¢å¼•ï¼ˆ0, 1, 2...ï¼‰è®¿é—®åˆ—
        // åˆ›å»ºåˆ—ååˆ°ç¡¬ç¼–ç ç´¢å¼•çš„æ˜ å°„
        var columnToOrdinal = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        for (int i = 0; i < columnOrder.Count; i++)
        {
            columnToOrdinal[columnOrder[i]] = i;
        }

        // ä½¿ç”¨å¯¹è±¡åˆå§‹åŒ–å™¨è¯­æ³•ï¼ˆæ”¯æŒinit-onlyå±æ€§ï¼‰
        if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}");
        }

        sb.AppendLine("{");
        sb.PushIndent();

        // æ ¹æ®å±æ€§æ˜ å°„åˆ°å¯¹åº”çš„ç¡¬ç¼–ç ç´¢å¼•
        bool first = true;
        foreach (var prop in properties)
        {
            var columnName = ConvertToSnakeCase(prop.Name);

            // æŸ¥æ‰¾è¯¥å±æ€§å¯¹åº”çš„ç¡¬ç¼–ç ç´¢å¼•
            if (!columnToOrdinal.TryGetValue(columnName, out int ordinalIndex))
            {
                // åˆ—ä¸å­˜åœ¨äºSQLä¸­ï¼Œè·³è¿‡æˆ–ä½¿ç”¨é»˜è®¤å€¼
                continue;
            }

            var readMethod = prop.Type.UnwrapNullableType().GetDataReaderMethod();

            // ğŸ¯ å…³é”®æ€§èƒ½ä¼˜åŒ–ï¼šåªå¯¹nullableç±»å‹æ£€æŸ¥IsDBNullï¼Œénullableç±»å‹ç›´æ¥è¯»å–
            // è¿™å¯ä»¥å‡å°‘60-70%çš„IsDBNullè°ƒç”¨ï¼Œæå‡5-6Î¼sæ€§èƒ½
            // âœ… å…¨é¢æ”¯æŒï¼šnullable value types (int?) å’Œ nullable reference types (string?)
            var isNullable = prop.Type.IsNullableType();

            // ğŸš€ æè‡´æ€§èƒ½ï¼šç›´æ¥ä½¿ç”¨ç¡¬ç¼–ç ç´¢å¼•ï¼ˆä¾‹å¦‚ï¼šreader.GetInt32(0)ï¼‰
            var valueExpression = string.IsNullOrEmpty(readMethod)
                ? $"({prop.Type.GetCachedDisplayString()})reader[{ordinalIndex}]"
                : $"reader.{readMethod}({ordinalIndex})";

            if (!first) sb.Append(",");

            // åªå¯¹nullableç±»å‹ç”ŸæˆIsDBNullæ£€æŸ¥
            if (isNullable)
            {
                sb.AppendLine($"{prop.Name} = reader.IsDBNull({ordinalIndex}) ? null : {valueExpression}");
            }
            else
            {
                // énullableç±»å‹ç›´æ¥è¯»å–ï¼Œæ— éœ€æ£€æŸ¥ï¼ˆå‡å°‘çº¦0.8Î¼s/å­—æ®µçš„å¼€é”€ï¼‰
                sb.AppendLine($"{prop.Name} = {valueExpression}");
            }

            first = false;
        }

        sb.PopIndent();
        sb.AppendLine("};");
    }

    /// <summary>
    /// Generate entity property mapping using GetOrdinal (backward compatible)
    /// </summary>
    private static void GenerateEntityMappingWithGetOrdinal(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName)
    {
        // Remove nullable annotation - ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬æå‡æ€§èƒ½
        var entityTypeName = entityType.GetCachedDisplayString();
        if (entityTypeName.EndsWith("?"))
        {
            entityTypeName = entityTypeName.TrimEnd('?');
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…ä¸å¿…è¦çš„ToList()è°ƒç”¨ï¼Œç›´æ¥éå†
        // æ”¯æŒ set å’Œ init å±æ€§ï¼ˆæ’é™¤ record çš„ EqualityContractï¼‰
        var properties = entityType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.CanBeReferencedByName && p.SetMethod != null && p.Name != "EqualityContract")
            .ToArray();

        if (properties.Length == 0)
        {
            // No properties to map, just create empty object
        if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}();");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}();");
            }
            return;
        }

        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜GetOrdinalç»“æœï¼Œé¿å…é‡å¤æŸ¥æ‰¾ï¼ˆæ¯ä¸ªå­—æ®µåªè°ƒç”¨ä¸€æ¬¡GetOrdinalï¼‰
        sb.AppendLine("// ç¼“å­˜åˆ—åºå·ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼šé¿å…é‡å¤GetOrdinalè°ƒç”¨ï¼‰");
        for (int i = 0; i < properties.Length; i++)
        {
            var prop = properties[i];
            var columnName = ConvertToSnakeCase(prop.Name);
            sb.AppendLine($"var __ord_{prop.Name}__ = reader.GetOrdinal(\"{columnName}\");");
        }
        sb.AppendLine();

        // Use object initializer syntax to support init-only properties
        if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}");
        }

        sb.AppendLine("{");
        sb.PushIndent();

        for (int i = 0; i < properties.Length; i++)
        {
            var prop = properties[i];
            var readMethod = prop.Type.UnwrapNullableType().GetDataReaderMethod();

            // ğŸ¯ å…³é”®æ€§èƒ½ä¼˜åŒ–ï¼šåªå¯¹nullableç±»å‹æ£€æŸ¥IsDBNull
            // âœ… å…¨é¢æ”¯æŒï¼šnullable value types (int?) å’Œ nullable reference types (string?)
            var isNullable = prop.Type.IsNullableType();

            // ä½¿ç”¨ç¼“å­˜çš„åºå·å˜é‡
            var ordinalVar = $"__ord_{prop.Name}__";
            var valueExpression = string.IsNullOrEmpty(readMethod)
                ? $"({prop.Type.GetCachedDisplayString()})reader[{ordinalVar}]"  // ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬
                : $"reader.{readMethod}({ordinalVar})";

            var comma = i < properties.Length - 1 ? "," : "";

            // åªå¯¹nullableç±»å‹ç”ŸæˆIsDBNullæ£€æŸ¥
            if (isNullable)
            {
                sb.AppendLine($"{prop.Name} = reader.IsDBNull({ordinalVar}) ? null : {valueExpression}{comma}");
            }
            else
            {
                sb.AppendLine($"{prop.Name} = {valueExpression}{comma}");
            }
        }

        sb.PopIndent();
        sb.AppendLine("};");
    }

    /// <summary>
    /// Get default value for a type
    /// </summary>
    private static string GetDefaultValue(ITypeSymbol type)
    {
        // âœ… å…¨é¢æ”¯æŒï¼šnullable value types (int?) å’Œ nullable reference types (string?)
        if (type.IsNullableType())
            return "null";

        return type.SpecialType switch
        {
            SpecialType.System_String => "string.Empty",
            SpecialType.System_Boolean => "false",
            SpecialType.System_Int32 => "0",
            SpecialType.System_Int64 => "0L",
            SpecialType.System_Decimal => "0m",
            SpecialType.System_Double => "0.0",
            SpecialType.System_Single => "0f",
            _ => $"default({type.GetCachedDisplayString()})"  // ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬
        };
    }

    /// <summary>Convert C# property names to snake_case database column names</summary>
    public static string ConvertToSnakeCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        if (name.Contains("_")) return name.ToLowerInvariant();

        // æ€§èƒ½ä¼˜åŒ–ï¼šé¢„è®¡ç®—å®¹é‡æ›´ç²¾ç¡®ï¼Œé¿å…é‡åˆ†é…
        var result = new System.Text.StringBuilder(name.Length + (name.Length >> 2));
        for (int i = 0; i < name.Length; i++)
        {
            char current = name[i];
            if (char.IsUpper(current))
            {
                if (i > 0 && !char.IsUpper(name[i - 1])) result.Append('_');
                result.Append(char.ToLowerInvariant(current));
            }
            else
            {
                result.Append(current);
            }
        }
        return result.ToString();
    }

    /// <summary>
    /// Extract entity type from Expression&lt;Func&lt;TEntity, bool&gt;&gt;
    /// </summary>
    private static INamedTypeSymbol ExtractEntityTypeFromExpression(ITypeSymbol expressionType)
    {
        // Expression<Func<TEntity, bool>>
        //                  ^^^^^^^ extract this
        if (expressionType is INamedTypeSymbol namedType &&
            namedType.TypeArguments.Length > 0 &&
            namedType.TypeArguments[0] is INamedTypeSymbol funcType &&
            funcType.TypeArguments.Length > 0)
        {
            return (INamedTypeSymbol)funcType.TypeArguments[0];
        }

        throw new System.InvalidOperationException($"Cannot extract entity type from Expression parameter: {expressionType.ToDisplayString()}");
    }

    /// <summary>
    /// Get database dialect for a method (from [SqlDefine] attribute on class)
    /// </summary>
    private static string GetDialectForMethod(IMethodSymbol method)
    {
        var classSymbol = method.ContainingType;
        return GetDialectForClass(classSymbol);
    }

    /// <summary>
    /// Get database dialect for a class (from [SqlDefine] attribute)
    /// </summary>
    private static string GetDialectForClass(INamedTypeSymbol classSymbol)
    {
        // Check [SqlDefine] attribute
        var sqlDefineAttr = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "SqlDefineAttribute");

        if (sqlDefineAttr != null && sqlDefineAttr.ConstructorArguments.Length > 0)
        {
            var enumValue = sqlDefineAttr.ConstructorArguments[0].Value;
            return MapDialectEnumToString(enumValue);
        }

        return "SqlServer"; // Default
    }

    /// <summary>
    /// Map SqlDefineTypes enum value to dialect string
    /// SqlDefineTypes: MySql=0, SqlServer=1, PostgreSql=2, Oracle=3, DB2=4, SQLite=5
    /// Returns the exact field name as defined in SqlDefine class
    /// </summary>
    private static string MapDialectEnumToString(object? enumValue)
    {
        return enumValue switch
        {
            0 => "MySql",       // SqlDefine.MySql
            1 => "SqlServer",   // SqlDefine.SqlServer
            2 => "PostgreSql",  // SqlDefine.PostgreSql
            3 => "Oracle",      // SqlDefine.Oracle
            4 => "DB2",         // SqlDefine.DB2
            5 => "SQLite",      // SqlDefine.SQLite
            _ => "SqlServer"    // Default
        };
    }

    /// <summary>
    /// Checks if a parameter is a collection type (IEnumerable, List, Array, etc.) but NOT string.
    /// </summary>
    public static bool IsEnumerableParameter(IParameterSymbol param)
    {
        var type = param.Type;

        // Exclude string (even though it's IEnumerable<char>)
        if (type.SpecialType == SpecialType.System_String)
            return false;

        // Check for array types
        if (type is IArrayTypeSymbol)
            return true;

        // Check for IEnumerable<T>, List<T>, etc.
        if (type is INamedTypeSymbol namedType)
        {
            // Check if the type itself is IEnumerable<T>
            if (namedType.Name == "IEnumerable" &&
                namedType.ContainingNamespace?.ToDisplayString() == "System.Collections.Generic")
            {
                return true;
            }

            // Check if any of its interfaces is IEnumerable<T>
            return namedType.AllInterfaces.Any(i =>
                i.Name == "IEnumerable" &&
                i.ContainingNamespace?.ToDisplayString() == "System.Collections.Generic");
        }

        return false;
    }
}
