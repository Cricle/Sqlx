C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\bin\Debug\net6.0\Sqlx.Tests.dll (.NETCoreApp,Version=v6.0)鐨勬祴璇曡繍琛?
VSTest 鐗堟湰 17.14.1 (x64)

C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\bin\Debug\net8.0\Sqlx.Tests.dll (.NETCoreApp,Version=v8.0)鐨勬祴璇曡繍琛?
VSTest 鐗堟湰 17.14.1 (x64)

姝ｅ湪鍚姩娴嬭瘯鎵ц锛岃绋嶅€?..
鎬诲叡 1 涓祴璇曟枃浠朵笌鎸囧畾妯″紡鐩稿尮閰嶃€?
姝ｅ湪鍚姩娴嬭瘯鎵ц锛岃绋嶅€?..
鎬诲叡 1 涓祴璇曟枃浠朵笌鎸囧畾妯″紡鐩稿尮閰嶃€?
  澶辫触 MapResultSetToProcedure [171 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M()鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚List<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapResultSetToProcedure() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 68

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Item has 0 attributes:
 No RepositoryFor attribute found on Item
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 MapResultSetToProcedure [218 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M()鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚List<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapResultSetToProcedure() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 68
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Item has 0 attributes:
 No RepositoryFor attribute found on Item
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 MapSingleObjectToProcedureFromDbContext [188 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M()鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚tem鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapSingleObjectToProcedureFromDbContext() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 132
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 MapSingleObjectToProcedureConnection [251 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M()鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapSingleObjectToProcedureConnection() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 194
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Item has 0 attributes:
 No RepositoryFor attribute found on Item
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 MapListFromDbContext [222 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M(int, int?)鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚List<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚tem鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapListFromDbContext() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 257
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 NoResults [204 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鍒嗛儴鏂规硶鈥淐.M(int, string?)鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.NoResults() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 306
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 MapSingleObjectToProcedureFromDbContext [125 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M()鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚tem鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapSingleObjectToProcedureFromDbContext() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 132

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 MapSingleObjectToProcedureConnection [134 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M()鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapSingleObjectToProcedureConnection() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 194

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Item has 0 attributes:
 No RepositoryFor attribute found on Item
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 MapListFromDbContext [155 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
搴旇緭鍏?;
鍒嗛儴鏂规硶鈥淐.M(int, int?)鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚List<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淚tem鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.MapListFromDbContext() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 257

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 NoResults [136 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鍒嗛儴鏂规硶鈥淐.M(int, string?)鈥濆繀椤诲叿鏈夊疄鐜伴儴鍒嗭紝鍥犱负瀹冨叿鏈夊彲璁块棶鎬т慨楗扮銆?鍒嗛儴鏂规硶蹇呴』鍦ㄥ垎閮ㄧ被鍨嬪唴澹版槑
鈥淪qlx鈥濅笉鏄壒鎬х被

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 42
   at Sqlx.Tests.AsyncSqlConnectionTests.NoResults() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\AsyncSqlConnectionTests.cs:line 306

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 BatchCommand_WithCollectionParameter_GeneratesCorrectCode [232 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertEntities(IEnumerable<TestEntity>)鈥?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithCollectionParameter_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 52
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_AsyncMethod_GeneratesAsyncExecution [215 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertEntitiesAsync(IEnumerable<TestEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_AsyncMethod_GeneratesAsyncExecution() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 94
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithoutCollectionParameter_GeneratesError [249 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertEntities(int, string)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithoutCollectionParameter_GeneratesError() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 128
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithRawSql_GeneratesCorrectImplementation [154 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertWithSql(IEnumerable<TestEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩awSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩awSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithRawSql_GeneratesCorrectImplementation() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 170
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithComplexEntity_HandlesAllProperties [158 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertComplexAsync(IEnumerable<ComplexEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithComplexEntity_HandlesAllProperties() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 216
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class ComplexEntity has 0 attributes:
 No RepositoryFor attribute found on ComplexEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithTransaction_IncludesTransactionHandling [181 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertWithTransactionAsync(IEnumerable<TestEntity>, DbTransaction)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithTransaction_IncludesTransactionHandling() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 261
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_ReturnsCorrectType_BasedOnMethodSignature [148 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertVoid(IEnumerable<TestEntity>)鈥?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertInt(IEnumerable<TestEntity>)鈥?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertTaskVoid(IEnumerable<TestEntity>)鈥?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertTaskInt(IEnumerable<TestEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_ReturnsCorrectType_BasedOnMethodSignature() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 309
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithCollectionParameter_GeneratesCorrectCode [130 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertEntities(IEnumerable<TestEntity>)鈥?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithCollectionParameter_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 52

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_AsyncMethod_GeneratesAsyncExecution [101 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertEntitiesAsync(IEnumerable<TestEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_AsyncMethod_GeneratesAsyncExecution() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 94

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithoutCollectionParameter_GeneratesError [112 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertEntities(int, string)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithoutCollectionParameter_GeneratesError() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 128

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithRawSql_GeneratesCorrectImplementation [104 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertWithSql(IEnumerable<TestEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩awSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩awSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithRawSql_GeneratesCorrectImplementation() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 170

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithComplexEntity_HandlesAllProperties [122 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertComplexAsync(IEnumerable<ComplexEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithComplexEntity_HandlesAllProperties() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 216

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class ComplexEntity has 0 attributes:
 No RepositoryFor attribute found on ComplexEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_WithTransaction_IncludesTransactionHandling [92 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertWithTransactionAsync(IEnumerable<TestEntity>, DbTransaction)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_WithTransaction_IncludesTransactionHandling() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 261

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 BatchCommand_ReturnsCorrectType_BasedOnMethodSignature [93 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertVoid(IEnumerable<TestEntity>)鈥?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertInt(IEnumerable<TestEntity>)鈥?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertTaskVoid(IEnumerable<TestEntity>)鈥?鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.BatchInsertTaskInt(IEnumerable<TestEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteTypeAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淪qlExecuteType鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?鈥淪qlExecuteTypes鈥濅笉鍙闂紝鍥犱负瀹冨叿鏈変竴瀹氱殑淇濇姢绾у埆
绫诲瀷鈥淓num鈥濆湪鏈紩鐢ㄧ殑绋嬪簭闆嗕腑瀹氫箟銆傚繀椤绘坊鍔犲绋嬪簭闆嗏€渘etstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51鈥濈殑寮曠敤銆?
Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.BatchCommandTests.BatchCommand_ReturnsCorrectType_BasedOnMethodSignature() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\BatchCommandTests.cs:line 309

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 NoResults [129 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鈥淭ask鈥濅笉鍖呭惈閲囩敤 0 涓弬鏁扮殑鏋勯€犲嚱鏁?鐢变簬 "C.M(int, string?, CancellationToken)" 鏄繑鍥?"Task" 鐨勫紓姝ユ柟娉曪紝鍥犳杩斿洖鍏抽敭瀛椾笉寰楀悗璺熷璞¤〃杈惧紡

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===
=== Generated File ===
// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public async partial System.Threading.Tasks.Task M(int clientId, string? personId, System.Threading.CancellationToken cancellationToken)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                await __conn__.OpenAsync(cancellationToken);
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                client_id_p.ParameterName = "@client_id";
                client_id_p.DbType = global::System.Data.DbType.Int32;
                client_id_p.Value = clientId;
                __cmd__.Parameters.Add(client_id_p);

                global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                person_id_p.ParameterName = "@person_id";
                person_id_p.DbType = global::System.Data.DbType.String;
                person_id_p.Value = personId;
                __cmd__.Parameters.Add(person_id_p);

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    using(global::System.Data.Common.DbDataReader __reader__ = await __cmd__.ExecuteReaderAsync(cancellationToken))
                    {
                        if(!await __reader__.ReadAsync(cancellationToken)) throw new global::System.InvalidOperationException(
                                "Sequence contains no elements");

                        System.Threading.Tasks.Task __data__ = new  System.Threading.Tasks.Task ();
                        OnExecuted("M", __cmd__, __data__, 
                            global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                        return __data__;
                    }
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}
=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.VerifyCSharp(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 64
   at Sqlx.Tests.CancellationTokenTests.NoResults() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CancellationTokenTests.cs:line 57

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 NoResults [147 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鈥淭ask鈥濅笉鍖呭惈閲囩敤 0 涓弬鏁扮殑鏋勯€犲嚱鏁?鐢变簬 "C.M(int, string?, CancellationToken)" 鏄繑鍥?"Task" 鐨勫紓姝ユ柟娉曪紝鍥犳杩斿洖鍏抽敭瀛椾笉寰楀悗璺熷璞¤〃杈惧紡

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===
=== Generated File ===
// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public async partial System.Threading.Tasks.Task M(int clientId, string? personId, System.Threading.CancellationToken cancellationToken)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                await __conn__.OpenAsync(cancellationToken);
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                client_id_p.ParameterName = "@client_id";
                client_id_p.DbType = global::System.Data.DbType.Int32;
                client_id_p.Value = clientId;
                __cmd__.Parameters.Add(client_id_p);

                global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                person_id_p.ParameterName = "@person_id";
                person_id_p.DbType = global::System.Data.DbType.String;
                person_id_p.Value = personId;
                __cmd__.Parameters.Add(person_id_p);

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    using(global::System.Data.Common.DbDataReader __reader__ = await __cmd__.ExecuteReaderAsync(cancellationToken))
                    {
                        if(!await __reader__.ReadAsync(cancellationToken)) throw new global::System.InvalidOperationException(
                                "Sequence contains no elements");

                        System.Threading.Tasks.Task __data__ = new  System.Threading.Tasks.Task ();
                        OnExecuted("M", __cmd__, __data__, 
                            global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                        return __data__;
                    }
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}
=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.VerifyCSharp(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 64
   at Sqlx.Tests.CancellationTokenTests.NoResults() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CancellationTokenTests.cs:line 57
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 DbDataReaderResult [94 ms]
  閿欒娑堟伅:
   Assert.AreEqual 澶辫触銆傚簲涓? <// <auto-generated>
// Code generated by Stored Procedures Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591

namespace Foo
{

    using System;
    using System.Collections.Generic;
    using System.Data.Common;
    using System.Linq;

    partial class C
    {
        public partial System.Data.Common.DbDataReader M(int clientId, string? personId)
        {
            var connection = this.connection;
            if(connection.State != global::System.Data.ConnectionState.Open)
            {
                connection.Open();
            }
            using var command = connection.CreateCommand();
            var sqlQuery = @"sp_TestSP @client_id, @person_id";
            command.CommandText = sqlQuery;
            var __result = command.ExecuteReader();
            return __result;
        }

    }
}>锛屽疄闄呬负: <// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}


// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public partial System.Data.Common.DbDataReader M(int clientId, string? personId)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                __conn__.Open();
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                client_id_p.ParameterName = "@client_id";
                client_id_p.DbType = global::System.Data.DbType.Int32;
                client_id_p.Value = clientId;
                __cmd__.Parameters.Add(client_id_p);

                global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                person_id_p.ParameterName = "@person_id";
                person_id_p.DbType = global::System.Data.DbType.String;
                person_id_p.Value = personId;
                __cmd__.Parameters.Add(person_id_p);

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                    {
                        if(!__reader__.Read()) throw new global::System.InvalidOperationException(
                                "Sequence contains no elements");

                        System.Data.Common.DbDataReader __data__ = __reader__;
                        OnExecuted("M", __cmd__, __data__, 
                            global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                        return __data__;
                    }
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.DbDataReaderTests.DbDataReaderResult() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\DbDataReaderTests.cs:line 70

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // Code generated by Sqlx Code Generator.
 // Changes may cause incorrect behavior and will be lost if the code is
 // regenerated.
 // </auto-generated>
 #nullable enable
 #pragma warning disable CS8618, CS8625, CS8629
 
 using System.Linq;
 
 namespace Foo
 {
     internal partial class C
     {
         public partial System.Data.Common.DbDataReader M(int clientId, string? personId)
         {
             global::System.Data.Common.DbConnection __conn__ = connection ?? 
                 throw new global::System.ArgumentNullException("connection");
             if(__conn__.State != global::System.Data.ConnectionState.Open)
             {
                 __conn__.Open();
             }
             using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
             {
                 __cmd__.CommandText = "EXEC sp_TestSP";
 
                 global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                 client_id_p.ParameterName = "@client_id";
                 client_id_p.DbType = global::System.Data.DbType.Int32;
                 client_id_p.Value = clientId;
                 __cmd__.Parameters.Add(client_id_p);
 
                 global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                 person_id_p.ParameterName = "@person_id";
                 person_id_p.DbType = global::System.Data.DbType.String;
                 person_id_p.Value = personId;
                 __cmd__.Parameters.Add(person_id_p);
 
                 global::System.Int64 __startTime__ = 
                     global::System.Diagnostics.Stopwatch.GetTimestamp();
                 try
                 {
                     OnExecuting("M", __cmd__);
                     using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                     {
                         if(!__reader__.Read()) throw new global::System.InvalidOperationException(
                                 "Sequence contains no elements");
 
                         System.Data.Common.DbDataReader __data__ = __reader__;
                         OnExecuted("M", __cmd__, __data__, 
                             global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                         return __data__;
                     }
                 }
                 catch (global::System.Exception ex)
                 {
                     OnExecuteFail("M", __cmd__, ex, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     throw;
                 }
             }
         }
 
         partial void OnExecuting(global::System.String methodName, 
             global::System.Data.Common.DbCommand command);
 
         partial void OnExecuted(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Object? result, 
             global::System.Int64 elpased);
 
         partial void OnExecuteFail(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Exception exception, 
             global::System.Int64 elpased);
 
     }
 }
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 ExpressionToSql_ModuloOperator_GeneratesCorrectSql [100 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.GetEntities(ExpressionToSql<TestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModuloOperator_GeneratesCorrectSql() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 50

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ArithmeticOperators_AllSupported [78 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.GetEntities(ExpressionToSql<TestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ArithmeticOperators_AllSupported() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 93

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ModOperator_InComplexExpressions [82 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.GetEntitiesWithComplexMod(ExpressionToSql<TestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_InComplexExpressions() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 144

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_AllArithmeticOperators_GenerateCorrectSql [85 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淐alculatorRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚CalculatorService.Calculate(ExpressionToSql<Calculator>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_AllArithmeticOperators_GenerateCorrectSql() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 190

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Calculator has 0 attributes:
 No RepositoryFor attribute found on Calculator
 Class CalculatorRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on CalculatorRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for CalculatorRepository
 === GenerateRepositoryImplementation START for CalculatorRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ModOperator_WithDifferentDataTypes [85 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淣umericRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚NumericService.GetByModulo(ExpressionToSql<NumericEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_WithDifferentDataTypes() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 247

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class NumericEntity has 0 attributes:
 No RepositoryFor attribute found on NumericEntity
 Class NumericRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on NumericRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for NumericRepository
 === GenerateRepositoryImplementation START for NumericRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 DbDataReaderResult [153 ms]
  閿欒娑堟伅:
   Assert.AreEqual 澶辫触銆傚簲涓? <// <auto-generated>
// Code generated by Stored Procedures Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591

namespace Foo
{

    using System;
    using System.Collections.Generic;
    using System.Data.Common;
    using System.Linq;

    partial class C
    {
        public partial System.Data.Common.DbDataReader M(int clientId, string? personId)
        {
            var connection = this.connection;
            if(connection.State != global::System.Data.ConnectionState.Open)
            {
                connection.Open();
            }
            using var command = connection.CreateCommand();
            var sqlQuery = @"sp_TestSP @client_id, @person_id";
            command.CommandText = sqlQuery;
            var __result = command.ExecuteReader();
            return __result;
        }

    }
}>锛屽疄闄呬负: <// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}


// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public partial System.Data.Common.DbDataReader M(int clientId, string? personId)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                __conn__.Open();
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                client_id_p.ParameterName = "@client_id";
                client_id_p.DbType = global::System.Data.DbType.Int32;
                client_id_p.Value = clientId;
                __cmd__.Parameters.Add(client_id_p);

                global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                person_id_p.ParameterName = "@person_id";
                person_id_p.DbType = global::System.Data.DbType.String;
                person_id_p.Value = personId;
                __cmd__.Parameters.Add(person_id_p);

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                    {
                        if(!__reader__.Read()) throw new global::System.InvalidOperationException(
                                "Sequence contains no elements");

                        System.Data.Common.DbDataReader __data__ = __reader__;
                        OnExecuted("M", __cmd__, __data__, 
                            global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                        return __data__;
                    }
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.DbDataReaderTests.DbDataReaderResult() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\DbDataReaderTests.cs:line 70
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // Code generated by Sqlx Code Generator.
 // Changes may cause incorrect behavior and will be lost if the code is
 // regenerated.
 // </auto-generated>
 #nullable enable
 #pragma warning disable CS8618, CS8625, CS8629
 
 using System.Linq;
 
 namespace Foo
 {
     internal partial class C
     {
         public partial System.Data.Common.DbDataReader M(int clientId, string? personId)
         {
             global::System.Data.Common.DbConnection __conn__ = connection ?? 
                 throw new global::System.ArgumentNullException("connection");
             if(__conn__.State != global::System.Data.ConnectionState.Open)
             {
                 __conn__.Open();
             }
             using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
             {
                 __cmd__.CommandText = "EXEC sp_TestSP";
 
                 global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                 client_id_p.ParameterName = "@client_id";
                 client_id_p.DbType = global::System.Data.DbType.Int32;
                 client_id_p.Value = clientId;
                 __cmd__.Parameters.Add(client_id_p);
 
                 global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                 person_id_p.ParameterName = "@person_id";
                 person_id_p.DbType = global::System.Data.DbType.String;
                 person_id_p.Value = personId;
                 __cmd__.Parameters.Add(person_id_p);
 
                 global::System.Int64 __startTime__ = 
                     global::System.Diagnostics.Stopwatch.GetTimestamp();
                 try
                 {
                     OnExecuting("M", __cmd__);
                     using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                     {
                         if(!__reader__.Read()) throw new global::System.InvalidOperationException(
                                 "Sequence contains no elements");
 
                         System.Data.Common.DbDataReader __data__ = __reader__;
                         OnExecuted("M", __cmd__, __data__, 
                             global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                         return __data__;
                     }
                 }
                 catch (global::System.Exception ex)
                 {
                     OnExecuteFail("M", __cmd__, ex, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     throw;
                 }
             }
         }
 
         partial void OnExecuting(global::System.String methodName, 
             global::System.Data.Common.DbCommand command);
 
         partial void OnExecuted(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Object? result, 
             global::System.Int64 elpased);
 
         partial void OnExecuteFail(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Exception exception, 
             global::System.Int64 elpased);
 
     }
 }
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 ExpressionToSql_ModOperator_InWhereAndOrderBy [96 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淧agedRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚PagedService.GetPagedResults(ExpressionToSql<PagedEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_InWhereAndOrderBy() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 290

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class PagedEntity has 0 attributes:
 No RepositoryFor attribute found on PagedEntity
 Class PagedRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on PagedRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for PagedRepository
 === GenerateRepositoryImplementation START for PagedRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ModOperator_WithConstants [89 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淐onstantTestRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚ConstantTestService.GetWithConstantMod(ExpressionToSql<ConstantTestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_WithConstants() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 333

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class ConstantTestEntity has 0 attributes:
 No RepositoryFor attribute found on ConstantTestEntity
 Class ConstantTestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on ConstantTestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for ConstantTestRepository
 === GenerateRepositoryImplementation START for ConstantTestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  宸茶烦杩?ScalarResultDbContext [< 1 ms]
  澶辫触 Extensions_FindMember_VariousTypes_WorksCorrectly [5 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.ExtensionsTests.Extensions_FindMember_VariousTypes_WorksCorrectly() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExtensionsTests.cs:line 268

  澶辫触 Extensions_GetDataReadIndexExpression_VariousTypes_WorksCorrectly [10 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.ExtensionsTests.Extensions_GetDataReadIndexExpression_VariousTypes_WorksCorrectly() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExtensionsTests.cs:line 361

  澶辫触 ExpressionToSql_ModuloOperator_GeneratesCorrectSql [188 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.GetEntities(ExpressionToSql<TestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModuloOperator_GeneratesCorrectSql() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 50
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ArithmeticOperators_AllSupported [174 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.GetEntities(ExpressionToSql<TestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ArithmeticOperators_AllSupported() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 93
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ModOperator_InComplexExpressions [141 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淭estRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚TestService.GetEntitiesWithComplexMod(ExpressionToSql<TestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_InComplexExpressions() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 144
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestEntity has 0 attributes:
 No RepositoryFor attribute found on TestEntity
 Class TestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on TestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for TestRepository
 === GenerateRepositoryImplementation START for TestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 GenericRepository_MultipleTypeParameters_GeneratesImplementation [90 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould generate GetById method with correct key type
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.GenericRepositoryTests.GenericRepository_MultipleTypeParameters_GeneratesImplementation() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\GenericRepositoryTests.cs:line 126

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class AdvancedUserRepository : TestNamespace.IAdvancedRepository<TestNamespace.User, int>
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetById using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <returns>The User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public TestNamespace.User? GetById(int id)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetById", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetById", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetById", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetByIdAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public async System.Threading.Tasks.Task<TestNamespace.User?> GetByIdAsync(int id, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetByIdAsync", __cmd__);
 
                 using var reader = await __cmd__.ExecuteReaderAsync(cancellationToken);
                 if (await reader.ReadAsync(cancellationToken))
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetByIdAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetByIdAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of Create using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public int Create(TestNamespace.User entity)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("Create", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("Create", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("Create", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of CreateAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public async System.Threading.Tasks.Task<int> CreateAsync(TestNamespace.User entity, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("CreateAsync", __cmd__);
 
                 __result__ = await __cmd__.ExecuteNonQueryAsync(cancellationToken);
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("CreateAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("CreateAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class User has 0 attributes:
 No RepositoryFor attribute found on User
 Class AdvancedUserRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on AdvancedUserRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for AdvancedUserRepository
 === GenerateRepositoryImplementation START for AdvancedUserRepository ===
 RepositoryFor attribute found: True
 Constructor arguments count: 1
 First argument kind: Type
 First argument value: TestNamespace.IAdvancedRepository<TestNamespace.User, int>
 First argument type: System.Type
 Got type from TypedConstantKind.Type: IAdvancedRepository
 IsGenericType: True
 TypeArguments.Length: 2
 TypeParameters.Length: 2
 Already have constructed generic type: TestNamespace.IAdvancedRepository<TestNamespace.User, int>
 Service interface: IAdvancedRepository
 Generating repository implementation for AdvancedUserRepository implementing IAdvancedRepository
 Service interface type: Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel.NonErrorNamedTypeSymbol
 Service interface kind: Interface
 Starting entity type inference for interface IAdvancedRepository
 === InferEntityTypeFromServiceInterface START ===
 Service interface: IAdvancedRepository
 Is generic: True
 Found 2 type arguments
 Type argument 0: User (TestNamespace.User)
 Using first type argument as entity type: User
 Inferred entity type: User
 Entity User has 0 attributes:
 No TableName attribute found on entity
 Using default table name: User
 Using table name: User
 DbConnection field already exists: connection
 Found 4 methods in interface IAdvancedRepository
 Generating implementations for all 4 methods
 Generating method: GetById with return type: TestNamespace.User?
 Generating method: GetByIdAsync with return type: System.Threading.Tasks.Task<TestNamespace.User?>
 Generating method: Create with return type: int
 Generating method: CreateAsync with return type: System.Threading.Tasks.Task<int>
 Generated repository implementation:
 // <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class AdvancedUserRepository : TestNamespace.IAdvancedRepository<TestNamespace.User, int>
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetById using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <returns>The User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public TestNamespace.User? GetById(int id)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetById", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetById", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetById", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetByIdAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public async System.Threading.Tasks.Task<TestNamespace.User?> GetByIdAsync(int id, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetByIdAsync", __cmd__);
 
                 using var reader = await __cmd__.ExecuteReaderAsync(cancellationToken);
                 if (await reader.ReadAsync(cancellationToken))
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetByIdAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetByIdAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of Create using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public int Create(TestNamespace.User entity)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("Create", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("Create", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("Create", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of CreateAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public async System.Threading.Tasks.Task<int> CreateAsync(TestNamespace.User entity, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("CreateAsync", __cmd__);
 
                 __result__ = await __cmd__.ExecuteNonQueryAsync(cancellationToken);
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("CreateAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("CreateAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 Adding source file: AdvancedUserRepository.Repository.g.cs
 Successfully added repository source file


  澶辫触 ExpressionToSql_AllArithmeticOperators_GenerateCorrectSql [167 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淐alculatorRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚CalculatorService.Calculate(ExpressionToSql<Calculator>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_AllArithmeticOperators_GenerateCorrectSql() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 190
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Calculator has 0 attributes:
 No RepositoryFor attribute found on Calculator
 Class CalculatorRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on CalculatorRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for CalculatorRepository
 === GenerateRepositoryImplementation START for CalculatorRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ModOperator_WithDifferentDataTypes [148 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淣umericRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚NumericService.GetByModulo(ExpressionToSql<NumericEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_WithDifferentDataTypes() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 247
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class NumericEntity has 0 attributes:
 No RepositoryFor attribute found on NumericEntity
 Class NumericRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on NumericRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for NumericRepository
 === GenerateRepositoryImplementation START for NumericRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ModOperator_InWhereAndOrderBy [146 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淧agedRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚PagedService.GetPagedResults(ExpressionToSql<PagedEntity>)鈥?鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_InWhereAndOrderBy() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 290
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class PagedEntity has 0 attributes:
 No RepositoryFor attribute found on PagedEntity
 Class PagedRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on PagedRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for PagedRepository
 === GenerateRepositoryImplementation START for PagedRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  澶辫触 ExpressionToSql_ModOperator_WithConstants [155 ms]
  閿欒娑堟伅:
   Assert.Fail 澶辫触銆侳inal compilation failed with errors:
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryForAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淩epositoryFor鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql<>鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鈥淐onstantTestRepository鈥濅笉瀹炵幇鎺ュ彛鎴愬憳鈥淚ConstantTestService.GetWithConstantMod(ExpressionToSql<ConstantTestEntity>)鈥?鈥淪qlx鈥濅笉鏄壒鎬х被
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSqlAttribute鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)
鏈兘鎵惧埌绫诲瀷鎴栧懡鍚嶇┖闂村悕鈥淓xpressionToSql鈥?鏄惁缂哄皯 using 鎸囦护鎴栫▼搴忛泦寮曠敤?)

Generated code:
=== Generated File ===
// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}

=== End File ===

  鍫嗘爤璺熻釜:
     at Sqlx.Tests.CodeGenerationTestBase.Compile(String source, NullableContextOptions nullableOptions) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 151
   at Sqlx.Tests.CodeGenerationTestBase.GetCSharpGeneratedOutput(String source) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\CodeGenerationTestBase.cs:line 31
   at Sqlx.Tests.ExpressionToSqlModOperatorTests.ExpressionToSql_ModOperator_WithConstants() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExpressionToSqlModOperatorTests.cs:line 333
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class ConstantTestEntity has 0 attributes:
 No RepositoryFor attribute found on ConstantTestEntity
 Class ConstantTestRepository has 1 attributes:
   - RepositoryFor (RepositoryFor)
 Found RepositoryFor attribute on ConstantTestRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for ConstantTestRepository
 === GenerateRepositoryImplementation START for ConstantTestRepository ===
 RepositoryFor attribute found: False
 No RepositoryFor attribute found


  宸茶烦杩?ScalarResultDbContext [< 1 ms]
  澶辫触 Extensions_FindMember_VariousTypes_WorksCorrectly [6 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.ExtensionsTests.Extensions_FindMember_VariousTypes_WorksCorrectly() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExtensionsTests.cs:line 268
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  澶辫触 Extensions_GetDataReadIndexExpression_VariousTypes_WorksCorrectly [13 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.ExtensionsTests.Extensions_GetDataReadIndexExpression_VariousTypes_WorksCorrectly() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\ExtensionsTests.cs:line 361
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  澶辫触 DbConectionCanJoinTransactions [76 ms]
  閿欒娑堟伅:
   Assert.AreEqual 澶辫触銆傚簲涓? <// <auto-generated>
// Code generated by Stored Procedures Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591

namespace Foo
{
    using System;
    using System.Collections.Generic;
    using System.Data.Common;
    using System.Linq;

    partial class C
    {
        public partial int M(DbTransaction transaction, int clientId, string? personId)
        {
            var connection = this.connection;
            using var command = connection.CreateCommand();

            var clientIdParameter = command.CreateParameter();
            clientIdParameter.ParameterName = "@client_id";
            clientIdParameter.Value = clientId;

            var personIdParameter = command.CreateParameter();
            personIdParameter.ParameterName = "@person_id";
            personIdParameter.Value = personId == null ? (object)DBNull.Value : personId;

            var parameters = new DbParameter[]
            {
                clientIdParameter,
                personIdParameter,
            };

            var sqlQuery = @"sp_TestSP @client_id, @person_id";
            command.CommandText = sqlQuery;
            command.Parameters.AddRange(parameters);
            command.Transaction = transaction;
            var __result = command.ExecuteScalar();
            return (int)__result!;
        }
    }
}>锛屽疄闄呬负: <// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}


// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public partial int M(System.Data.Common.DbTransaction transaction, int clientId, string? personId)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                __conn__.Open();
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.Transaction = transaction;
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                client_id_p.ParameterName = "@client_id";
                client_id_p.DbType = global::System.Data.DbType.Int32;
                client_id_p.Value = clientId;
                __cmd__.Parameters.Add(client_id_p);

                global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                person_id_p.ParameterName = "@person_id";
                person_id_p.DbType = global::System.Data.DbType.String;
                person_id_p.Value = personId;
                __cmd__.Parameters.Add(person_id_p);

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    var __result__ = __cmd__.ExecuteScalar();
                    OnExecuted("M", __cmd__, __result__, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    if(__result__ == null) throw new global::System.InvalidOperationException(
                        "Sequence contains no elements");
                    return (int)global::System.Convert.ChangeType(__result__, 
                        typeof(int));
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.JoinTransactionTests.DbConectionCanJoinTransactions() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\JoinTransactionTests.cs:line 81

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // Code generated by Sqlx Code Generator.
 // Changes may cause incorrect behavior and will be lost if the code is
 // regenerated.
 // </auto-generated>
 #nullable enable
 #pragma warning disable CS8618, CS8625, CS8629
 
 using System.Linq;
 
 namespace Foo
 {
     internal partial class C
     {
         public partial int M(System.Data.Common.DbTransaction transaction, int clientId, string? personId)
         {
             global::System.Data.Common.DbConnection __conn__ = connection ?? 
                 throw new global::System.ArgumentNullException("connection");
             if(__conn__.State != global::System.Data.ConnectionState.Open)
             {
                 __conn__.Open();
             }
             using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
             {
                 __cmd__.Transaction = transaction;
                 __cmd__.CommandText = "EXEC sp_TestSP";
 
                 global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                 client_id_p.ParameterName = "@client_id";
                 client_id_p.DbType = global::System.Data.DbType.Int32;
                 client_id_p.Value = clientId;
                 __cmd__.Parameters.Add(client_id_p);
 
                 global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                 person_id_p.ParameterName = "@person_id";
                 person_id_p.DbType = global::System.Data.DbType.String;
                 person_id_p.Value = personId;
                 __cmd__.Parameters.Add(person_id_p);
 
                 global::System.Int64 __startTime__ = 
                     global::System.Diagnostics.Stopwatch.GetTimestamp();
                 try
                 {
                     OnExecuting("M", __cmd__);
                     var __result__ = __cmd__.ExecuteScalar();
                     OnExecuted("M", __cmd__, __result__, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     if(__result__ == null) throw new global::System.InvalidOperationException(
                         "Sequence contains no elements");
                     return (int)global::System.Convert.ChangeType(__result__, 
                         typeof(int));
                 }
                 catch (global::System.Exception ex)
                 {
                     OnExecuteFail("M", __cmd__, ex, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     throw;
                 }
             }
         }
 
         partial void OnExecuting(global::System.String methodName, 
             global::System.Data.Common.DbCommand command);
 
         partial void OnExecuted(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Object? result, 
             global::System.Int64 elpased);
 
         partial void OnExecuteFail(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Exception exception, 
             global::System.Int64 elpased);
 
     }
 }
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 GenericRepository_MultipleTypeParameters_GeneratesImplementation [150 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould generate GetById method with correct key type
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.GenericRepositoryTests.GenericRepository_MultipleTypeParameters_GeneratesImplementation() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\GenericRepositoryTests.cs:line 126
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class AdvancedUserRepository : TestNamespace.IAdvancedRepository<TestNamespace.User, int>
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetById using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <returns>The User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public TestNamespace.User? GetById(int id)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetById", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetById", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetById", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetByIdAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public async System.Threading.Tasks.Task<TestNamespace.User?> GetByIdAsync(int id, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetByIdAsync", __cmd__);
 
                 using var reader = await __cmd__.ExecuteReaderAsync(cancellationToken);
                 if (await reader.ReadAsync(cancellationToken))
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetByIdAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetByIdAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of Create using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public int Create(TestNamespace.User entity)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("Create", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("Create", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("Create", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of CreateAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public async System.Threading.Tasks.Task<int> CreateAsync(TestNamespace.User entity, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("CreateAsync", __cmd__);
 
                 __result__ = await __cmd__.ExecuteNonQueryAsync(cancellationToken);
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("CreateAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("CreateAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class User has 0 attributes:
 No RepositoryFor attribute found on User
 Class AdvancedUserRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on AdvancedUserRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for AdvancedUserRepository
 === GenerateRepositoryImplementation START for AdvancedUserRepository ===
 RepositoryFor attribute found: True
 Constructor arguments count: 1
 First argument kind: Type
 First argument value: TestNamespace.IAdvancedRepository<TestNamespace.User, int>
 First argument type: System.Type
 Got type from TypedConstantKind.Type: IAdvancedRepository
 IsGenericType: True
 TypeArguments.Length: 2
 TypeParameters.Length: 2
 Already have constructed generic type: TestNamespace.IAdvancedRepository<TestNamespace.User, int>
 Service interface: IAdvancedRepository
 Generating repository implementation for AdvancedUserRepository implementing IAdvancedRepository
 Service interface type: Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel.NonErrorNamedTypeSymbol
 Service interface kind: Interface
 Starting entity type inference for interface IAdvancedRepository
 === InferEntityTypeFromServiceInterface START ===
 Service interface: IAdvancedRepository
 Is generic: True
 Found 2 type arguments
 Type argument 0: User (TestNamespace.User)
 Using first type argument as entity type: User
 Inferred entity type: User
 Entity User has 0 attributes:
 No TableName attribute found on entity
 Using default table name: User
 Using table name: User
 DbConnection field already exists: connection
 Found 4 methods in interface IAdvancedRepository
 Generating implementations for all 4 methods
 Generating method: GetById with return type: TestNamespace.User?
 Generating method: GetByIdAsync with return type: System.Threading.Tasks.Task<TestNamespace.User?>
 Generating method: Create with return type: int
 Generating method: CreateAsync with return type: System.Threading.Tasks.Task<int>
 Generated repository implementation:
 // <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class AdvancedUserRepository : TestNamespace.IAdvancedRepository<TestNamespace.User, int>
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetById using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <returns>The User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public TestNamespace.User? GetById(int id)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetById", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetById", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetById", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetByIdAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the User result.</returns>
         [Sqlx("SELECT * FROM User WHERE Id = @id")]
         public async System.Threading.Tasks.Task<TestNamespace.User?> GetByIdAsync(int id, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [User] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetByIdAsync", __cmd__);
 
                 using var reader = await __cmd__.ExecuteReaderAsync(cancellationToken);
                 if (await reader.ReadAsync(cancellationToken))
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     int __ordinal_email = reader.GetOrdinal("email");
                     var entity = new TestNamespace.User
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name),
                         Email = reader.IsDBNull(__ordinal_email) ? string.Empty : reader.GetString(__ordinal_email)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetByIdAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetByIdAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of Create using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public int Create(TestNamespace.User entity)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("Create", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("Create", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("Create", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of CreateAsync using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="entity">The User entity to process.</param>
         /// <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
         /// <returns>A task containing the number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "User")]
         public async System.Threading.Tasks.Task<int> CreateAsync(TestNamespace.User entity, System.Threading.CancellationToken cancellationToken = default)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     await connection.OpenAsync(cancellationToken);
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [User] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = entity.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = entity.Email ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("CreateAsync", __cmd__);
 
                 __result__ = await __cmd__.ExecuteNonQueryAsync(cancellationToken);
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("CreateAsync", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("CreateAsync", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 Adding source file: AdvancedUserRepository.Repository.g.cs
 Successfully added repository source file


  澶辫触 DbContextCanJoinTransactions [73 ms]
  閿欒娑堟伅:
   Assert.AreEqual 澶辫触銆傚簲涓? <// <auto-generated>
// Code generated by Stored Procedures Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591

namespace Foo
{
    using System;
    using System.Data.Common;
    using System.Linq;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.EntityFrameworkCore.Storage;

    partial class C
    {
        public partial IList<Item> M(DbTransaction transaction)
        {
            var connection = this.dbContext.Database.GetDbConnection();
            using var command = connection.CreateCommand();

            var sqlQuery = @"sp_TestSP";
            this.dbContext.Database.UseTransaction(transaction);
            var __result = this.dbContext.Items.FromSqlRaw(sqlQuery).ToList();
            return __result;
        }
    }
}>锛屽疄闄呬负: <// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}


// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public partial System.Collections.Generic.IList<Foo.Item> M(System.Data.Common.DbTransaction transaction)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                __conn__.Open();
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.Transaction = transaction;
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                    {
                        global::System.Collections.Generic.List<Foo.Item> __result__ = new global::System.Collections.Generic.List<Foo.Item>();
                        int __ordinal_string_value = __reader__.GetOrdinal("string_value");
                        int __ordinal_int32_value = __reader__.GetOrdinal("int32_value");
                        int __ordinal_nullable_int32_value = __reader__.GetOrdinal("nullable_int32_value");
                        while(__reader__.Read())
                        {
                            Foo.Item __data__ = new  Foo.Item ();
                            __data__.StringValue = __reader__.IsDBNull(__ordinal_string_value) ? string.Empty : __reader__.GetString(__ordinal_string_value);
                            __data__.Int32Value = __reader__.IsDBNull(__ordinal_int32_value) ? default : __reader__.GetInt32(__ordinal_int32_value);
                            __data__.NullableInt32Value = __reader__.IsDBNull(__ordinal_nullable_int32_value) ? null : __reader__.GetInt32(__ordinal_nullable_int32_value);
                            __result__.Add(__data__);
                        }

                        OnExecuted("M", __cmd__, __result__, 
                            global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                        return __result__;
                    }
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.JoinTransactionTests.DbContextCanJoinTransactions() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\JoinTransactionTests.cs:line 143

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // Code generated by Sqlx Code Generator.
 // Changes may cause incorrect behavior and will be lost if the code is
 // regenerated.
 // </auto-generated>
 #nullable enable
 #pragma warning disable CS8618, CS8625, CS8629
 
 using System.Linq;
 
 namespace Foo
 {
     internal partial class C
     {
         public partial System.Collections.Generic.IList<Foo.Item> M(System.Data.Common.DbTransaction transaction)
         {
             global::System.Data.Common.DbConnection __conn__ = connection ?? 
                 throw new global::System.ArgumentNullException("connection");
             if(__conn__.State != global::System.Data.ConnectionState.Open)
             {
                 __conn__.Open();
             }
             using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
             {
                 __cmd__.Transaction = transaction;
                 __cmd__.CommandText = "EXEC sp_TestSP";
 
                 global::System.Int64 __startTime__ = 
                     global::System.Diagnostics.Stopwatch.GetTimestamp();
                 try
                 {
                     OnExecuting("M", __cmd__);
                     using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                     {
                         global::System.Collections.Generic.List<Foo.Item> __result__ = new global::System.Collections.Generic.List<Foo.Item>();
                         int __ordinal_string_value = __reader__.GetOrdinal("string_value");
                         int __ordinal_int32_value = __reader__.GetOrdinal("int32_value");
                         int __ordinal_nullable_int32_value = __reader__.GetOrdinal("nullable_int32_value");
                         while(__reader__.Read())
                         {
                             Foo.Item __data__ = new  Foo.Item ();
                             __data__.StringValue = __reader__.IsDBNull(__ordinal_string_value) ? string.Empty : __reader__.GetString(__ordinal_string_value);
                             __data__.Int32Value = __reader__.IsDBNull(__ordinal_int32_value) ? default : __reader__.GetInt32(__ordinal_int32_value);
                             __data__.NullableInt32Value = __reader__.IsDBNull(__ordinal_nullable_int32_value) ? null : __reader__.GetInt32(__ordinal_nullable_int32_value);
                             __result__.Add(__data__);
                         }
 
                         OnExecuted("M", __cmd__, __result__, 
                             global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                         return __result__;
                     }
                 }
                 catch (global::System.Exception ex)
                 {
                     OnExecuteFail("M", __cmd__, ex, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     throw;
                 }
             }
         }
 
         partial void OnExecuting(global::System.String methodName, 
             global::System.Data.Common.DbCommand command);
 
         partial void OnExecuted(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Object? result, 
             global::System.Int64 elpased);
 
         partial void OnExecuteFail(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Exception exception, 
             global::System.Int64 elpased);
 
     }
 }
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Item has 0 attributes:
 No RepositoryFor attribute found on Item
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 SourceGenerator_GeneratesSqlDefineConstants [30 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆侾ostgreSQL dialect should use quotes and $ prefix
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.SourceGeneratorFunctionalTests.SourceGenerator_GeneratesSqlDefineConstants() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\SourceGeneratorFunctionalTests.cs:line 112

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestClass has 0 attributes:
 No RepositoryFor attribute found on TestClass
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 SqlGeneration_MethodBodies_IncludeNotImplementedException [27 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆侻ethod bodies should include NotImplementedException
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.SqlAttributeGenerationTests.SqlGeneration_MethodBodies_IncludeNotImplementedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\SqlAttributeGenerationTests.cs:line 528

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Sample has 0 attributes:
 No RepositoryFor attribute found on Sample
 Class SampleRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on SampleRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for SampleRepository
 === GenerateRepositoryImplementation START for SampleRepository ===
 RepositoryFor attribute found: True
 Constructor arguments count: 1
 First argument kind: Type
 First argument value: TestNamespace.ISampleService
 First argument type: System.Type
 Got type from TypedConstantKind.Type: ISampleService
 IsGenericType: False
 TypeArguments.Length: 0
 TypeParameters.Length: 0
 Service interface: ISampleService
 Generating repository implementation for SampleRepository implementing ISampleService
 Service interface type: Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel.NonErrorNamedTypeSymbol
 Service interface kind: Interface
 Starting entity type inference for interface ISampleService
 === InferEntityTypeFromServiceInterface START ===
 Service interface: ISampleService
 Is generic: False
 Found 4 methods in interface ISampleService
 Analyzing method: GetAll
 Analyzing method: GetById
 Analyzing method: Create
 Analyzing method: DoVoidOperation
 Selected entity type: Sample with score 5
 Inferred entity type: Sample
 Entity Sample has 0 attributes:
 No TableName attribute found on entity
 Using default table name: Sample
 Using table name: Sample
 Generated DbConnection field: connection
 Found 4 methods in interface ISampleService
 Generating implementations for all 4 methods
 Generating method: GetAll with return type: System.Collections.Generic.IList<TestNamespace.Sample>
 Generating method: GetById with return type: TestNamespace.Sample?
 Generating method: Create with return type: int
 Generating method: DoVoidOperation with return type: void
 Generated repository implementation:
 // <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class SampleRepository : TestNamespace.ISampleService
     {
         // Auto-generated DbConnection field for repository operations
         // This field is available to both RepositoryFor and Sqlx generators
         protected readonly global::System.Data.Common.DbConnection connection;
 
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAll using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Sample entities.</returns>
         [Sqlx("SELECT * FROM Sample")]
         public System.Collections.Generic.IList<TestNamespace.Sample> GetAll()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [Sample]";
 
                 OnExecuting("GetAll", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Sample>();
 
                 while (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     var entity = new TestNamespace.Sample
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name)
                     };
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Sample>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAll", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAll", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetById using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <returns>The Sample result.</returns>
         [Sqlx("SELECT * FROM Sample WHERE Id = @id")]
         public TestNamespace.Sample? GetById(int id)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [Sample] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetById", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     var entity = new TestNamespace.Sample
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetById", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetById", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of Create using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="sample">The Sample entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "Sample")]
         public int Create(TestNamespace.Sample sample)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [Sample] ([name]) VALUES (@name)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = sample.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 OnExecuting("Create", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("Create", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("Create", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of DoVoidOperation using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         [Sqlx("SELECT * FROM Sample")]
         public void DoVoidOperation()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [Sample] LIMIT 1";
 
                 OnExecuting("DoVoidOperation", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     var entity = new TestNamespace.Sample
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("DoVoidOperation", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("DoVoidOperation", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 Adding source file: SampleRepository.Repository.g.cs
 Successfully added repository source file


  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0002") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0002. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0003") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0003. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0004") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0004. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0005") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0005. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0010") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0010. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0011") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0011. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0012") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0012. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0013") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0013. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0014") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0014. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0015") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0015. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303

  澶辫触 ClassGenerationContext_Class_HasCorrectStructure [1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侰lassGenerationContext should have SqlxAttributeSymbol property
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.ClassGenerationContext_Class_HasCorrectStructure() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 734

  澶辫触 MethodGenerationContext_Class_HasCorrectStructure [1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻ethodGenerationContext should have ReturnIsList property
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.MethodGenerationContext_Class_HasCorrectStructure() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 828

  澶辫触 GetDialectProvider_WithOracleDefineTypes_ThrowsNotSupportedException [1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithOracleDefineTypes_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 115

  澶辫触 GetDialectProvider_WithDB2DefineTypes_ThrowsNotSupportedException [< 1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithDB2DefineTypes_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 125

  澶辫触 GetDialectProvider_WithOracleDefine_ThrowsNotSupportedException [< 1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithOracleDefine_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 138

  澶辫触 GetDialectProvider_WithDB2Define_ThrowsNotSupportedException [< 1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithDB2Define_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 151

  澶辫触 DbConectionCanJoinTransactions [104 ms]
  閿欒娑堟伅:
   Assert.AreEqual 澶辫触銆傚簲涓? <// <auto-generated>
// Code generated by Stored Procedures Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591

namespace Foo
{
    using System;
    using System.Collections.Generic;
    using System.Data.Common;
    using System.Linq;

    partial class C
    {
        public partial int M(DbTransaction transaction, int clientId, string? personId)
        {
            var connection = this.connection;
            using var command = connection.CreateCommand();

            var clientIdParameter = command.CreateParameter();
            clientIdParameter.ParameterName = "@client_id";
            clientIdParameter.Value = clientId;

            var personIdParameter = command.CreateParameter();
            personIdParameter.ParameterName = "@person_id";
            personIdParameter.Value = personId == null ? (object)DBNull.Value : personId;

            var parameters = new DbParameter[]
            {
                clientIdParameter,
                personIdParameter,
            };

            var sqlQuery = @"sp_TestSP @client_id, @person_id";
            command.CommandText = sqlQuery;
            command.Parameters.AddRange(parameters);
            command.Transaction = transaction;
            var __result = command.ExecuteScalar();
            return (int)__result!;
        }
    }
}>锛屽疄闄呬负: <// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}


// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public partial int M(System.Data.Common.DbTransaction transaction, int clientId, string? personId)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                __conn__.Open();
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.Transaction = transaction;
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                client_id_p.ParameterName = "@client_id";
                client_id_p.DbType = global::System.Data.DbType.Int32;
                client_id_p.Value = clientId;
                __cmd__.Parameters.Add(client_id_p);

                global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                person_id_p.ParameterName = "@person_id";
                person_id_p.DbType = global::System.Data.DbType.String;
                person_id_p.Value = personId;
                __cmd__.Parameters.Add(person_id_p);

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    var __result__ = __cmd__.ExecuteScalar();
                    OnExecuted("M", __cmd__, __result__, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    if(__result__ == null) throw new global::System.InvalidOperationException(
                        "Sequence contains no elements");
                    return (int)global::System.Convert.ChangeType(__result__, 
                        typeof(int));
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.JoinTransactionTests.DbConectionCanJoinTransactions() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\JoinTransactionTests.cs:line 81
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // Code generated by Sqlx Code Generator.
 // Changes may cause incorrect behavior and will be lost if the code is
 // regenerated.
 // </auto-generated>
 #nullable enable
 #pragma warning disable CS8618, CS8625, CS8629
 
 using System.Linq;
 
 namespace Foo
 {
     internal partial class C
     {
         public partial int M(System.Data.Common.DbTransaction transaction, int clientId, string? personId)
         {
             global::System.Data.Common.DbConnection __conn__ = connection ?? 
                 throw new global::System.ArgumentNullException("connection");
             if(__conn__.State != global::System.Data.ConnectionState.Open)
             {
                 __conn__.Open();
             }
             using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
             {
                 __cmd__.Transaction = transaction;
                 __cmd__.CommandText = "EXEC sp_TestSP";
 
                 global::System.Data.Common.DbParameter client_id_p = __cmd__.CreateParameter();
                 client_id_p.ParameterName = "@client_id";
                 client_id_p.DbType = global::System.Data.DbType.Int32;
                 client_id_p.Value = clientId;
                 __cmd__.Parameters.Add(client_id_p);
 
                 global::System.Data.Common.DbParameter person_id_p = __cmd__.CreateParameter();
                 person_id_p.ParameterName = "@person_id";
                 person_id_p.DbType = global::System.Data.DbType.String;
                 person_id_p.Value = personId;
                 __cmd__.Parameters.Add(person_id_p);
 
                 global::System.Int64 __startTime__ = 
                     global::System.Diagnostics.Stopwatch.GetTimestamp();
                 try
                 {
                     OnExecuting("M", __cmd__);
                     var __result__ = __cmd__.ExecuteScalar();
                     OnExecuted("M", __cmd__, __result__, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     if(__result__ == null) throw new global::System.InvalidOperationException(
                         "Sequence contains no elements");
                     return (int)global::System.Convert.ChangeType(__result__, 
                         typeof(int));
                 }
                 catch (global::System.Exception ex)
                 {
                     OnExecuteFail("M", __cmd__, ex, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     throw;
                 }
             }
         }
 
         partial void OnExecuting(global::System.String methodName, 
             global::System.Data.Common.DbCommand command);
 
         partial void OnExecuted(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Object? result, 
             global::System.Int64 elpased);
 
         partial void OnExecuteFail(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Exception exception, 
             global::System.Int64 elpased);
 
     }
 }
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 DbContextCanJoinTransactions [127 ms]
  閿欒娑堟伅:
   Assert.AreEqual 澶辫触銆傚簲涓? <// <auto-generated>
// Code generated by Stored Procedures Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591

namespace Foo
{
    using System;
    using System.Data.Common;
    using System.Linq;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.EntityFrameworkCore.Storage;

    partial class C
    {
        public partial IList<Item> M(DbTransaction transaction)
        {
            var connection = this.dbContext.Database.GetDbConnection();
            using var command = connection.CreateCommand();

            var sqlQuery = @"sp_TestSP";
            this.dbContext.Database.UseTransaction(transaction);
            var __result = this.dbContext.Items.FromSqlRaw(sqlQuery).ToList();
            return __result;
        }
    }
}>锛屽疄闄呬负: <// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
        /// </summary>
        /// <param name="storedProcedureName">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
        /// </summary>
        /// <param name="sql">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
        /// </summary>
        /// <param name="executeType">The SQL operation type.</param>
        /// <param name="tableName">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
        /// </summary>
        /// <param name="serviceType">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
        /// </summary>
        /// <param name="tableName">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
        /// </summary>
        /// <param name="type">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
        /// </summary>
        /// <param name="dialectType">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
        /// </summary>
        /// <param name="columnLeft">Left column delimiter.</param>
        /// <param name="columnRight">Right column delimiter.</param>
        /// <param name="stringLeft">Left string delimiter.</param>
        /// <param name="stringRight">Right string delimiter.</param>
        /// <param name="parameterPrefix">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
    }

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name="T">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($"({conditionSql})");
            }
            return string.Join(" AND ", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? " DESC" : " ASC";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($"OFFSET {_skip.Value}");
            }
            if (_take.HasValue)
            {
                clauses.Add($"LIMIT {_take.Value}");
            }
            return string.Join(" ", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string BuildSql()
        {
            var sql = new global::System.Text.StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append("UPDATE ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append(" SET ");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($"{column} = {value}");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($"{column} = {expression}");
                }
                sql.Append(string.Join(", ", setClauses));
            }
            else
            {
                sql.Append("SELECT * FROM ");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append(" WHERE ");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($"({conditionSql})");
                }
                sql.Append(string.Join(" AND ", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append(" ORDER BY ");
                    var orderClauses = new global::System.Collections.Generic.List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? " DESC" : " ASC";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join(", ", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($" OFFSET {_skip.Value}");
                }
                if (_take.HasValue)
                {
                    sql.Append($" LIMIT {_take.Value}");
                }
            }
            return sql.ToString();
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $"NOT ({ParseExpression(unary.Operand)})";
                default:
                    return "1=1";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                _ => $"{left} = {right}"
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return "Column";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return "NULL";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                bool b => b ? "1" : "0",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                _ => value.ToString() ?? "NULL"
            };
        }
    }

    /// <summary>
    /// Represents a parameterized SQL template.
    /// </summary>
    public class SqlTemplate
    {
        /// <summary>
        /// Initializes a new instance of the SqlTemplate class.
        /// </summary>
        public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
        {
            Sql = sql ?? string.Empty;
            Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
        }

        /// <summary>
        /// Gets the SQL command text.
        /// </summary>
        public string Sql { get; }

        /// <summary>
        /// Gets the parameters for the SQL command.
        /// </summary>
        public global::System.Data.Common.DbParameter[] Parameters { get; }
    }
}


// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable CS8618, CS8625, CS8629

using System.Linq;

namespace Foo
{
    internal partial class C
    {
        public partial System.Collections.Generic.IList<Foo.Item> M(System.Data.Common.DbTransaction transaction)
        {
            global::System.Data.Common.DbConnection __conn__ = connection ?? 
                throw new global::System.ArgumentNullException("connection");
            if(__conn__.State != global::System.Data.ConnectionState.Open)
            {
                __conn__.Open();
            }
            using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
            {
                __cmd__.Transaction = transaction;
                __cmd__.CommandText = "EXEC sp_TestSP";

                global::System.Int64 __startTime__ = 
                    global::System.Diagnostics.Stopwatch.GetTimestamp();
                try
                {
                    OnExecuting("M", __cmd__);
                    using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                    {
                        global::System.Collections.Generic.List<Foo.Item> __result__ = new global::System.Collections.Generic.List<Foo.Item>();
                        int __ordinal_string_value = __reader__.GetOrdinal("string_value");
                        int __ordinal_int32_value = __reader__.GetOrdinal("int32_value");
                        int __ordinal_nullable_int32_value = __reader__.GetOrdinal("nullable_int32_value");
                        while(__reader__.Read())
                        {
                            Foo.Item __data__ = new  Foo.Item ();
                            __data__.StringValue = __reader__.IsDBNull(__ordinal_string_value) ? string.Empty : __reader__.GetString(__ordinal_string_value);
                            __data__.Int32Value = __reader__.IsDBNull(__ordinal_int32_value) ? default : __reader__.GetInt32(__ordinal_int32_value);
                            __data__.NullableInt32Value = __reader__.IsDBNull(__ordinal_nullable_int32_value) ? null : __reader__.GetInt32(__ordinal_nullable_int32_value);
                            __result__.Add(__data__);
                        }

                        OnExecuted("M", __cmd__, __result__, 
                            global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                        return __result__;
                    }
                }
                catch (global::System.Exception ex)
                {
                    OnExecuteFail("M", __cmd__, ex, 
                        global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                    throw;
                }
            }
        }

        partial void OnExecuting(global::System.String methodName, 
            global::System.Data.Common.DbCommand command);

        partial void OnExecuted(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Object? result, 
            global::System.Int64 elpased);

        partial void OnExecuteFail(global::System.String methodName, 
            global::System.Data.Common.DbCommand command, global::System.Exception exception, 
            global::System.Int64 elpased);

    }
}>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.JoinTransactionTests.DbContextCanJoinTransactions() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\JoinTransactionTests.cs:line 143
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions = 
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions = 
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression = 
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, 
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate != null)
                 return _cachedTemplate;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string BuildSql()
         {
             var sql = new global::System.Text.StringBuilder();
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
             }
             else
             {
                 sql.Append("SELECT * FROM ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
             }
             if (_whereConditions.Count > 0)
             {
                 sql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 sql.Append(string.Join(" AND ", conditions));
             }
             if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
             {
                 if (_orderByExpressions.Count > 0)
                 {
                     sql.Append(" ORDER BY ");
                     var orderClauses = new global::System.Collections.Generic.List<string>();
                     foreach (var (expression, descending) in _orderByExpressions)
                     {
                         var columnName = GetColumnName(expression.Body);
                         var direction = descending ? " DESC" : " ASC";
                         orderClauses.Add(columnName + direction);
                     }
                     sql.Append(string.Join(", ", orderClauses));
                 }
                 if (_skip.HasValue)
                 {
                     sql.Append($" OFFSET {_skip.Value}");
                 }
                 if (_take.HasValue)
                 {
                     sql.Append($" LIMIT {_take.Value}");
                 }
             }
             return sql.ToString();
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Represents a parameterized SQL template.
     /// </summary>
     public class SqlTemplate
     {
         /// <summary>
         /// Initializes a new instance of the SqlTemplate class.
         /// </summary>
         public SqlTemplate(string sql, global::System.Data.Common.DbParameter[] parameters)
         {
             Sql = sql ?? string.Empty;
             Parameters = parameters ?? new global::System.Data.Common.DbParameter[0];
         }
 
         /// <summary>
         /// Gets the SQL command text.
         /// </summary>
         public string Sql { get; }
 
         /// <summary>
         /// Gets the parameters for the SQL command.
         /// </summary>
         public global::System.Data.Common.DbParameter[] Parameters { get; }
     }
 }
 

// <auto-generated>
 // Code generated by Sqlx Code Generator.
 // Changes may cause incorrect behavior and will be lost if the code is
 // regenerated.
 // </auto-generated>
 #nullable enable
 #pragma warning disable CS8618, CS8625, CS8629
 
 using System.Linq;
 
 namespace Foo
 {
     internal partial class C
     {
         public partial System.Collections.Generic.IList<Foo.Item> M(System.Data.Common.DbTransaction transaction)
         {
             global::System.Data.Common.DbConnection __conn__ = connection ?? 
                 throw new global::System.ArgumentNullException("connection");
             if(__conn__.State != global::System.Data.ConnectionState.Open)
             {
                 __conn__.Open();
             }
             using(global::System.Data.Common.DbCommand __cmd__ = __conn__.CreateCommand())
             {
                 __cmd__.Transaction = transaction;
                 __cmd__.CommandText = "EXEC sp_TestSP";
 
                 global::System.Int64 __startTime__ = 
                     global::System.Diagnostics.Stopwatch.GetTimestamp();
                 try
                 {
                     OnExecuting("M", __cmd__);
                     using(global::System.Data.Common.DbDataReader __reader__ = __cmd__.ExecuteReader())
                     {
                         global::System.Collections.Generic.List<Foo.Item> __result__ = new global::System.Collections.Generic.List<Foo.Item>();
                         int __ordinal_string_value = __reader__.GetOrdinal("string_value");
                         int __ordinal_int32_value = __reader__.GetOrdinal("int32_value");
                         int __ordinal_nullable_int32_value = __reader__.GetOrdinal("nullable_int32_value");
                         while(__reader__.Read())
                         {
                             Foo.Item __data__ = new  Foo.Item ();
                             __data__.StringValue = __reader__.IsDBNull(__ordinal_string_value) ? string.Empty : __reader__.GetString(__ordinal_string_value);
                             __data__.Int32Value = __reader__.IsDBNull(__ordinal_int32_value) ? default : __reader__.GetInt32(__ordinal_int32_value);
                             __data__.NullableInt32Value = __reader__.IsDBNull(__ordinal_nullable_int32_value) ? null : __reader__.GetInt32(__ordinal_nullable_int32_value);
                             __result__.Add(__data__);
                         }
 
                         OnExecuted("M", __cmd__, __result__, 
                             global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                         return __result__;
                     }
                 }
                 catch (global::System.Exception ex)
                 {
                     OnExecuteFail("M", __cmd__, ex, 
                         global::System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__);
                     throw;
                 }
             }
         }
 
         partial void OnExecuting(global::System.String methodName, 
             global::System.Data.Common.DbCommand command);
 
         partial void OnExecuted(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Object? result, 
             global::System.Int64 elpased);
 
         partial void OnExecuteFail(global::System.String methodName, 
             global::System.Data.Common.DbCommand command, global::System.Exception exception, 
             global::System.Int64 elpased);
 
     }
 }
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Item has 0 attributes:
 No RepositoryFor attribute found on Item
 Class C has 0 attributes:
 No RepositoryFor attribute found on C
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 1 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes



澶辫触!  - 澶辫触:    44锛岄€氳繃:   603锛屽凡璺宠繃:     1锛屾€昏:   648锛屾寔缁椂闂? 15 s - Sqlx.Tests.dll (net6.0)
  澶辫触 SourceGenerator_GeneratesSqlDefineConstants [42 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆侾ostgreSQL dialect should use quotes and $ prefix
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.SourceGeneratorFunctionalTests.SourceGenerator_GeneratesSqlDefineConstants() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\SourceGeneratorFunctionalTests.cs:line 112
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class TestClass has 0 attributes:
 No RepositoryFor attribute found on TestClass
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 0 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 0 repository classes


  澶辫触 SqlGeneration_MethodBodies_IncludeNotImplementedException [96 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆侻ethod bodies should include NotImplementedException
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.SqlAttributeGenerationTests.SqlGeneration_MethodBodies_IncludeNotImplementedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\SqlAttributeGenerationTests.cs:line 528
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Sample has 0 attributes:
 No RepositoryFor attribute found on Sample
 Class SampleRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on SampleRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class SqlTemplate has 0 attributes:
 No RepositoryFor attribute found on SqlTemplate
 AbstractGenerator.Execute called
 Found 0 methods and 1 repository classes
 RepositoryForAttribute symbol: Sqlx.Annotations.RepositoryForAttribute
 TableNameAttribute symbol: Sqlx.Annotations.TableNameAttribute
 Processing 1 repository classes
 Generating repository implementation for SampleRepository
 === GenerateRepositoryImplementation START for SampleRepository ===
 RepositoryFor attribute found: True
 Constructor arguments count: 1
 First argument kind: Type
 First argument value: TestNamespace.ISampleService
 First argument type: System.Type
 Got type from TypedConstantKind.Type: ISampleService
 IsGenericType: False
 TypeArguments.Length: 0
 TypeParameters.Length: 0
 Service interface: ISampleService
 Generating repository implementation for SampleRepository implementing ISampleService
 Service interface type: Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel.NonErrorNamedTypeSymbol
 Service interface kind: Interface
 Starting entity type inference for interface ISampleService
 === InferEntityTypeFromServiceInterface START ===
 Service interface: ISampleService
 Is generic: False
 Found 4 methods in interface ISampleService
 Analyzing method: GetAll
 Analyzing method: GetById
 Analyzing method: Create
 Analyzing method: DoVoidOperation
 Selected entity type: Sample with score 5
 Inferred entity type: Sample
 Entity Sample has 0 attributes:
 No TableName attribute found on entity
 Using default table name: Sample
 Using table name: Sample
 Generated DbConnection field: connection
 Found 4 methods in interface ISampleService
 Generating implementations for all 4 methods
 Generating method: GetAll with return type: System.Collections.Generic.IList<TestNamespace.Sample>
 Generating method: GetById with return type: TestNamespace.Sample?
 Generating method: Create with return type: int
 Generating method: DoVoidOperation with return type: void
 Generated repository implementation:
 // <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class SampleRepository : TestNamespace.ISampleService
     {
         // Auto-generated DbConnection field for repository operations
         // This field is available to both RepositoryFor and Sqlx generators
         protected readonly global::System.Data.Common.DbConnection connection;
 
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAll using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Sample entities.</returns>
         [Sqlx("SELECT * FROM Sample")]
         public System.Collections.Generic.IList<TestNamespace.Sample> GetAll()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [Sample]";
 
                 OnExecuting("GetAll", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Sample>();
 
                 while (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     var entity = new TestNamespace.Sample
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name)
                     };
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Sample>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAll", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAll", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetById using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="id">The id parameter.</param>
         /// <returns>The Sample result.</returns>
         [Sqlx("SELECT * FROM Sample WHERE Id = @id")]
         public TestNamespace.Sample? GetById(int id)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [Sample] WHERE [Id] = @Id LIMIT 1";
                 var paramId = __cmd__.CreateParameter();
                 paramId.ParameterName = "@Id";
                 paramId.Value = id;
                 __cmd__.Parameters.Add(paramId);
 
                 OnExecuting("GetById", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     var entity = new TestNamespace.Sample
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetById", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetById", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of Create using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="sample">The Sample entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "Sample")]
         public int Create(TestNamespace.Sample sample)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [Sample] ([name]) VALUES (@name)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = sample.Name ?? (object)global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 OnExecuting("Create", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return (int)__result__;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("Create", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("Create", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of DoVoidOperation using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         [Sqlx("SELECT * FROM Sample")]
         public void DoVoidOperation()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             object? __result__ = null;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT * FROM [Sample] LIMIT 1";
 
                 OnExecuting("DoVoidOperation", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 if (reader.Read())
                 {
                     int __ordinal_id = reader.GetOrdinal("id");
                     int __ordinal_name = reader.GetOrdinal("name");
                     var entity = new TestNamespace.Sample
                     {
                         Id = reader.IsDBNull(__ordinal_id) ? default : reader.GetInt32(__ordinal_id),
                         Name = reader.IsDBNull(__ordinal_name) ? string.Empty : reader.GetString(__ordinal_name)
                     };
                     __result__ = entity;
                     return entity;
                 }
 
                 __result__ = null;
                 return null;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("DoVoidOperation", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("DoVoidOperation", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 Adding source file: SampleRepository.Repository.g.cs
 Successfully added repository source file


  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0002") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0002. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0003") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0003. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0004") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0004. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0005") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0005. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0010") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0010. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0011") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0011. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0012") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0012. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0013") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0013. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0014") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0014. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 Messages_ContainsWellFormattedErrorMessages ("SP0015") [< 1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻essages should contain property for error code SP0015. Available properties: SP0001, SP0006, SP0007, SP0008, SP0009
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(String errorCode) in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 303
   at InvokeStub_UtilityClassesFunctionalTests.Messages_ContainsWellFormattedErrorMessages(Object, Span`1)
   at System.Reflection.MethodBaseInvoker.InvokeWithOneArg(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)

  澶辫触 ClassGenerationContext_Class_HasCorrectStructure [1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侰lassGenerationContext should have SqlxAttributeSymbol property
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.ClassGenerationContext_Class_HasCorrectStructure() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 734
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  澶辫触 MethodGenerationContext_Class_HasCorrectStructure [1 ms]
  閿欒娑堟伅:
   Assert.IsNotNull 澶辫触銆侻ethodGenerationContext should have ReturnIsList property
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.UtilityClassesFunctionalTests.MethodGenerationContext_Class_HasCorrectStructure() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\UtilityClassesFunctionalTests.cs:line 828
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  澶辫触 GetDialectProvider_WithOracleDefineTypes_ThrowsNotSupportedException [< 1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithOracleDefineTypes_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 115
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  澶辫触 GetDialectProvider_WithDB2DefineTypes_ThrowsNotSupportedException [< 1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithDB2DefineTypes_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 125
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  澶辫触 GetDialectProvider_WithOracleDefine_ThrowsNotSupportedException [< 1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithOracleDefine_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 138
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  澶辫触 GetDialectProvider_WithDB2Define_ThrowsNotSupportedException [< 1 ms]
  閿欒娑堟伅:
   Assert.ThrowsException 澶辫触銆傞鏈熷紓甯哥被鍨?<System.NotSupportedException>銆傚疄闄呭紓甯哥被鍨?<Sqlx.Core.UnsupportedDialectException>銆?
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.Core.DatabaseDialectFactoryTests.GetDialectProvider_WithDB2Define_ThrowsNotSupportedException() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\Core\DatabaseDialectFactoryTests.cs:line 151
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)


澶辫触!  - 澶辫触:    44锛岄€氳繃:   603锛屽凡璺宠繃:     1锛屾€昏:   648锛屾寔缁椂闂? 19 s - Sqlx.Tests.dll (net8.0)

鏈夊彲鐢ㄧ殑宸ヤ綔璐熻浇鏇存柊銆傛湁鍏宠缁嗕俊鎭紝璇疯繍琛?`dotnet workload list`銆?
