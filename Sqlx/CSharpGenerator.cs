// -----------------------------------------------------------------------
// <copyright file="CSharpGenerator.cs" company="Andrii Kurdiumov">
// Copyright (c) Andrii Kurdiumov. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Sqlx;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <summary>
/// Stored procedures generator for C#.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class CSharpGenerator : AbstractGenerator
{
    private const string CSharpAttributeSource = @"// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable

namespace Sqlx.Annotations
{
    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple = true)]
    internal sealed class SqlxAttribute: System.Attribute
    {
        public SqlxAttribute()
            => StoredProcedureName = string.Empty;

        public SqlxAttribute(string name)
            => StoredProcedureName = name;

        public string StoredProcedureName { get; }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(System.AttributeTargets.Parameter, AllowMultiple = false)]
    internal sealed class RawSqlAttribute: System.Attribute
    {
        public RawSqlAttribute() {}
    }
    
    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false)]
    internal sealed class RepositoryAttribute: global::System.Attribute
    {
        public RepositoryAttribute(global::System.Type entityType)
        {
            EntityType = entityType;
        }

        public global::System.Type EntityType { get; }
    }
}
";

    /// <inheritdoc/>
    public override void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization((pi) =>
        {
            pi.AddSource("SqlxAttribute.g.cs", CSharpAttributeSource);
        });
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    /// <inheritdoc/>
    protected override SyntaxNode GetParameters(IMethodSymbol methodSymbol)
    {
        var parametersNodes = methodSymbol.Parameters.Select((parameterSymbol, index) => GetParameterDeclaration(methodSymbol, parameterSymbol, index));
        var separatedList = methodSymbol.Parameters.Length == 0
            ? SeparatedList<ParameterSyntax>()
            : SeparatedList(parametersNodes, methodSymbol.Parameters.Take(methodSymbol.Parameters.Length - 1).Select(_ => Token(SyntaxKind.CommaToken).WithTrailingTrivia(Whitespace(" "))));
        return ParameterList(separatedList);
    }

    private static ParameterSyntax GetParameterDeclaration(IMethodSymbol methodSymbol, IParameterSymbol parameter, int index)
    {
        var typeAsClause = ParseTypeName(parameter.Type.ToDisplayString()).WithTrailingTrivia(Whitespace(" "));
        if (parameter.RefKind == RefKind.Out)
        {
            return CreateParameterSyntax(SyntaxKind.OutKeyword);
        }
        else if (parameter.RefKind == RefKind.Ref)
        {
            return CreateParameterSyntax(SyntaxKind.RefKeyword);
        }
        else if (methodSymbol.IsExtensionMethod && index == 0)
        {
            return CreateParameterSyntax(SyntaxKind.ThisKeyword);
        }
        else
        {
            var parameterSyntax = Parameter(default, default, typeAsClause, Identifier(parameter.Name), @default: null);
            return parameterSyntax;
        }

        ParameterSyntax CreateParameterSyntax(SyntaxKind kind)
        {
            return Parameter(default, SyntaxTokenList.Create(Token(kind).WithTrailingTrivia(Whitespace(" "))), typeAsClause, Identifier(parameter.Name), @default: null);
        }
    }

    internal class SyntaxReceiver : ISqlxSyntaxReceiver
    {
        public List<IMethodSymbol> Methods { get; } = new List<IMethodSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is MethodDeclarationSyntax methodDeclarationSyntax)
            {
                // Get the symbol being declared by the field, and keep it if its annotated
                if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not IMethodSymbol methodSymbol)
                {
                    return;
                }

                if (methodSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.SqlxAttribute"))
                {
                    this.Methods.Add(methodSymbol);
                }

                if (methodSymbol.ContainingType.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.RepositoryAttribute"))
                {
                    this.Methods.Add(methodSymbol);
                }
            }
        }
    }
}
