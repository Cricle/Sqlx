// -----------------------------------------------------------------------
// <copyright file="AttributeSourceGenerator.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Sqlx.Core;

/// <summary>
/// Generates the C# attribute source code in a more readable and maintainable way.
/// </summary>
internal static class AttributeSourceGenerator
{
    /// <summary>
    /// Generates the complete C# attribute source.
    /// </summary>
    public static string GenerateAttributeSource()
    {
        return @"// <auto-generated>
// This code was generated by Sqlx Source Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text or stored procedure name for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = true, Inherited = false)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""SqlxAttribute""/> class.
        /// </summary>
        public SqlxAttribute()
        {
            StoredProcedureName = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref=""SqlxAttribute""/> class.
        /// </summary>
        /// <param name=""storedProcedureName"">The stored procedure name.</param>
        public SqlxAttribute(string storedProcedureName)
        {
            StoredProcedureName = storedProcedureName ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; set; }
    }

    /// <summary>
    /// Specifies raw SQL command text for methods or parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""RawSqlAttribute""/> class.
        /// </summary>
        public RawSqlAttribute()
        {
            Sql = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref=""RawSqlAttribute""/> class.
        /// </summary>
        /// <param name=""sql"">The raw SQL command text.</param>
        public RawSqlAttribute(string sql)
        {
            Sql = sql ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the raw SQL command text.
        /// </summary>
        public string Sql { get; set; }
    }

    /// <summary>
    /// Indicates that a parameter should be converted from a LINQ expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
        AllowMultiple = false, Inherited = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
    }

    /// <summary>
    /// Specifies CRUD operation types and target table names.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method,
        AllowMultiple = false, Inherited = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""SqlExecuteTypeAttribute""/> class.
        /// </summary>
        /// <param name=""executeType"">The SQL operation type.</param>
        /// <param name=""tableName"">The target table name.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
        {
            ExecuteType = executeType;
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the SQL operation type.
        /// </summary>
        public SqlExecuteTypes ExecuteType { get; }

        /// <summary>
        /// Gets the target table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Marks a class as a repository for a specified service interface.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class,
        AllowMultiple = false, Inherited = false)]
    public sealed class RepositoryForAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""RepositoryForAttribute""/> class.
        /// </summary>
        /// <param name=""serviceType"">The service interface type.</param>
        public RepositoryForAttribute(global::System.Type serviceType)
        {
            ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
        }

        /// <summary>
        /// Gets the service interface type.
        /// </summary>
        public global::System.Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the database table name for an entity.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    public sealed class TableNameAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""TableNameAttribute""/> class.
        /// </summary>
        /// <param name=""tableName"">The database table name.</param>
        public TableNameAttribute(string tableName)
        {
            TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
        }

        /// <summary>
        /// Gets the database table name.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Defines SQL operation types for CRUD operations.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>SELECT operation.</summary>
        Select = 0,
        /// <summary>UPDATE operation.</summary>
        Update = 1,
        /// <summary>INSERT operation.</summary>
        Insert = 2,
        /// <summary>DELETE operation.</summary>
        Delete = 3,
        /// <summary>Batch INSERT operation.</summary>
        BatchInsert = 4,
        /// <summary>Batch UPDATE operation.</summary>
        BatchUpdate = 5,
        /// <summary>Batch DELETE operation.</summary>
        BatchDelete = 6,
        /// <summary>ADO.NET BatchCommand operation.</summary>
        BatchCommand = 7
    }

    /// <summary>
    /// Defines database dialect types for SQL generation.
    /// </summary>
    public enum SqlDefineTypes
    {
        /// <summary>MySQL dialect with backtick column wrapping.</summary>
        MySql = 0,
        /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
        SqlServer = 1,
        /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
        Postgresql = 2,
        /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
        Oracle = 3,
        /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
        DB2 = 4,
        /// <summary>SQLite dialect with square bracket column wrapping.</summary>
        SQLite = 5
    }

    /// <summary>
    /// Provides database dialect-specific SQL formatting definitions.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) MySql = (""`"", ""`"", ""'"", ""'"", ""@"");

        /// <summary>
        /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) SqlServer = (""["", ""]"", ""'"", ""'"", ""@"");

        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = (""\"""", ""\"""", ""'"", ""'"", ""$"");

        /// <summary>
        /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Oracle = (""\"""", ""\"""", ""'"", ""'"", "":"");

        /// <summary>
        /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) DB2 = (""\"""", ""\"""", ""'"", ""'"", ""?"");

        /// <summary>
        /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) Sqlite = (""["", ""]"", ""'"", ""'"", ""@"");
    }

    /// <summary>
    /// Represents a SQL template with parameterized command text and parameters.
    /// </summary>
    public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);

    /// <summary>
    /// Provides LINQ expression to SQL conversion functionality.
    /// </summary>
    /// <typeparam name=""T"">The entity type for expressions.</typeparam>
    public class ExpressionToSql<T> : global::System.IDisposable
    {
        private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
            new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
        private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
            new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
            new global::System.Collections.Generic.List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;

        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }

        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);

        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);

        /// <summary>
        /// Creates an ExpressionToSql builder for Oracle dialect.
        /// </summary>
        public static ExpressionToSql<T> ForOracle()
            => new ExpressionToSql<T>(SqlDefine.Oracle);

        /// <summary>
        /// Creates an ExpressionToSql builder for DB2 dialect.
        /// </summary>
        public static ExpressionToSql<T> ForDB2()
            => new ExpressionToSql<T>(SqlDefine.DB2);

        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.Sqlite);

        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);

        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
        {
            return Where(predicate);
        }

        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }

        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }

        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }

        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }

        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }

        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
            global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }

        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
        {
            return this;
        }

        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }

        private string BuildSql()
        {
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                var sql = new global::System.Text.StringBuilder();
                sql.Append(""UPDATE "");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append("" SET "");
                var setClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($""{column} = {value}"");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($""{column} = {expression}"");
                }
                sql.Append(string.Join("", "", setClauses));

                if (_whereConditions.Count > 0)
                {
                    sql.Append("" WHERE "");
                    var conditions = new global::System.Collections.Generic.List<string>();
                    foreach (var condition in _whereConditions)
                    {
                        var conditionSql = ParseExpression(condition.Body);
                        conditions.Add($""({conditionSql})"");
                    }
                    sql.Append(string.Join("" AND "", conditions));
                }
                return sql.ToString();
            }

            var selectSql = new global::System.Text.StringBuilder();
            selectSql.Append(""SELECT * FROM "");
            selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);

            if (_whereConditions.Count > 0)
            {
                selectSql.Append("" WHERE "");
                var conditions = new global::System.Collections.Generic.List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($""({conditionSql})"");
                }
                selectSql.Append(string.Join("" AND "", conditions));
            }

            if (_orderByExpressions.Count > 0)
            {
                selectSql.Append("" ORDER BY "");
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? "" DESC"" : "" ASC"";
                    orderClauses.Add(columnName + direction);
                }
                selectSql.Append(string.Join("", "", orderClauses));
            }

            if (_skip.HasValue)
            {
                selectSql.Append($"" OFFSET {_skip.Value}"");
            }

            if (_take.HasValue)
            {
                selectSql.Append($"" LIMIT {_take.Value}"");
            }

            return selectSql.ToString();
        }

        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate.HasValue)
                return _cachedTemplate.Value;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
            return _cachedTemplate.Value;
        }

        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }

        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new global::System.Collections.Generic.List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($""({conditionSql})"");
            }
            return string.Join("" AND "", conditions);
        }

        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new global::System.Collections.Generic.List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new global::System.Collections.Generic.List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? "" DESC"" : "" ASC"";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add(""ORDER BY "" + string.Join("", "", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($""OFFSET {_skip.Value}"");
            }
            if (_take.HasValue)
            {
                clauses.Add($""LIMIT {_take.Value}"");
            }
            return string.Join("" "", clauses);
        }

        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }

        private string ParseExpression(global::System.Linq.Expressions.Expression expression)
        {
            switch (expression)
            {
                case global::System.Linq.Expressions.BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case global::System.Linq.Expressions.MemberExpression member:
                    return GetColumnName(member);
                case global::System.Linq.Expressions.ConstantExpression constant:
                    return GetConstantValue(constant);
                case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                    return $""NOT ({ParseExpression(unary.Operand)})"";
                default:
                    return ""1=1"";
            }
        }

        private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                global::System.Linq.Expressions.ExpressionType.Equal => $""{left} = {right}"",
                global::System.Linq.Expressions.ExpressionType.NotEqual => $""{left} <> {right}"",
                global::System.Linq.Expressions.ExpressionType.GreaterThan => $""{left} > {right}"",
                global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $""{left} >= {right}"",
                global::System.Linq.Expressions.ExpressionType.LessThan => $""{left} < {right}"",
                global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $""{left} <= {right}"",
                global::System.Linq.Expressions.ExpressionType.AndAlso => $""({left} AND {right})"",
                global::System.Linq.Expressions.ExpressionType.OrElse => $""({left} OR {right})"",
                global::System.Linq.Expressions.ExpressionType.Add => $""{left} + {right}"",
                global::System.Linq.Expressions.ExpressionType.Subtract => $""{left} - {right}"",
                global::System.Linq.Expressions.ExpressionType.Multiply => $""{left} * {right}"",
                global::System.Linq.Expressions.ExpressionType.Divide => $""{left} / {right}"",
                global::System.Linq.Expressions.ExpressionType.Modulo => $""{left} % {right}"",
                _ => $""{left} = {right}""
            };
        }

        private string GetColumnName(global::System.Linq.Expressions.Expression expression)
        {
            if (expression is global::System.Linq.Expressions.MemberExpression member)
            {
                var columnName = member.Member.Name;
                return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
            }
            return ""Column"";
        }

        private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
        {
            return FormatConstantValue(constant.Value);
        }

        private string FormatConstantValue(object? value)
        {
            if (value == null)
                return ""NULL"";
            return value switch
            {
                string s => _dialect.StringLeft + s.Replace(""'"", ""''"") + _dialect.StringRight,
                bool b => b ? ""1"" : ""0"",
                global::System.DateTime dt => _dialect.StringLeft + dt.ToString(""yyyy-MM-dd HH:mm:ss"") + _dialect.StringRight,
                _ => value.ToString() ?? ""NULL""
            };
        }
    }

    /// <summary>
    /// Specifies the entity type for DbContext methods returning tuples or generic collections.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public sealed class DbSetTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""DbSetTypeAttribute""/> class.
        /// </summary>
        /// <param name=""type"">The entity type.</param>
        public DbSetTypeAttribute(global::System.Type type)
        {
            Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Gets the entity type.
        /// </summary>
        public global::System.Type Type { get; }
    }

    /// <summary>
    /// Specifies the database dialect for SQL generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class SqlDefineAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""SqlDefineAttribute""/> class with a predefined dialect.
        /// </summary>
        /// <param name=""dialectType"">The database dialect type.</param>
        public SqlDefineAttribute(SqlDefineTypes dialectType)
        {
            DialectType = dialectType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref=""SqlDefineAttribute""/> class with custom dialect settings.
        /// </summary>
        /// <param name=""columnLeft"">Left column delimiter.</param>
        /// <param name=""columnRight"">Right column delimiter.</param>
        /// <param name=""stringLeft"">Left string delimiter.</param>
        /// <param name=""stringRight"">Right string delimiter.</param>
        /// <param name=""parameterPrefix"">Parameter prefix.</param>
        public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
        {
            ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
            ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
            StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
            StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
            ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
        }

        /// <summary>
        /// Gets the database dialect type.
        /// </summary>
        public SqlDefineTypes? DialectType { get; }

        /// <summary>
        /// Gets the left column delimiter.
        /// </summary>
        public string? ColumnLeft { get; }

        /// <summary>
        /// Gets the right column delimiter.
        /// </summary>
        public string? ColumnRight { get; }

        /// <summary>
        /// Gets the left string delimiter.
        /// </summary>
        public string? StringLeft { get; }

        /// <summary>
        /// Gets the right string delimiter.
        /// </summary>
        public string? StringRight { get; }

        /// <summary>
        /// Gets the parameter prefix.
        /// </summary>
        public string? ParameterPrefix { get; }
    }
}";
    }
}
