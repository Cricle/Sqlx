// <copyright file="EntityProviderGenerator.cs" company="Sqlx">
// Copyright (c) Sqlx. All rights reserved.
// </copyright>

namespace Sqlx;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

/// <summary>
/// Source generator that creates IEntityProvider and IResultReader implementations for classes marked with [SqlxEntity].
/// </summary>
/// <remarks>
/// <para>
/// This generator produces AOT-compatible, reflection-free implementations for:
/// </para>
/// <list type="bullet">
/// <item><description><c>IEntityProvider</c> - Provides column metadata for SQL generation</description></item>
/// <item><description><c>IResultReader&lt;T&gt;</c> - Reads entities from DbDataReader efficiently</description></item>
/// </list>
/// <para>
/// The generated code respects:
/// </para>
/// <list type="bullet">
/// <item><description>[Column] attribute for custom column name mapping</description></item>
/// <item><description>[IgnoreDataMember] attribute to exclude properties</description></item>
/// <item><description>Nullable annotations for proper null handling</description></item>
/// </list>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public class EntityProviderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,
                transform: static (ctx, _) => GetTarget(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static ClassDeclarationSyntax? GetTarget(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        foreach (var attrList in classDecl.AttributeLists)
        {
            foreach (var attr in attrList.Attributes)
            {
                var name = attr.Name.ToString();
                if (name is "SqlxEntity" or "SqlxEntityAttribute")
                    return classDecl;
            }
        }
        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty) return;

        var sqlxEntityAttr = compilation.GetTypeByMetadataName("Sqlx.Annotations.SqlxEntityAttribute");
        if (sqlxEntityAttr is null) return;

        var ignoreAttr = compilation.GetTypeByMetadataName("System.Runtime.Serialization.IgnoreDataMemberAttribute");
        var columnAttr = compilation.GetTypeByMetadataName("System.ComponentModel.DataAnnotations.Schema.ColumnAttribute");

        foreach (var classDecl in classes.Distinct())
        {
            if (classDecl is null) continue;

            var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol typeSymbol) continue;

            var hasAttr = typeSymbol.GetAttributes().Any(a =>
                SymbolEqualityComparer.Default.Equals(a.AttributeClass, sqlxEntityAttr));
            if (!hasAttr) continue;

            // Check if class is partial
            var isPartial = classDecl.Modifiers.Any(m => m.ValueText == "partial");

            var source = GenerateSource(typeSymbol, ignoreAttr, columnAttr, isPartial);
            context.AddSource($"{typeSymbol.Name}.EntityProvider.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateSource(INamedTypeSymbol typeSymbol, INamedTypeSymbol? ignoreAttr, INamedTypeSymbol? columnAttr, bool isPartial)
    {
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace ? null : typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;
        var fullTypeName = typeSymbol.ToDisplayString();

        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic && p.GetMethod is not null)
            .Where(p => ignoreAttr is null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
            .ToList();

        var sb = new IndentedStringBuilder(null);
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace " + (ns ?? "Global") + ";");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Data.Common;");
        sb.AppendLine();

        // Add static registration to the entity type only if it's partial
        if (isPartial)
        {
            GenerateEntityTypeExtension(sb, typeName, fullTypeName);
            sb.AppendLine();
        }

        // EntityProvider
        GenerateEntityProvider(sb, typeName, fullTypeName, properties, columnAttr);
        sb.AppendLine();

        // ResultReader
        GenerateResultReader(sb, typeName, fullTypeName, properties, columnAttr);

        return sb.ToString();
    }

    private static void GenerateEntityTypeExtension(IndentedStringBuilder sb, string typeName, string fullTypeName)
    {
        sb.AppendLine($"// Auto-registration for {typeName}");
        sb.AppendLine($"partial class {typeName}");
        sb.AppendLine("{");
        sb.PushIndent();
        sb.AppendLine($"static {typeName}()");
        sb.AppendLine("{");
        sb.PushIndent();
        sb.AppendLine($"global::Sqlx.SqlQuery<{fullTypeName}>.EntityProvider = {typeName}EntityProvider.Default;");
        sb.PopIndent();
        sb.AppendLine("}");
        sb.PopIndent();
        sb.AppendLine("}");
    }

    private static void GenerateEntityProvider(IndentedStringBuilder sb, string typeName, string fullTypeName, 
        System.Collections.Generic.List<IPropertySymbol> properties, INamedTypeSymbol? columnAttr)
    {
        sb.AppendLine($"public sealed class {typeName}EntityProvider : global::Sqlx.IEntityProvider");
        sb.AppendLine("{");
        sb.PushIndent();

        sb.AppendLine($"public static {typeName}EntityProvider Default {{ get; }} = new();");
        sb.AppendLine($"private static readonly Type _entityType = typeof({fullTypeName});");
        sb.AppendLine("private static readonly IReadOnlyList<global::Sqlx.ColumnMeta> _columns = new global::Sqlx.ColumnMeta[]");
        sb.AppendLine("{");
        sb.PushIndent();

        foreach (var prop in properties)
        {
            var columnName = GetColumnName(prop, columnAttr);
            var dbType = GetDbType(prop.Type);
            var isNullable = IsNullable(prop);
            sb.AppendLine($"new global::Sqlx.ColumnMeta(\"{columnName}\", \"{prop.Name}\", DbType.{dbType}, {isNullable.ToString().ToLowerInvariant()}),");
        }

        sb.PopIndent();
        sb.AppendLine("};");
        sb.AppendLine("public Type EntityType => _entityType;");
        sb.AppendLine("public IReadOnlyList<global::Sqlx.ColumnMeta> Columns => _columns;");

        sb.PopIndent();
        sb.AppendLine("}");
    }

    private static void GenerateResultReader(IndentedStringBuilder sb, string typeName, string fullTypeName,
        System.Collections.Generic.List<IPropertySymbol> properties, INamedTypeSymbol? columnAttr)
    {
        sb.AppendLine($"public sealed class {typeName}ResultReader : global::Sqlx.IResultReader<{fullTypeName}>");
        sb.AppendLine("{");
        sb.PushIndent();

        sb.AppendLine($"public static {typeName}ResultReader Default {{ get; }} = new();");
        sb.AppendLine();

        // Generate column name constants
        sb.AppendLine("// Column names");
        for (int i = 0; i < properties.Count; i++)
        {
            var columnName = GetColumnName(properties[i], columnAttr);
            sb.AppendLine($"private const string Col{i} = \"{columnName}\";");
        }
        sb.AppendLine();

        // GetOrdinals method
        GenerateGetOrdinalsMethod(sb, properties);
        sb.AppendLine();

        // Read(IDataReader) method
        GenerateReadMethod(sb, fullTypeName, properties);
        sb.AppendLine();

        // Read(IDataReader, int[]) method
        GenerateReadWithOrdinalsMethod(sb, fullTypeName, properties);

        sb.PopIndent();
        sb.AppendLine("}");
    }

    private static void GenerateGetOrdinalsMethod(IndentedStringBuilder sb, System.Collections.Generic.List<IPropertySymbol> properties)
    {
        sb.AppendLine("public int[] GetOrdinals(IDataReader reader)");
        sb.AppendLine("{");
        sb.PushIndent();
        sb.AppendLine($"return new int[{properties.Count}]");
        sb.AppendLine("{");
        sb.PushIndent();
        for (int i = 0; i < properties.Count; i++)
        {
            sb.AppendLine($"reader.GetOrdinal(Col{i}),");
        }
        sb.PopIndent();
        sb.AppendLine("};");
        sb.PopIndent();
        sb.AppendLine("}");
    }

    private static void GenerateReadMethod(IndentedStringBuilder sb, string fullTypeName,
        System.Collections.Generic.List<IPropertySymbol> properties)
    {
        sb.AppendLine($"public {fullTypeName} Read(IDataReader reader)");
        sb.AppendLine("{");
        sb.PushIndent();

        sb.AppendLine($"return new {fullTypeName}");
        sb.AppendLine("{");
        sb.PushIndent();

        for (int i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var isNullable = IsNullable(prop);
            // Inline GetOrdinal call directly
            var readExpr = GetReaderExpression(prop.Type, $"reader.GetOrdinal(Col{i})", isNullable);
            sb.AppendLine($"{prop.Name} = {readExpr},");
        }

        sb.PopIndent();
        sb.AppendLine("};");

        sb.PopIndent();
        sb.AppendLine("}");
    }

    private static void GenerateReadWithOrdinalsMethod(IndentedStringBuilder sb, string fullTypeName,
        System.Collections.Generic.List<IPropertySymbol> properties)
    {
        sb.AppendLine($"public {fullTypeName} Read(IDataReader reader, int[] ordinals)");
        sb.AppendLine("{");
        sb.PushIndent();

        sb.AppendLine($"return new {fullTypeName}");
        sb.AppendLine("{");
        sb.PushIndent();

        for (int i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var isNullable = IsNullable(prop);
            var readExpr = GetReaderExpression(prop.Type, $"ordinals[{i}]", isNullable);
            sb.AppendLine($"{prop.Name} = {readExpr},");
        }

        sb.PopIndent();
        sb.AppendLine("};");

        sb.PopIndent();
        sb.AppendLine("}");
    }

    private static string GetColumnName(IPropertySymbol prop, INamedTypeSymbol? columnAttr)
    {
        if (columnAttr is not null)
        {
            var attr = prop.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, columnAttr));
            if (attr?.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is string name)
                return name;
        }
        return ToSnakeCase(prop.Name);
    }

    private static string ToSnakeCase(string name)
    {
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsUpper(c) && i > 0) sb.Append('_');
            sb.Append(char.ToLowerInvariant(c));
        }
        return sb.ToString();
    }

    private static bool IsNullable(IPropertySymbol prop)
    {
        if (prop.NullableAnnotation == NullableAnnotation.Annotated) return true;
        if (prop.Type.IsValueType && prop.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T) return true;
        return false;
    }

    private static string GetDbType(ITypeSymbol type)
    {
        var typeName = GetUnderlyingTypeName(type);
        return typeName switch
        {
            "Int32" => "Int32",
            "Int64" => "Int64",
            "Int16" => "Int16",
            "Byte" => "Byte",
            "Boolean" => "Boolean",
            "String" => "String",
            "DateTime" => "DateTime",
            "DateTimeOffset" => "DateTimeOffset",
            "Decimal" => "Decimal",
            "Double" => "Double",
            "Single" => "Single",
            "Guid" => "Guid",
            _ => "Object",
        };
    }

    private static string GetUnderlyingTypeName(ITypeSymbol type)
    {
        if (type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T && type is INamedTypeSymbol namedType)
            return namedType.TypeArguments[0].Name;
        return type.Name;
    }

    private static string GetReaderExpression(ITypeSymbol type, string ordinal, bool isNullable)
    {
        var typeName = GetUnderlyingTypeName(type);
        var method = typeName switch
        {
            "Int32" => "GetInt32",
            "Int64" => "GetInt64",
            "Int16" => "GetInt16",
            "Byte" => "GetByte",
            "Boolean" => "GetBoolean",
            "String" => "GetString",
            "DateTime" => "GetDateTime",
            "Decimal" => "GetDecimal",
            "Double" => "GetDouble",
            "Single" => "GetFloat",
            "Guid" => "GetGuid",
            _ => null,
        };

        if (method is null)
            return isNullable ? $"reader.IsDBNull({ordinal}) ? default : reader.GetValue({ordinal})" : $"reader.GetValue({ordinal})";

        if (isNullable)
            return $"reader.IsDBNull({ordinal}) ? default : reader.{method}({ordinal})";

        return $"reader.{method}({ordinal})";
    }
}
