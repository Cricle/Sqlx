// -----------------------------------------------------------------------
// <copyright file="MethodGenerationListReturnTests.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;

namespace Sqlx.Tests.Core;

[TestClass]
public class MethodGenerationListReturnTests
{
    [TestMethod]
    public void Generated_Method_Returns_List_Handles_Mapping_Or_Fallback()
    {
        var source = @"using System.Data.Common; using Sqlx.Annotations; using System.Threading.Tasks; using System.Collections.Generic;
namespace LNS {
  [RepositoryFor(typeof(IRepo))]
  public partial class Repo : IRepo { private readonly DbConnection connection; public Repo(DbConnection c){connection=c;} }
  public interface IRepo {
    [RawSql(""SELECT Id FROM Users"")] Task<List<int>> GetIdsAsync();
  }
}";

        var code = Generate(source);
        // Accept either full mapping or generator fallback
        StringAssert.Contains(code, "GetIdsAsync");
        Assert.IsTrue(
            code.Contains("List<int>") ||
            code.Contains("Task.FromResult<List<int>>(default)")
        );
    }

    private static string Generate(string source)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);
        var references = new List<MetadataReference>
        {
            MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(System.Data.Common.DbConnection).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(System.Threading.Tasks.Task).Assembly.Location)
        };

        var compilation = CSharpCompilation.Create(
            "GenListAsm",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        var generator = new CSharpGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnostics);

        var generated = new List<string>();
        foreach (var tree in newCompilation.SyntaxTrees)
        {
            var text = tree.ToString();
            if (text.Contains("// <auto-generated>") || string.IsNullOrEmpty(tree.FilePath))
            {
                generated.Add(text);
            }
        }
        return string.Join("\n", generated);
    }
}


