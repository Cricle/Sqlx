// -----------------------------------------------------------------------
// <auto-generated>
// -----------------------------------------------------------------------

#nullable enable

namespace Sqlx;

using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

public partial class CSharpGenerator
{
    /// <summary>
    /// C# specific syntax receiver for collecting method symbols and repository classes.
    /// </summary>
    internal class CSharpSyntaxReceiver : ISyntaxReceiver
    {
        /// <summary>Gets the list of collected method symbols.</summary>
        public List<IMethodSymbol> Methods { get; } = new List<IMethodSymbol>();
        /// <summary>Gets the set of collected repository classes (deduplicated).</summary>
        public HashSet<INamedTypeSymbol> RepositoryClasses { get; } = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        // Collect syntax nodes for later processing
        /// <summary>Gets the list of collected method declaration syntax nodes.</summary>
        public List<MethodDeclarationSyntax> MethodSyntaxNodes { get; } = new List<MethodDeclarationSyntax>();
        /// <summary>Gets the list of collected class declaration syntax nodes.</summary>
        public List<ClassDeclarationSyntax> ClassSyntaxNodes { get; } = new List<ClassDeclarationSyntax>();

        /// <summary>Visits a syntax node and collects relevant method and class declarations.</summary>
        /// <param name="syntaxNode">The syntax node to visit.</param>
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Collect method declarations with potential Sqlx attributes
            if (syntaxNode is MethodDeclarationSyntax methodDeclaration && HasSqlxAttributeSyntax(methodDeclaration))
            {
                MethodSyntaxNodes.Add(methodDeclaration);
            }
            // Collect class declarations with potential RepositoryFor attributes
            else if (syntaxNode is ClassDeclarationSyntax classDeclaration && HasRepositoryForAttributeSyntax(classDeclaration))
            {
                ClassSyntaxNodes.Add(classDeclaration);
            }
        }

        /// <summary>Visits a syntax node with semantic model context for enhanced analysis.</summary>
        /// <param name="context">The generator syntax context containing the syntax node and semantic model.</param>
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            var semanticModel = context.SemanticModel;

            // Collect methods with Sqlx attributes
            if (context.Node is MethodDeclarationSyntax methodDeclaration &&
                semanticModel.GetDeclaredSymbol(methodDeclaration) is IMethodSymbol method &&
                HasSqlxAttribute(method))
            {
                Methods.Add(method);
            }
            // Collect repository classes with RepositoryFor attributes
            else if (context.Node is ClassDeclarationSyntax classDeclaration &&
                     semanticModel.GetDeclaredSymbol(classDeclaration) is INamedTypeSymbol type &&
                     HasRepositoryForAttribute(type))
            {
                RepositoryClasses.Add(type);
            }
        }

        private static bool HasSqlxAttribute(IMethodSymbol method)
        {
            // Only collect methods declared in classes to avoid generating implementations for interfaces
            if (method.ContainingType?.TypeKind != TypeKind.Class)
                return false;

            // Check semantic attributes first
            if (HasSemanticSqlxAttribute(method))
                return true;

            // Fallback: syntax-based detection for tests without using directives
            return HasSyntaxSqlxAttribute(method);
        }

        private static bool HasSemanticSqlxAttribute(IMethodSymbol method) =>
            method.GetAttributes().Any(attr => IsSqlxAttributeName(attr.AttributeClass?.Name));

        private static bool HasSyntaxSqlxAttribute(IMethodSymbol method)
        {
            var syntax = method.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax;
            return syntax?.AttributeLists.Any(attrList =>
                attrList.Attributes.Any(attr => IsSqlxAttributeName(attr.Name.ToString()))) == true;
        }

        private static bool IsSqlxAttributeName(string? name) => name is
            "SqlxAttribute" or "Sqlx" or "SqlTemplateAttribute" or "SqlTemplate" or
            "SqlExecuteTypeAttribute" or "SqlExecuteType";

        private static bool HasSqlxAttributeSyntax(MethodDeclarationSyntax methodDeclaration) =>
            methodDeclaration.AttributeLists.Any(attrList =>
                attrList.Attributes.Any(attr => IsSqlxAttributeName(attr.Name.ToString())));

        private static bool HasRepositoryForAttributeSyntax(ClassDeclarationSyntax classDeclaration) =>
            classDeclaration.AttributeLists.Any(attrList =>
                attrList.Attributes.Any(attr => IsRepositoryForAttributeName(attr.Name.ToString())));

        private static bool HasRepositoryForAttribute(INamedTypeSymbol type) =>
            type.GetAttributes().Any(attr => IsRepositoryForAttributeName(attr.AttributeClass?.Name));

        private static bool IsRepositoryForAttributeName(string? name)
        {
            if (string.IsNullOrEmpty(name))
                return false;

            // Support both non-generic and generic syntax:
            // - Non-generic: "RepositoryFor" or "RepositoryForAttribute"
            // - Generic: "RepositoryFor<T>" or "RepositoryForAttribute<T>"
            return name == "RepositoryFor" ||
                   name == "RepositoryForAttribute" ||
                   name.StartsWith("RepositoryFor<") ||
                   name.StartsWith("RepositoryForAttribute<");
        }
    }
}


