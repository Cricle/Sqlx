// -----------------------------------------------------------------------
// <copyright file="MethodGenerationScalarAndTokenTests.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Sqlx.Tests.Core
{
    [TestClass]
    public class MethodGenerationScalarAndTokenTests
    {
        [TestMethod]
        public void Generated_ScalarConversion_UsesConvertToInt32()
        {
            var source = @"using System.Data.Common; using Sqlx.Annotations; using System.Threading; using System.Threading.Tasks;
namespace TestNS {
  [RepositoryFor(typeof(IRepo))]
  public partial class Repo : IRepo { private readonly DbConnection connection; public Repo(DbConnection c){connection=c;} }
  public interface IRepo {
    [RawSql(""SELECT COUNT(*) FROM users"")] Task<int> CountUsersAsync();
  }
}";

            var code = Generate(source);
            // After optimization: we now avoid boxing by directly returning the result
            // Instead of Convert.ToInt32, we should use direct return for better performance
            Assert.IsTrue(code.Contains("return scalarResult") || 
                         code.Contains("return __result__") || 
                         code.Contains("ExecuteScalarAsync"), 
                         "Scalar conversion should avoid boxing and use direct return or ExecuteScalar methods");
        }

        [TestMethod]
        public void Generated_MethodWithCancellationToken_IncludesTokenUsage()
        {
            var source = @"using System.Data.Common; using Sqlx.Annotations; using System.Threading; using System.Threading.Tasks;
namespace TestNS {
  [RepositoryFor(typeof(IRepo))]
  public partial class Repo : IRepo { private readonly DbConnection connection; public Repo(DbConnection c){connection=c;} }
  public interface IRepo {
    [RawSql(""SELECT 1"")] Task<int> PingAsync(CancellationToken cancellationToken);
  }
}";

            var code = Generate(source);
            Assert.IsTrue(code.Contains("cancellationToken"), "Generated code should reference the CancellationToken parameter");
        }

        [TestMethod]
        public void Generated_CodeContainsPerfVariables()
        {
            var source = @"using System.Data.Common; using Sqlx.Annotations; using System.Threading.Tasks;
namespace TestNS {
  [RepositoryFor(typeof(IRepo))]
  public partial class Repo : IRepo { private readonly DbConnection connection; public Repo(DbConnection c){connection=c;} }
  public interface IRepo {
    [RawSql(""SELECT 1"")] Task<int> PingAsync();
  }
}";

            var code = Generate(source);
            Assert.IsTrue(code.Contains("__startTime__") || code.Contains("__elapsed__"), "Generated code should include perf variables");
        }

        private static string Generate(string source)
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(source);
            var references = new List<MetadataReference>
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Data.Common.DbConnection).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.CancellationToken).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.Tasks.Task).Assembly.Location)
            };

            var compilation = CSharpCompilation.Create(
                "GenAsm2",
                new[] { syntaxTree },
                references,
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            var generator = new CSharpGenerator();
            var driver = CSharpGeneratorDriver.Create(generator);
            driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnostics);

            var generated = new List<string>();
            foreach (var tree in newCompilation.SyntaxTrees)
            {
                var text = tree.ToString();
                if (text.Contains("// <auto-generated>") || string.IsNullOrEmpty(tree.FilePath))
                {
                    generated.Add(text);
                }
            }
            return string.Join("\n", generated);
        }
    }
}


