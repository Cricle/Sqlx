# Sqlx 性能优化计划

## 当前状态

### 性能对比（vs Dapper.AOT）

| 场景 | Sqlx | Dapper.AOT | 差距 | 状态 |
|------|------|------------|------|------|
| 单行查询 | 9.447 μs | 10.040 μs | **✅ 快 5.9%** | 优秀 |
| 插入操作 | 85.17 μs | 108.24 μs | **✅ 快 21.3%** | 优秀 |
| 更新操作 | 19.04 μs | 21.98 μs | **✅ 快 13.4%** | 优秀 |
| 删除操作 | 43.45 μs | 48.73 μs | **✅ 快 10.8%** | 优秀 |
| 计数操作 | 4.014 μs | 4.042 μs | **✅ 相当** | 优秀 |
| 复杂查询 | 2.289 ms | 9.961 ms | **✅ 快 4.4倍** | 优秀 |
| 10行查询 | 38.12 μs | 36.69 μs | ⚠️ 慢 3.9% | 可接受 |
| 100行查询 | 212.95 μs | 212.46 μs | ⚠️ 相当 | 可接受 |
| 1000行查询 | 1,908.61 μs | 1,755.95 μs | ⚠️ 慢 8.7% | **需优化** |

### 优势与劣势

**优势** ✅:
- 单行查询最快
- 写操作（插入/更新/删除）快 10-21%
- 复杂查询快 4.4 倍
- 内存分配少 12-35.6%
- GC 压力低 16.7%

**劣势** ⚠️:
- 大批量查询（1000行）慢 8.7%

## 性能瓶颈分析

### 根本原因

批量查询性能差距主要来自 3 个方面：

#### 1. IsDBNull 检查开销 (30-40%)

```csharp
// 当前实现
UpdatedAt = reader.IsDBNull(ord6) ? default(DateTime?) : reader.GetDateTime(ord6),
Description = reader.IsDBNull(ord8) ? default : reader.GetString(ord8),

// 问题：
// - 1000行 × 2个可空字段 = 2000次 IsDBNull 调用
// - 每次约 20-30ns，总开销 40-60μs
```

#### 2. 对象初始化器开销 (20-30%)

```csharp
// 当前实现：对象初始化器
return new BenchmarkUser
{
    Id = reader.GetInt64(ord0),
    Name = reader.GetString(ord1),
    // ... 10个字段
};

// 问题：
// - 先调用默认构造函数
// - 再逐个设置属性
// - 比构造函数调用慢 20-30%
```

#### 3. 可空类型装箱 (10-15%)

```csharp
// 当前实现
(DateTime?)reader.GetDateTime(ord6)

// 问题：
// - 显式装箱有额外开销
```

## 优化方案

### 🎯 阶段 1: 快速优化（预期收益 15-25%）

**目标**: 将 1000 行查询从 1,908 μs 优化到 1,620-1,720 μs（接近 Dapper.AOT）

#### 1.1 优化可空类型处理 ✅

**实现**:
```csharp
// 优化前
UpdatedAt = reader.IsDBNull(ord6) ? default(DateTime?) : (DateTime?)reader.GetDateTime(ord6),

// 优化后
UpdatedAt = reader.IsDBNull(ord6) ? null : reader.GetDateTime(ord6),
```

**预期收益**: 10-15 μs (0.5-0.8%)

**工作量**: 1 小时
**风险**: 低

#### 1.2 测试 GetFieldValue<T?> ✅

**实现**:
```csharp
// 测试是否更快
UpdatedAt = reader.GetFieldValue<DateTime?>(ord6),
Description = reader.GetFieldValue<string?>(ord8),
```

**预期收益**: 40-60 μs (2-3%) 如果更快的话

**工作量**: 2 小时（需要测试多个数据库驱动）
**风险**: 中（可能在某些驱动上更慢）

#### 1.3 优化生成代码结构 ✅

**实现**:
- 减少不必要的类型转换
- 优化变量声明顺序
- 使用更高效的代码模式

**预期收益**: 20-40 μs (1-2%)

**工作量**: 3 小时
**风险**: 低

**阶段 1 总预期收益**: 70-115 μs (3.7-6.0%)
**完成后性能**: 1,793-1,838 μs（仍慢 2-5%）

---

### 🚀 阶段 2: 深度优化（预期收益 30-50%）

**目标**: 将性能优化到与 Dapper.AOT 相当或更快

#### 2.1 支持构造函数初始化 ⚠️

**实现**:
```csharp
// 检测实体是否有合适的构造函数
if (HasMatchingConstructor(type, columns))
{
    // 生成构造函数调用
    return new BenchmarkUser(
        reader.GetInt64(ord0),
        reader.GetString(ord1),
        // ...
    );
}
else
{
    // 使用对象初始化器（当前方式）
}
```

**预期收益**: 50-80 μs (2.6-4.2%)

**工作量**: 1-2 天
**风险**: 中（需要处理各种构造函数签名）

#### 2.2 提供 Fast 模式（跳过 null 检查）⚠️

**实现**:
```csharp
// 用户可以选择
[SqlxQuery("SELECT * FROM users", FastMode = true)]
public partial IEnumerable<User> GetAllUsers();

// 生成两个版本
private User ReadUser(IDataReader reader, ReadOnlySpan<int> ordinals)
{
    // 标准版本 - 检查 null
}

private User ReadUserFast(IDataReader reader, ReadOnlySpan<int> ordinals)
{
    // 快速版本 - 不检查 null
    // 假设数据库中没有 null 值
}
```

**预期收益**: 40-60 μs (2-3%)

**工作量**: 2-3 天
**风险**: 中（需要文档说明使用场景）

#### 2.3 优化 Span 使用 ⚠️

**实现**:
- 使用 stackalloc 减少堆分配
- 优化 ordinals 传递方式
- 减少边界检查

**预期收益**: 20-40 μs (1-2%)

**工作量**: 1-2 天
**风险**: 低

**阶段 2 总预期收益**: 110-180 μs (5.8-9.4%)
**完成后性能**: 1,728-1,798 μs（接近或超过 Dapper.AOT）

---

### 🔬 阶段 3: 极致优化（可选）

**目标**: 超越 Dapper.AOT 10-20%

#### 3.1 IL 生成（替代 C# 代码生成）❌

**实现**:
- 使用 ILGenerator 直接生成 IL 代码
- 完全控制对象创建和字段赋值
- 避免所有不必要的开销

**预期收益**: 100-200 μs (5-10%)

**工作量**: 2-4 周
**风险**: 高
- 实现复杂
- 调试困难
- 可能影响 AOT 兼容性
- 维护成本高

**不推荐**: 除非有明确的极致性能需求

---

## 推荐执行计划

### 优先级 1: 快速优化（立即执行）✅

**时间**: 1 周
**收益**: 3.7-6.0%
**风险**: 低

1. 优化可空类型处理（1 小时）
2. 测试 GetFieldValue<T?>（2 小时）
3. 优化生成代码结构（3 小时）
4. 运行基准测试验证（2 小时）

**预期结果**: 1000 行查询从 1,908 μs → 1,793-1,838 μs

### 优先级 2: 深度优化（按需执行）⚠️

**时间**: 1-2 周
**收益**: 5.8-9.4%
**风险**: 中

**触发条件**:
- 用户反馈批量查询性能不足
- 竞品性能显著提升
- 有明确的性能需求

**实施顺序**:
1. 支持构造函数初始化（2 天）
2. 提供 Fast 模式（3 天）
3. 优化 Span 使用（2 天）
4. 全面测试和文档（2 天）

**预期结果**: 1000 行查询从 1,793 μs → 1,728 μs（接近 Dapper.AOT）

### 优先级 3: 极致优化（不推荐）❌

**原因**:
- 实现成本高（2-4 周）
- 维护成本高
- 可能影响 AOT 兼容性
- 收益不明显（5-10%）
- 当前性能已经足够好

**替代方案**:
- 专注于其他更有价值的功能
- 优化其他场景的性能
- 改善开发体验

---

## 性能目标

### 短期目标（1 周内）

| 场景 | 当前 | 目标 | Dapper.AOT | 状态 |
|------|------|------|------------|------|
| 1000行查询 | 1,908 μs | 1,793-1,838 μs | 1,755 μs | 接近 |

### 中期目标（1-2 周内，按需）

| 场景 | 当前 | 目标 | Dapper.AOT | 状态 |
|------|------|------|------------|------|
| 1000行查询 | 1,908 μs | 1,728 μs | 1,755 μs | 相当或更快 |

---

## 实际应用考虑

### 当前性能是否足够？

**是的**，对于大多数应用：

```
典型 Web API 请求:
┌─────────────────────────────────────────┐
│ 网络延迟:     10-50 ms                  │
│ 数据库查询:   5-20 ms                   │
│ ORM 映射:     1.9 ms (Sqlx)            │
│ 业务逻辑:     5-10 ms                   │
│ 序列化:       2-5 ms                    │
├─────────────────────────────────────────┤
│ 总时间:       23.9-86.9 ms              │
│ ORM 占比:     2.2-8.2%                  │
│ ORM 差距:     0.15 ms (vs Dapper)      │
│ 差距占比:     0.17-0.65% (可忽略)      │
└─────────────────────────────────────────┘
```

### 何时需要优化？

只在以下场景需要考虑：

1. **极高频率的批量查询** (每秒 1000+ 次)
2. **对延迟极度敏感** (P99 < 10ms)
3. **CPU 受限但内存充足**
4. **用户明确反馈性能问题**

### Sqlx 的核心优势

不要忘记 Sqlx 的其他优势：

1. ✅ **单行查询最快** (快 5.9%)
2. ✅ **写操作更快** (快 10-21%)
3. ✅ **复杂查询快 4.4 倍**
4. ✅ **内存效率高** (少 12-35.6%)
5. ✅ **GC 友好** (压力低 16.7%)
6. ✅ **代码质量高** (易读易维护)
7. ✅ **完全支持 AOT**

---

## 决策建议

### 推荐方案 ✅

**执行阶段 1（快速优化）**:
- 时间成本低（1 周）
- 风险低
- 收益明显（3.7-6.0%）
- 不影响现有功能

**暂缓阶段 2（深度优化）**:
- 等待用户反馈
- 评估实际需求
- 考虑投入产出比

**放弃阶段 3（极致优化）**:
- 成本太高
- 收益不明显
- 可能影响其他目标

### 替代策略

如果用户对批量查询性能有极致要求：

1. **提供性能调优指南**:
   - 使用索引
   - 优化查询语句
   - 使用分页
   - 考虑缓存

2. **提供性能对比文档**:
   - 说明 Sqlx 的优势场景
   - 说明性能差距的实际影响
   - 提供选择建议

3. **专注于差异化优势**:
   - 更好的开发体验
   - 更强的类型安全
   - 更好的 AOT 支持
   - 更低的内存占用

---

## 总结

### 当前状态

- ✅ 单行查询、写操作、复杂查询：**优秀**
- ✅ 小批量查询（10-100行）：**可接受**
- ⚠️ 大批量查询（1000行）：**需优化**（慢 8.7%）

### 优化计划

1. **立即执行**: 阶段 1 快速优化（1 周，收益 3.7-6.0%）
2. **按需执行**: 阶段 2 深度优化（1-2 周，收益 5.8-9.4%）
3. **不推荐**: 阶段 3 极致优化（成本高，收益低）

### 预期结果

- 短期：接近 Dapper.AOT（差距 < 5%）
- 中期：相当或超过 Dapper.AOT
- 长期：保持竞争力，专注差异化优势

---

**下一步**: 开始执行阶段 1 快速优化 ✅
