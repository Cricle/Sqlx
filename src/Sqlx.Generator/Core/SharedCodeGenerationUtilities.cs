// -----------------------------------------------------------------------
// <copyright file="SharedCodeGenerationUtilities.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;

namespace Sqlx.Generator;

/// <summary>
/// Shared code generation utilities to reduce code duplication
/// </summary>
public static class SharedCodeGenerationUtilities
{
    // ç¼“å­˜ToDisplayString()ç»“æœä»¥æå‡æ€§èƒ½
    private static readonly ConcurrentDictionary<ISymbol, string> _displayStringCache =
        new(SymbolEqualityComparer.Default);

    // ç¼“å­˜ç±»å‹æ£€æŸ¥ç»“æœï¼Œé¿å…é‡å¤çš„ç±»å‹åˆ†æ
    private static readonly ConcurrentDictionary<ITypeSymbol, bool> _isScalarTypeCache =
        new(SymbolEqualityComparer.Default);

    // ç¼“å­˜å±æ€§çš„SQLåç§°
    private static readonly ConcurrentDictionary<IPropertySymbol, string> _sqlNameCache =
        new(SymbolEqualityComparer.Default);

    /// <summary>è·å–ç¬¦å·çš„æ˜¾ç¤ºå­—ç¬¦ä¸²ï¼Œä½¿ç”¨ç¼“å­˜æå‡æ€§èƒ½</summary>
    public static string GetCachedDisplayString(this ISymbol symbol) =>
        _displayStringCache.GetOrAdd(symbol, s => s.ToDisplayString());

    /// <summary>ç¼“å­˜ç‰ˆæœ¬çš„æ ‡é‡ç±»å‹æ£€æŸ¥</summary>
    public static bool IsCachedScalarType(this ITypeSymbol type) =>
        _isScalarTypeCache.GetOrAdd(type, t => t.IsScalarType());

    /// <summary>ç¼“å­˜ç‰ˆæœ¬çš„SQLåç§°è·å–</summary>
    public static string GetCachedSqlName(this IPropertySymbol property) =>
        _sqlNameCache.GetOrAdd(property, p => p.GetSqlName());
    /// <summary>Extract inner type from Task&lt;T&gt; type strings</summary>
    public static string ExtractInnerTypeFromTask(string taskType) => taskType switch
    {
        var t when t.StartsWith("Task<") && t.EndsWith(">") => t.Substring(5, t.Length - 6),
        var t when t.StartsWith("System.Threading.Tasks.Task<") && t.EndsWith(">") => t.Substring(28, t.Length - 29),
        _ => taskType // å¯¹äºéTaskç±»å‹ï¼Œè¿”å›åŸå§‹ç±»å‹è€Œä¸æ˜¯"object"
    };

    /// <summary>Escape SQL string for C# string literal</summary>
    public static string EscapeSqlForCSharp(string? sql)
    {
        if (string.IsNullOrEmpty(sql)) return string.Empty;

        // æ€§èƒ½ä¼˜åŒ–ï¼šå•æ¬¡æ£€æŸ¥é¿å…ä¸å¿…è¦çš„æ“ä½œ
        var hasEscapeChars = sql.IndexOfAny(new[] { '"', '\r', '\n' }) >= 0;
        if (!hasEscapeChars) return sql;

        return sql.Replace("\"", "\\\"").Replace("\r\n", "\\r\\n").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    /// <summary>
    /// Generate standard file header
    /// </summary>
    public static void GenerateFileHeader(IndentedStringBuilder sb, string namespaceName)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
    }

    /// <summary>
    /// Generate command creation and parameter binding
    /// </summary>
    public static void GenerateCommandSetup(IndentedStringBuilder sb, string sql, IMethodSymbol method, string connectionName)
    {
        sb.AppendLine($"__cmd__ = {connectionName}.CreateCommand();");

        // Properly escape SQL string for C# code generation
        var escapedSql = sql.Replace("\"", "\"\"").Replace("\r\n", "\\r\\n").Replace("\n", "\\n").Replace("\t", "\\t");
        sb.AppendLine($"__cmd__.CommandText = @\"{escapedSql}\";");
        sb.AppendLine();

        // Generate parameter binding
        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç®€åŒ–å‚æ•°åˆ›å»ºï¼Œå‡å°‘ä¸´æ—¶å˜é‡å’Œèµ‹å€¼æ“ä½œ
        foreach (var param in method.Parameters.Where(p => p.Type.Name != "CancellationToken"))
        {
            var paramName = $"@{param.Name}";
            var isNullable = param.Type.IsReferenceType || param.Type.NullableAnnotation == Microsoft.CodeAnalysis.NullableAnnotation.Annotated;

            // ç›´æ¥åˆ›å»ºå¹¶æ·»åŠ å‚æ•°ï¼Œå‡å°‘ä¸­é—´æ­¥éª¤
            sb.Append("{ var __p__ = __cmd__.CreateParameter(); ");
            sb.Append($"__p__.ParameterName = \"{paramName}\"; ");
            
            if (isNullable)
            {
                sb.Append($"__p__.Value = {param.Name} ?? (object)global::System.DBNull.Value; ");
            }
            else
            {
                sb.Append($"__p__.Value = {param.Name}; ");
            }
            
            sb.AppendLine("__cmd__.Parameters.Add(__p__); }");
        }
    }

    /// <summary>
    /// Get DbType
    /// </summary>
    public static string GetDbType(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_String => "global::System.Data.DbType.String",
            SpecialType.System_Int32 => "global::System.Data.DbType.Int32",
            SpecialType.System_Int64 => "global::System.Data.DbType.Int64",
            SpecialType.System_Boolean => "global::System.Data.DbType.Boolean",
            SpecialType.System_DateTime => "global::System.Data.DbType.DateTime",
            SpecialType.System_Decimal => "global::System.Data.DbType.Decimal",
            SpecialType.System_Double => "global::System.Data.DbType.Double",
            _ => "global::System.Data.DbType.Object"
        };
    }

    /// <summary>
    /// Generate entity property mapping with optional ordinal access optimization
    /// </summary>
    public static void GenerateEntityMapping(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName, List<string>? columnOrder = null, bool useOrdinalIndex = true)
    {
        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šé»˜è®¤ä½¿ç”¨ç¡¬ç¼–ç ç´¢å¼•è®¿é—®ï¼ˆæè‡´æ€§èƒ½ï¼‰
        // å¦‚æœåˆ—é¡ºåºä¸åŒ¹é…ï¼Œæºåˆ†æå™¨ä¼šå‘å‡ºç¼–è¯‘è­¦å‘Š
        if (columnOrder != null && columnOrder.Count > 0)
        {
            sb.AppendLine($"// ğŸš€ ä½¿ç”¨ç¡¬ç¼–ç ç´¢å¼•è®¿é—®ï¼ˆæè‡´æ€§èƒ½ï¼‰- {columnOrder.Count}åˆ—: [{string.Join(", ", columnOrder)}]");
            sb.AppendLine($"// âš ï¸ å¦‚æœC#å±æ€§é¡ºåºä¸SQLåˆ—é¡ºåºä¸ä¸€è‡´ï¼Œæºåˆ†æå™¨ä¼šå‘å‡ºè­¦å‘Š");
            GenerateEntityMappingWithHardcodedOrdinals(sb, entityType, variableName, columnOrder);
            return;
        }

        // å‘åå…¼å®¹ï¼šæ²¡æœ‰åˆ—é¡ºåºä¿¡æ¯æ—¶ï¼Œä½¿ç”¨GetOrdinalæŸ¥æ‰¾
        sb.AppendLine($"// âš ï¸ ä½¿ç”¨GetOrdinalæŸ¥æ‰¾ï¼ˆå…¼å®¹ç‰ˆæœ¬ï¼‰- columnOrderä¸º{(columnOrder == null ? "null" : "empty")}");
        sb.AppendLine($"// æ€§èƒ½è­¦å‘Šï¼šæœªä½¿ç”¨åºå·è®¿é—®ä¼˜åŒ–ï¼ŒæŸ¥è¯¢æ€§èƒ½å¯èƒ½é™ä½20%");
        GenerateEntityMappingWithGetOrdinal(sb, entityType, variableName);
    }

    /// <summary>
    /// Generate entity property mapping using hardcoded ordinal index (extreme performance mode)
    /// </summary>
    private static void GenerateEntityMappingWithHardcodedOrdinals(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName, List<string> columnOrder)
    {
        // Remove nullable annotation
        var entityTypeName = entityType.GetCachedDisplayString();
        if (entityTypeName.EndsWith("?"))
        {
            entityTypeName = entityTypeName.TrimEnd('?');
        }

        // è·å–æ‰€æœ‰å¯æ˜ å°„çš„å±æ€§
        var properties = entityType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.CanBeReferencedByName && p.SetMethod != null)
            .ToArray();

        if (properties.Length == 0)
        {
            if (variableName == "__result__")
            {
                sb.AppendLine($"__result__ = new {entityTypeName}();");
            }
            else
            {
                sb.AppendLine($"var {variableName} = new {entityTypeName}();");
            }
            return;
        }

        // ğŸš€ æè‡´ä¼˜åŒ–ï¼šç›´æ¥ä½¿ç”¨ç¡¬ç¼–ç ç´¢å¼•ï¼ˆ0, 1, 2...ï¼‰è®¿é—®åˆ—
        // åˆ›å»ºåˆ—ååˆ°ç¡¬ç¼–ç ç´¢å¼•çš„æ˜ å°„
        var columnToOrdinal = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        for (int i = 0; i < columnOrder.Count; i++)
        {
            columnToOrdinal[columnOrder[i]] = i;
        }

        // ä½¿ç”¨å¯¹è±¡åˆå§‹åŒ–å™¨è¯­æ³•ï¼ˆæ”¯æŒinit-onlyå±æ€§ï¼‰
        if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}");
        }

        sb.AppendLine("{");
        sb.PushIndent();

        // æ ¹æ®å±æ€§æ˜ å°„åˆ°å¯¹åº”çš„ç¡¬ç¼–ç ç´¢å¼•
        bool first = true;
        foreach (var prop in properties)
        {
            var columnName = ConvertToSnakeCase(prop.Name);

            // æŸ¥æ‰¾è¯¥å±æ€§å¯¹åº”çš„ç¡¬ç¼–ç ç´¢å¼•
            if (!columnToOrdinal.TryGetValue(columnName, out int ordinalIndex))
            {
                // åˆ—ä¸å­˜åœ¨äºSQLä¸­ï¼Œè·³è¿‡æˆ–ä½¿ç”¨é»˜è®¤å€¼
                continue;
            }

            var readMethod = prop.Type.UnwrapNullableType().GetDataReaderMethod();
            var isNullable = prop.Type.CanBeReferencedByName && prop.Type.NullableAnnotation == Microsoft.CodeAnalysis.NullableAnnotation.Annotated;
            var defaultValue = isNullable ? "null" : GetDefaultValue(prop.Type);

            // ğŸš€ æè‡´æ€§èƒ½ï¼šç›´æ¥ä½¿ç”¨ç¡¬ç¼–ç ç´¢å¼•ï¼ˆä¾‹å¦‚ï¼šreader.GetInt32(0)ï¼‰
            var valueExpression = string.IsNullOrEmpty(readMethod)
                ? $"({prop.Type.GetCachedDisplayString()})reader[{ordinalIndex}]"
                : $"reader.{readMethod}({ordinalIndex})";

            if (!first) sb.Append(",");
            sb.AppendLine($"{prop.Name} = reader.IsDBNull({ordinalIndex}) ? {defaultValue} : {valueExpression}");
            first = false;
        }

        sb.PopIndent();
        sb.AppendLine("};");
    }

    /// <summary>
    /// Generate entity property mapping using GetOrdinal (backward compatible)
    /// </summary>
    private static void GenerateEntityMappingWithGetOrdinal(IndentedStringBuilder sb, INamedTypeSymbol entityType, string variableName)
    {
        // Remove nullable annotation - ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬æå‡æ€§èƒ½
        var entityTypeName = entityType.GetCachedDisplayString();
        if (entityTypeName.EndsWith("?"))
        {
            entityTypeName = entityTypeName.TrimEnd('?');
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…ä¸å¿…è¦çš„ToList()è°ƒç”¨ï¼Œç›´æ¥éå†
        // æ”¯æŒ set å’Œ init å±æ€§
        var properties = entityType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.CanBeReferencedByName && p.SetMethod != null)
            .ToArray();

        if (properties.Length == 0)
        {
            // No properties to map, just create empty object
            if (variableName == "__result__")
            {
                sb.AppendLine($"__result__ = new {entityTypeName}();");
            }
            else
            {
                sb.AppendLine($"var {variableName} = new {entityTypeName}();");
            }
            return;
        }

        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜GetOrdinalç»“æœï¼Œé¿å…é‡å¤æŸ¥æ‰¾ï¼ˆæ¯ä¸ªå­—æ®µåªè°ƒç”¨ä¸€æ¬¡GetOrdinalï¼‰
        sb.AppendLine("// ç¼“å­˜åˆ—åºå·ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼šé¿å…é‡å¤GetOrdinalè°ƒç”¨ï¼‰");
        for (int i = 0; i < properties.Length; i++)
        {
            var prop = properties[i];
            var columnName = ConvertToSnakeCase(prop.Name);
            sb.AppendLine($"var __ord_{prop.Name}__ = reader.GetOrdinal(\"{columnName}\");");
        }
        sb.AppendLine();

        // Use object initializer syntax to support init-only properties
        if (variableName == "__result__")
        {
            sb.AppendLine($"__result__ = new {entityTypeName}");
        }
        else
        {
            sb.AppendLine($"var {variableName} = new {entityTypeName}");
        }

        sb.AppendLine("{");
        sb.PushIndent();

        for (int i = 0; i < properties.Length; i++)
        {
            var prop = properties[i];
            var readMethod = prop.Type.UnwrapNullableType().GetDataReaderMethod();
            var isNullable = prop.Type.CanBeReferencedByName && prop.Type.NullableAnnotation == Microsoft.CodeAnalysis.NullableAnnotation.Annotated;
            var defaultValue = isNullable ? "null" : GetDefaultValue(prop.Type);

            // ä½¿ç”¨ç¼“å­˜çš„åºå·å˜é‡
            var ordinalVar = $"__ord_{prop.Name}__";
            var valueExpression = string.IsNullOrEmpty(readMethod)
                ? $"({prop.Type.GetCachedDisplayString()})reader[{ordinalVar}]"  // ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬
                : $"reader.{readMethod}({ordinalVar})";

            var comma = i < properties.Length - 1 ? "," : "";
            sb.AppendLine($"{prop.Name} = reader.IsDBNull({ordinalVar}) ? {defaultValue} : {valueExpression}{comma}");
        }

        sb.PopIndent();
        sb.AppendLine("};");
    }

    /// <summary>
    /// Get default value for a type
    /// </summary>
    private static string GetDefaultValue(ITypeSymbol type)
    {
        if (type.NullableAnnotation == Microsoft.CodeAnalysis.NullableAnnotation.Annotated)
            return "null";

        return type.SpecialType switch
        {
            SpecialType.System_String => "string.Empty",
            SpecialType.System_Boolean => "false",
            SpecialType.System_Int32 => "0",
            SpecialType.System_Int64 => "0L",
            SpecialType.System_Decimal => "0m",
            SpecialType.System_Double => "0.0",
            SpecialType.System_Single => "0f",
            _ => $"default({type.GetCachedDisplayString()})"  // ä½¿ç”¨ç¼“å­˜ç‰ˆæœ¬
        };
    }

    /// <summary>Convert C# property names to snake_case database column names</summary>
    public static string ConvertToSnakeCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        if (name.Contains("_")) return name.ToLowerInvariant();

        // æ€§èƒ½ä¼˜åŒ–ï¼šé¢„è®¡ç®—å®¹é‡æ›´ç²¾ç¡®ï¼Œé¿å…é‡åˆ†é…
        var result = new System.Text.StringBuilder(name.Length + (name.Length >> 2));
        for (int i = 0; i < name.Length; i++)
        {
            char current = name[i];
            if (char.IsUpper(current))
            {
                if (i > 0 && !char.IsUpper(name[i - 1])) result.Append('_');
                result.Append(char.ToLowerInvariant(current));
            }
            else
            {
                result.Append(current);
            }
        }
        return result.ToString();
    }
}
