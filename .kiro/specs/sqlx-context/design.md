# Design Document

## Overview

This document describes the design of SqlxContext, a lightweight context manager for Sqlx that simplifies multi-repository management and unified transaction handling.


## Architecture

SqlxContext follows a lightweight manager pattern that coordinates multiple repositories without introducing heavy abstractions like change tracking or lazy loading. The design maintains Sqlx's core principles:

- **Zero Reflection**: All repository instantiation is done through compile-time generated code
- **AOT Compatible**: Fully supports Native AOT compilation
- **Minimal Overhead**: Context is just a thin wrapper around repository instances
- **Optional**: Existing code continues to work without any changes

### Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                        SqlxContext                           │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  - DbConnection _connection                            │ │
│  │  - IServiceProvider? _serviceProvider                  │ │
│  │  - DbTransaction? _transaction                         │ │
│  │  - bool _ownsConnection                                │ │
│  │  - bool _ownsTransaction                               │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  + BeginTransactionAsync()                             │ │
│  │  + BeginTransaction()                                  │ │
│  │  + UseTransaction(DbTransaction?)                      │ │
│  │  # ResolveRepository<TRepository>()                    │ │
│  │  + Dispose()                                           │ │
│  │  + DisposeAsync()                                      │ │
│  │  # PropagateTransactionToRepositories() (virtual)      │ │
│  │  # ClearRepositoryTransactions() (virtual)             │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ resolves via IServiceProvider
                            ▼
        ┌──────────────────────────────────────┐
        │         Repository Instances          │
        │  ┌────────────────────────────────┐  │
        │  │  UserRepository                │  │
        │  │  - DbConnection Connection     │  │
        │  │  - DbTransaction? Transaction  │  │
        │  └────────────────────────────────┘  │
        │  ┌────────────────────────────────┐  │
        │  │  OrderRepository               │  │
        │  │  - DbConnection Connection     │  │
        │  │  - DbTransaction? Transaction  │  │
        │  └────────────────────────────────┘  │
        └──────────────────────────────────────┘
```

## Components and Interfaces

### 1. SqlxContext (Base Class)

The core context class that manages repositories and transactions. Repository properties are generated by the source generator in derived classes.

```csharp
namespace Sqlx;

public abstract class SqlxContext : IDisposable, IAsyncDisposable
{
    // Fields
    private readonly DbConnection _connection;
    private readonly bool _ownsConnection;
    private DbTransaction? _transaction;
    private bool _ownsTransaction;  // Track if we created the transaction
    private bool _disposed;

    // Constructor
    protected SqlxContext(DbConnection connection, bool ownsConnection = true)
    {
        _connection = connection ?? throw new ArgumentNullException(nameof(connection));
        _ownsConnection = ownsConnection;
    }

    // Properties
    public DbConnection Connection => _connection;
    public DbTransaction? Transaction => _transaction;
    public bool HasActiveTransaction => _transaction != null;

    // Transaction Management
    public async Task<DbTransaction> BeginTransactionAsync(
        IsolationLevel isolationLevel = IsolationLevel.ReadCommitted,
        CancellationToken cancellationToken = default)
    {
        if (_transaction != null)
        {
            throw new InvalidOperationException("A transaction is already active.");
        }

        _transaction = await _connection.BeginTransactionAsync(isolationLevel, cancellationToken);
        _ownsTransaction = true;
        PropagateTransactionToRepositories();
        return _transaction;
    }

    public DbTransaction BeginTransaction(IsolationLevel isolationLevel = IsolationLevel.ReadCommitted)
    {
        if (_transaction != null)
        {
            throw new InvalidOperationException("A transaction is already active.");
        }

        _transaction = _connection.BeginTransaction(isolationLevel);
        _ownsTransaction = true;
        PropagateTransactionToRepositories();
        return _transaction;
    }

    // Set external transaction
    public void UseTransaction(DbTransaction? transaction)
    {
        if (_transaction != null && _ownsTransaction)
        {
            throw new InvalidOperationException("Cannot set external transaction when an owned transaction is active. Commit or rollback the current transaction first.");
        }

        _transaction = transaction;
        _ownsTransaction = false;
        PropagateTransactionToRepositories();
    }

    // Virtual methods for derived classes to propagate/clear transactions
    // Overridden in generated code to set/clear transaction on all repository properties
    protected virtual void PropagateTransactionToRepositories()
    {
        // Override in generated code to set transaction on all repository properties
    }

    protected virtual void ClearRepositoryTransactions()
    {
        // Override in generated code to clear transaction on all repository properties
    }

    // Disposal
    public void Dispose()
    {
        if (_disposed) return;

        if (_transaction != null && _ownsTransaction)
        {
            _transaction.Rollback();
            _transaction.Dispose();
        }
        
        _transaction = null;
        ClearRepositoryTransactions();

        if (_ownsConnection)
        {
            _connection.Dispose();
        }

        _disposed = true;
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;

        if (_transaction != null && _ownsTransaction)
        {
            await _transaction.RollbackAsync();
            await _transaction.DisposeAsync();
        }
        
        _transaction = null;
        ClearRepositoryTransactions();

        if (_ownsConnection)
        {
            await _connection.DisposeAsync();
        }

        _disposed = true;
    }
}
```

### 2. SqlxContextAttribute

Attribute to mark context classes for source generation.

```csharp
namespace Sqlx.Annotations;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
public sealed class SqlxContextAttribute : Attribute
{
    public SqlxContextAttribute() { }
}
```

### 3. IncludeRepositoryAttribute

Attribute to explicitly specify which repository implementations should be included in a context.

```csharp
namespace Sqlx.Annotations;

/// <summary>
/// Specifies a repository implementation to include in a SqlxContext.
/// The generator will extract the entity type from the repository's interface.
/// </summary>
/// <example>
/// <code>
/// [SqlxContext]
/// [IncludeRepository(typeof(UserRepository))]
/// [IncludeRepository(typeof(OrderRepository))]
/// public partial class AppDbContext : SqlxContext { }
/// </code>
/// </example>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
public sealed class IncludeRepositoryAttribute : Attribute
{
    /// <summary>
    /// Gets the repository implementation type to include in the context.
    /// </summary>
    public Type RepositoryType { get; }
    
    /// <summary>
    /// Initializes a new instance of the <see cref="IncludeRepositoryAttribute"/> class.
    /// </summary>
    /// <param name="repositoryType">The repository implementation type (e.g., typeof(UserRepository)).</param>
    /// <exception cref="ArgumentNullException">Thrown when repositoryType is null.</exception>
    public IncludeRepositoryAttribute(Type repositoryType)
    {
        RepositoryType = repositoryType ?? throw new ArgumentNullException(nameof(repositoryType));
    }
}
```

### 2. Source-Generated Context (Example)

The source generator creates a partial class with direct repository properties using lazy initialization. No wrapper classes, no Set() methods, no dictionary caching.

```csharp
// User code - Repository definitions (standard RepositoryFor pattern)
[RepositoryFor(typeof(IUserRepository))]
[TableName("users")]
public partial class UserRepository { }

[RepositoryFor(typeof(IOrderRepository))]
[TableName("orders")]
public partial class OrderRepository { }

// User code - Context definition with repository specifications
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
[IncludeRepository(typeof(OrderRepository))]
public partial class AppDbContext : SqlxContext
{
    // Constructor will be auto-generated by source generator
}

// Generated code - Direct repository properties with lazy service provider resolution
public partial class AppDbContext
{
    // Backing fields for lazy-resolved repositories
    private UserRepository? _users;
    private OrderRepository? _orders;
    private readonly System.IServiceProvider _serviceProvider;
    
    // DI-friendly constructor (generated if not provided by user)
    public AppDbContext(DbConnection connection, IServiceProvider serviceProvider) 
        : base(connection, ownsConnection: false)
    {
        _serviceProvider = serviceProvider;
    }
    
    // Direct repository properties (lazy resolution from service provider)
    public UserRepository Users
    {
        get
        {
            if (_users == null)
            {
                _users = _serviceProvider.GetRequiredService<UserRepository>();
                // Zero reflection - direct property access in generated code
                ((ISqlxRepository)_users).Connection = Connection;
                _users.Transaction = Transaction;
            }
            return _users;
        }
    }
    
    public OrderRepository Orders
    {
        get
        {
            if (_orders == null)
            {
                _orders = _serviceProvider.GetRequiredService<OrderRepository>();
                // Zero reflection - direct property access in generated code
                ((ISqlxRepository)_orders).Connection = Connection;
                _orders.Transaction = Transaction;
            }
            return _orders;
        }
    }
    
    // Override to propagate transaction to all initialized repositories
    protected override void PropagateTransactionToRepositories()
    {
        if (_users != null) _users.Transaction = Transaction;
        if (_orders != null) _orders.Transaction = Transaction;
    }
    
    // Override to clear transaction from all initialized repositories
    protected override void ClearRepositoryTransactions()
    {
        if (_users != null) _users.Transaction = null;
        if (_orders != null) _orders.Transaction = null;
    }
}
```

### 5. DI Extension Methods

Extension methods for ASP.NET Core dependency injection. These are simple helper methods and do not require source generator support.

```csharp
namespace Microsoft.Extensions.DependencyInjection;

public static class SqlxContextServiceCollectionExtensions
{
    public static IServiceCollection AddSqlxContext<TContext>(
        this IServiceCollection services,
        ServiceLifetime lifetime = ServiceLifetime.Scoped)
        where TContext : SqlxContext
    {
        services.Add(new ServiceDescriptor(typeof(TContext), typeof(TContext), lifetime));
        return services;
    }
    
    public static IServiceCollection AddSqlxContext<TContext>(
        this IServiceCollection services,
        Func<IServiceProvider, TContext> implementationFactory,
        ServiceLifetime lifetime = ServiceLifetime.Scoped)
        where TContext : SqlxContext
    {
        services.Add(new ServiceDescriptor(typeof(TContext), implementationFactory, lifetime));
        return services;
    }
}
```

## Data Models

### Repository Storage

The context uses direct backing fields for each repository, generated at compile time:

```csharp
private UserRepository? _users;
private OrderRepository? _orders;
```

Each repository is lazily initialized on first access through its property getter. No dictionary caching is used.

### Connection Ownership

The context tracks whether it owns the connection:

```csharp
private readonly bool _ownsConnection;
```

- `true`: Context will dispose the connection when disposed
- `false`: Context will not dispose the connection (external ownership)

## Correctness Properties

A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.

### Property 1: Repository Instance Consistency

*For any* repository property, accessing it multiple times should return the same repository instance (injected via DI).

**Validates: Requirements 2.2, 6.4**

### Property 2: Transaction Propagation

*For any* set of repositories managed by a context, when a transaction is started, all initialized repositories should have their Transaction property set to the active transaction.

**Validates: Requirements 2.5, 3.3**

### Property 3: Transaction Cleanup

*For any* context with an active transaction, when the transaction is committed or rolled back, all initialized repositories should have their Transaction property cleared.

**Validates: Requirements 3.4**

### Property 4: Connection Disposal

*For any* context that owns its connection, calling Dispose should dispose the connection. For any context with an external connection, calling Dispose should not dispose the connection.

**Validates: Requirements 4.3, 4.6**

### Property 5: Transaction Rollback on Dispose

*For any* context with an active transaction that it owns, calling Dispose should rollback the transaction before disposing. For any context with an external transaction, calling Dispose should NOT rollback or dispose the transaction.

**Validates: Requirements 4.4, 3.9**

### Property 6: Idempotent Disposal

*For any* context, calling Dispose multiple times should not throw an exception.

**Validates: Requirements 8.3**

### Property 7: Thread-Safe Repository Access

*For any* context after initialization, multiple threads reading repository properties concurrently should not cause exceptions or data corruption.

**Validates: Requirements 1.4**

### Property 8: Transaction State Property

*For any* context, the `HasActiveTransaction` property should accurately reflect whether a transaction is currently active.

**Validates: Requirements 8.5**

### Property 9: External Transaction Tracking

*For any* context using an external transaction (via UseTransaction), the context should not rollback or dispose the transaction when disposed.

**Validates: Requirements 3.8, 3.9**

## Error Handling

### Transaction Already Active

When `BeginTransaction()` is called while a transaction is already active:

```csharp
throw new InvalidOperationException("A transaction is already active.");
```

### External Transaction Conflict

When `UseTransaction()` is called while an owned transaction is active:

```csharp
throw new InvalidOperationException("Cannot set external transaction when an owned transaction is active. Commit or rollback the current transaction first.");
```

### Null Connection

When a null connection is passed to the constructor:

```csharp
throw new ArgumentNullException(nameof(connection));
```

## Testing Strategy

### Unit Tests

Unit tests verify specific examples and edge cases:

- Context creation with valid and null connections
- Context creation with injected repositories
- Repository property access
- Transaction lifecycle (begin, commit, rollback)
- External transaction usage with UseTransaction()
- Disposal with owned and external connections
- Disposal with owned and external transactions
- Error cases (double transaction, null connection, external transaction conflict)

### Property-Based Tests

Property tests verify universal properties across all inputs:

- **Property 1**: Repository instance consistency (100+ iterations with random repository accesses)
- **Property 2**: Transaction propagation (100+ iterations with random repository collections)
- **Property 3**: Transaction cleanup (100+ iterations with random transaction outcomes)
- **Property 4**: Connection disposal (100+ iterations with random ownership flags)
- **Property 5**: Transaction rollback on dispose (100+ iterations with owned/external transactions)
- **Property 6**: Idempotent disposal (100+ iterations with random disposal counts)
- **Property 7**: Thread-safe repository access (100+ iterations with concurrent threads)
- **Property 8**: Transaction state property (100+ iterations with random transaction states)
- **Property 9**: External transaction tracking (100+ iterations with external transactions)

Each property test will:
- Run minimum 100 iterations
- Use FsCheck or similar PBT library for C#
- Tag with format: **Feature: sqlx-context, Property N: [property text]**
- Reference the design document property number

### Integration Tests

Integration tests verify the context works with real databases and DI containers:

- SQLite in-memory database tests
- ASP.NET Core DI registration tests
- Multi-repository transaction tests
- Connection pooling tests

## Performance Considerations

### Repository Instance Caching

Repositories use lazy initialization with backing fields. Each repository is instantiated only once on first access. No dictionary lookups or additional overhead.

### Transaction Propagation

Transaction propagation uses virtual methods (`PropagateTransactionToRepositories` and `ClearRepositoryTransactions`) that are overridden in generated code. This approach:
- Uses zero reflection - all property assignments are direct in generated code
- Uses direct property access in generated override methods for transaction changes
- Is fully AOT compatible (no reflection at all)
- Has minimal overhead (simple null checks and property assignments)
- Maintains type safety
- All code is generated at compile time

**Transaction Synchronization Flow:**
1. **On Repository Resolution**: When a repository is first accessed, generated code calls `_serviceProvider.GetRequiredService<T>()`, sets Connection via ISqlxRepository interface, then sets Transaction
2. **On Transaction Begin**: `BeginTransactionAsync()`/`BeginTransaction()` calls `PropagateTransactionToRepositories()` to update all initialized repositories
3. **On External Transaction**: `UseTransaction()` calls `PropagateTransactionToRepositories()` to update all initialized repositories
4. **On Transaction End**: Commit/rollback triggers `ClearRepositoryTransactions()` to clear transaction from all initialized repositories
5. **On Dispose**: If transaction is owned, it's rolled back and `ClearRepositoryTransactions()` is called

This ensures that all repositories always have the current transaction state from the context.

### Memory Overhead

The context adds minimal memory overhead:
- One nullable backing field per repository (e.g., `UserRepository? _users`)
- One `DbConnection` reference
- One `DbTransaction?` reference
- One `bool` for ownership tracking

Compared to manual repository management, the overhead is negligible (one nullable field per repository, ~8 bytes each on 64-bit systems).

## Source Generator Design

### Generator Input

The generator scans for:

1. **Context Classes**: Classes marked with `[SqlxContext]` attribute
2. **Repository Specifications**: `[IncludeRepository(typeof(RepositoryType))]` attributes on the context class

```csharp
// Context definition with repository specifications
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
[IncludeRepository(typeof(OrderRepository))]
public partial class AppDbContext : SqlxContext
{
    public AppDbContext(DbConnection connection) : base(connection) { }
}

// Repository definitions (standard pattern)
[RepositoryFor(typeof(IUserRepository))]
[TableName("users")]
public partial class UserRepository { }

[RepositoryFor(typeof(IOrderRepository))]
[TableName("orders")]
public partial class OrderRepository { }
```

### Generator Output

The generator produces:

1. **Service Provider Field**: Private readonly field to store IServiceProvider
2. **Constructor**: DI-friendly constructor accepting DbConnection and IServiceProvider (if not provided by user)
3. **Backing Fields**: Private nullable fields for lazy-resolved repositories
4. **Repository Properties**: Public properties with lazy resolution from service provider
5. **Transaction Propagation**: Override of `PropagateTransactionToRepositories()` method
6. **Transaction Cleanup**: Override of `ClearRepositoryTransactions()` method
7. **Type Safety**: Compile-time errors if repository types don't match

```csharp
public partial class AppDbContext
{
    // Backing fields for lazy-resolved repositories
    private UserRepository? _users;
    private OrderRepository? _orders;
    private readonly System.IServiceProvider _serviceProvider;
    
    // DI-friendly constructor (generated if not provided by user)
    public AppDbContext(DbConnection connection, IServiceProvider serviceProvider) 
        : base(connection, ownsConnection: false)
    {
        _serviceProvider = serviceProvider;
    }
    
    // Direct repository properties (lazy resolution from service provider)
    public UserRepository Users
    {
        get
        {
            if (_users == null)
            {
                _users = _serviceProvider.GetRequiredService<UserRepository>();
                // Zero reflection - direct property access in generated code
                ((ISqlxRepository)_users).Connection = Connection;
                _users.Transaction = Transaction;
            }
            return _users;
        }
    }
    
    public OrderRepository Orders
    {
        get
        {
            if (_orders == null)
            {
                _orders = _serviceProvider.GetRequiredService<OrderRepository>();
                // Zero reflection - direct property access in generated code
                ((ISqlxRepository)_orders).Connection = Connection;
                _orders.Transaction = Transaction;
            }
            return _orders;
        }
    }
    
    // Override to propagate transaction to all initialized repositories
    protected override void PropagateTransactionToRepositories()
    {
        if (_users != null) _users.Transaction = Transaction;
        if (_orders != null) _orders.Transaction = Transaction;
    }
    
    // Override to clear transaction from all initialized repositories
    protected override void ClearRepositoryTransactions()
    {
        if (_users != null) _users.Transaction = null;
        if (_orders != null) _orders.Transaction = null;
    }
}
```

### Repository Discovery Algorithm

The generator discovers repositories using explicit specifications on the context class:

1. **Scan for Context Classes**: Find all classes marked with `[SqlxContext]` attribute
2. **Read Repository Specifications**: For each context, read all `[IncludeRepository(typeof(RepositoryType))]` attributes
3. **Extract Type Information**: For each specified repository:
   - Get the repository implementation type (e.g., `UserRepository`)
   - Find the `[RepositoryFor]` attribute to get the interface type
   - Extract entity type and key type from the interface's `ICrudRepository<TEntity, TKey>` inheritance
   - Determine property name from entity type (e.g., `User` → `Users`)
4. **Generate Code**: For each context, generate:
   - Constructor accepting DbConnection and all repositories (if not already provided by user)
   - Constructor body that assigns injected repositories to backing fields
   - Constructor body that sets Connection and Transaction on each repository
   - Private readonly backing field for each repository (e.g., `private readonly UserRepository _users;`)
   - Public property returning the repository (e.g., `public UserRepository Users => _users;`)
   - Override of `PropagateTransactionToRepositories()` with transaction assignment
   - Override of `ClearRepositoryTransactions()` with transaction clearing
5. **Dialect Handling**: Use the `SqlDefine` dialect from the context class

**Key Design Decision**: Repository implementations are explicitly specified on the context using `[IncludeRepository]` attributes. This provides:
- **Explicit Control**: Developers explicitly choose which repositories belong to which contexts
- **Centralized Configuration**: All repository specifications visible in one place (the context class)
- **Simple Specification**: Only need to specify repository implementation type, entity type is extracted automatically
- **Multi-Context Support**: Different contexts can include different sets of repositories
- **Clear Ownership**: It's immediately obvious which context manages which repositories
- **Direct Access**: No wrapper classes or Set() methods, just direct repository properties

## Usage Examples

### Complete Example with Explicit Repository Specification

```csharp
// 1. Define entities
public class User
{
    public long Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
}

public class Order
{
    public long Id { get; set; }
    public long UserId { get; set; }
    public decimal Total { get; set; }
}

// 2. Define repository interfaces
public interface IUserRepository : ICrudRepository<User, long> { }
public interface IOrderRepository : ICrudRepository<Order, long> { }

// 3. Define repository implementations
[RepositoryFor(typeof(IUserRepository))]
[TableName("users")]
public partial class UserRepository { }

[RepositoryFor(typeof(IOrderRepository))]
[TableName("orders")]
public partial class OrderRepository { }

// 4. Define context with repository specifications
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
[IncludeRepository(typeof(OrderRepository))]
public partial class AppDbContext : SqlxContext
{
    // Constructor will be auto-generated by source generator
}

// 5. Register with DI
services.AddScoped<DbConnection>(sp => new SqliteConnection("Data Source=app.db"));
services.AddScoped<UserRepository>();
services.AddScoped<OrderRepository>();
services.AddScoped<AppDbContext>();

// 6. Use the context (injected via DI)
public class UserService
{
    private readonly AppDbContext _context;
    
    public UserService(AppDbContext context)
    {
        _context = context;
    }
    
    public async Task ProcessUserOrders(long userId)
    {
        // Access repositories directly - properties automatically generated with lazy resolution!
        var user = await _context.Users.GetByIdAsync(userId);
        var orders = await _context.Orders.GetWhereAsync(o => o.UserId == user.Id);
    }
}
```

### Basic Usage

```csharp
// Context is injected via DI with IServiceProvider
public class UserService
{
    private readonly AppDbContext _context;
    
    public UserService(AppDbContext context)
    {
        _context = context;
    }
    
    public async Task ProcessUser(long userId)
    {
        // Access repositories directly through properties (lazy resolution)
        var user = await _context.Users.GetByIdAsync(userId);
        var userOrders = await _context.Orders.GetWhereAsync(o => o.UserId == userId);
    }
}
```

### Transaction Management

```csharp
public class OrderService
{
    private readonly AppDbContext _context;
    
    public OrderService(AppDbContext context)
    {
        _context = context;
    }
    
    public async Task CreateUserWithOrder(User newUser, Order newOrder)
    {
        // Begin transaction
        await using var transaction = await _context.BeginTransactionAsync();

        try
        {
            // All repository operations participate in the transaction
            var userId = await _context.Users.InsertAndGetIdAsync(newUser);
            newOrder.UserId = userId;
            await _context.Orders.InsertAsync(newOrder);
            
            // Commit transaction
            await transaction.CommitAsync();
        }
        catch
        {
            // Transaction is automatically rolled back on dispose
            throw;
        }
    }
}
```

### Using External Transaction

```csharp
public class TransactionService
{
    private readonly AppDbContext _context;
    private readonly DbConnection _connection;
    
    public TransactionService(AppDbContext context, DbConnection connection)
    {
        _context = context;
        _connection = connection;
    }
    
    public async Task ProcessWithExternalTransaction()
    {
        // Create transaction externally
        await using var transaction = await _connection.BeginTransactionAsync();

        // Use external transaction
        _context.UseTransaction(transaction);

        try
        {
            // All repository operations participate in the external transaction
            var userId = await _context.Users.InsertAndGetIdAsync(newUser);
            await _context.Orders.InsertAsync(new Order { UserId = userId });InsertAsync(new Order { UserId = userId });
            
            // Commit external transaction
            await transaction.CommitAsync();
        }
        catch
        {
            // Rollback external transaction
            await transaction.RollbackAsync();
            throw;
        }
        // Context won't dispose the external transaction
    }
}
```

### DI Registration

```csharp
// Startup.cs or Program.cs
services.AddScoped<DbConnection>(sp => 
    new SqliteConnection("Data Source=app.db"));

// Register repositories
services.AddScoped<UserRepository>();
services.AddScoped<OrderRepository>();

// Register context (IServiceProvider will be injected automatically by DI)
services.AddScoped<AppDbContext>();

// Usage in controller
public class UsersController : ControllerBase
{
    private readonly AppDbContext _context;
    
    public UsersController(AppDbContext context)
    {
        _context = context;
    }
    
    [HttpGet("{id}")]
    public async Task<IActionResult> GetUser(long id)
    {
        var user = await _context.Users.GetByIdAsync(id);
        return user != null ? Ok(user) : NotFound();
    }
}
```

### Manual Registration (Without Source Generator)

For scenarios where source generation is not desired, you can manually create repository properties:

```csharp
public class ManualDbContext : SqlxContext
{
    private readonly UserRepository _users;
    private readonly OrderRepository _orders;
    
    public ManualDbContext(
        DbConnection connection,
        UserRepository users,
        OrderRepository orders) 
        : base(connection)
    {
        _users = users;
        _orders = orders;
        
        _users.Connection = connection;
        _users.Transaction = Transaction;
        _orders.Connection = connection;
        _orders.Transaction = Transaction;
    }
    
    public UserRepository Users => _users;
    public OrderRepository Orders => _orders;
    
    protected override void PropagateTransactionToRepositories()
    {
        _users.Transaction = Transaction;
        _orders.Transaction = Transaction;
    }
    
    protected override void ClearRepositoryTransactions()
    {
        _users.Transaction = null;
        _orders.Transaction = null;
    }
}
```

Note: Manual registration does not use source generation and requires writing the boilerplate code yourself.

### Multiple Contexts Example

Different contexts can include different sets of repositories:

```csharp
// Shared repositories
[RepositoryFor(typeof(IUserRepository))]
[TableName("users")]
public partial class UserRepository { }

[RepositoryFor(typeof(IOrderRepository))]
[TableName("orders")]
public partial class OrderRepository { }

// Context 1: Application context (includes both repositories)
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
[IncludeRepository(typeof(OrderRepository))]
public partial class AppDbContext : SqlxContext
{
    // Constructor auto-generated
}

// Context 2: Admin context (includes only UserRepository)
[SqlxContext]
[SqlDefine(SqlDefineTypes.SQLite)]
[IncludeRepository(typeof(UserRepository))]
public partial class AdminDbContext : SqlxContext
{
    // Constructor auto-generated
}

// Usage with DI
public class AppService
{
    private readonly AppDbContext _appContext;
    
    public AppService(AppDbContext appContext)
    {
        _appContext = appContext;
    }
    
    public async Task ProcessData()
    {
        // AppDbContext has both Users and Orders properties
        var appUser = await _appContext.Users.GetByIdAsync(1);
        var orders = await _appContext.Orders.GetAllAsync();
    }
}

public class AdminService
{
    private readonly AdminDbContext _adminContext;
    
    public AdminService(AdminDbContext adminContext)
    {
        _adminContext = adminContext;
    }
    
    public async Task ProcessAdmin()
    {
        // AdminDbContext has only Users property
        var adminUser = await _adminContext.Users.GetByIdAsync(1);
        // _adminContext.Orders does not exist!
    }
}
```

## Migration Guide

### From Manual Repository Management

Before:
```csharp
await using var connection = new SqliteConnection("Data Source=app.db");
await connection.OpenAsync();

var userRepo = new UserRepository(connection);
var orderRepo = new OrderRepository(connection);

// Transaction management
await using var transaction = await connection.BeginTransactionAsync();
userRepo.Transaction = transaction;
orderRepo.Transaction = transaction;

try
{
    await userRepo.InsertAsync(user);
    await orderRepo.InsertAsync(order);
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

After (SqlxContext with lazy resolution):
```csharp
// Register with DI
services.AddScoped<DbConnection>(sp => new SqliteConnection("Data Source=app.db"));
services.AddScoped<UserRepository>();
services.AddScoped<OrderRepository>();
services.AddScoped<AppDbContext>();

// Use in service
public class OrderService
{
    private readonly AppDbContext _context;
    
    public OrderService(AppDbContext context)
    {
        _context = context;
    }
    
    public async Task CreateOrder(User user, Order order)
    {
        await using var transaction = await _context.BeginTransactionAsync();

        try
        {
            await _context.Users.InsertAsync(user);
            await _context.Orders.InsertAsync(order);
            await transaction.CommitAsync();
        }
        catch
        {
            // Automatic rollback on dispose
            throw;
        }
    }
}
```

Benefits:
- EF Core-style API (`context.Users`, `context.Orders`)
- Automatic transaction propagation
- Automatic rollback on error
- Cleaner code with less boilerplate
- Set instance caching

## Alternatives Considered

### 1. SqlxSet Wrapper with Set() Method (Rejected)

**Rejected**: Using a wrapper class `SqlxSet<TEntity, TKey>` with a `Set<TEntity, TKey>()` method would:
- Add unnecessary abstraction layer
- Require dictionary caching for Set instances
- Add runtime overhead for dictionary lookups
- Make the API less direct and intuitive

The direct property approach provides:
- Zero abstraction overhead
- Direct access to repository instances
- Simpler generated code
- More intuitive API (just access the property)

### 2. Dictionary-Based Repository Caching (Rejected)

**Rejected**: Using `Dictionary<Type, object>` to cache repository instances would:
- Add runtime overhead for dictionary lookups
- Require type casting
- Add memory overhead for the dictionary
- Complicate the implementation

Direct backing fields provide:
- Zero lookup overhead
- Type-safe access
- Minimal memory overhead
- Simpler implementation

### 3. Automatic Discovery of All Repositories (Rejected)

**Rejected**: Automatically discovering all repositories in an assembly would:
- Include repositories the developer doesn't want in the context
- Make it unclear which repositories belong to which context
- Cause issues in large projects with multiple contexts
- Prevent fine-grained control over context composition

The explicit `[IncludeRepository]` attribute provides:
- Clear intent and control
- Support for multiple contexts with different repository sets
- Centralized configuration
- Explicit over implicit

### 4. Entity Type Specification (Rejected)

**Rejected**: Specifying entity types like `[IncludeEntity(typeof(User))]` would:
- Require the generator to search for matching repositories
- Add complexity to the discovery algorithm
- Make it less obvious which repository implementation is being used

The repository-type specification `[IncludeRepository]` provides:
- Direct specification of what you want
- No ambiguity about which repository is used
- Simpler generator logic
- More explicit and clear

### 5. Full DbContext with Change Tracking

**Rejected**: Would add significant complexity and overhead, contradicting Sqlx's lightweight philosophy.

### 6. Interface-Based Transaction Propagation (Rejected)

```csharp
public interface ITransactionAware
{
    DbTransaction? Transaction { get; set; }
}
```

**Rejected**: Requires all repositories to implement the interface, breaking backward compatibility. Virtual methods in the base class provide the same functionality without requiring interface implementation.

### 7. Delegate-Based Repository Factory (Rejected)

```csharp
public SqlxContext(DbConnection connection, Func<Type, DbConnection, object> factory)
```

**Rejected**: Less type-safe and harder to use than source generation.

### 8. Static Context (Singleton) (Rejected)

**Rejected**: Would prevent multiple contexts in the same application and complicate testing.

## Future Enhancements

### 1. Nested Transaction Support

Add support for savepoints to enable nested transactions:

```csharp
await using var outerTx = await context.BeginTransactionAsync();
await using var innerTx = await context.BeginNestedTransactionAsync("savepoint1");
```

### 2. Interceptor Support

Add hooks for logging and monitoring:

```csharp
public class LoggingDbContext : AppDbContext
{
    protected override void OnTransactionBegin(DbTransaction transaction)
    {
        _logger.LogInformation("Transaction started");
    }
}
```

### 3. Repository Lifetime Management

Add support for transient repository instances:

```csharp
[SqlxContext(RepositoryLifetime = RepositoryLifetime.Transient)]
public partial class AppDbContext : SqlxContext { }
```
