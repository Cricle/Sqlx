# LINQ Select 匿名类型支持设计方案

## 最终方案：Interceptor + ModuleInitializer + 泛型静态缓存

### 核心思路

**利用 .NET 的现代特性：**
1. **Interceptor（拦截器）** - 编译时拦截 Select 调用，注入生成的 ResultReader
2. **ModuleInitializer** - 模块初始化时自动注册所有 ResultReader
3. **泛型静态类** - 零开销缓存，无需字典

### 完整实现方案

#### 1. 泛型静态缓存（基础设施）

```csharp
// src/Sqlx/SelectResultReader.cs
namespace Sqlx
{
    /// <summary>
    /// Generic static cache for Select projection result readers.
    /// Each type T has its own static instance (singleton per type).
    /// </summary>
    public static class SelectResultReader<T>
    {
        private static IResultReader<T>? _instance;
        
        public static IResultReader<T>? Instance
        {
            get => _instance;
            set => _instance ??= value;  // Only set once
        }
    }
}
```

#### 2. 源生成器检测 Select 调用

```csharp
// src/Sqlx.Generator/SelectInterceptorGenerator.cs
[Generator(LanguageNames.CSharp)]
public class SelectInterceptorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 检测所有 Select 方法调用
        var selectCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSelectMethodCall(s),
                transform: static (ctx, _) => GetSelectCallInfo(ctx))
            .Where(static m => m is not null);

        var compilationAndCalls = context.CompilationProvider.Combine(selectCalls.Collect());
        context.RegisterSourceOutput(compilationAndCalls, 
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }
    
    private static bool IsSelectMethodCall(SyntaxNode node)
    {
        // 检测：.Select(u => new { ... }) 或 .Select(u => new SomeType { ... })
        return node is InvocationExpressionSyntax invocation &&
               invocation.Expression is MemberAccessExpressionSyntax member &&
               member.Name.Identifier.Text == "Select";
    }
    
    private static SelectCallInfo? GetSelectCallInfo(GeneratorSyntaxContext context)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        // 获取 Select 的返回类型
        var symbolInfo = semanticModel.GetSymbolInfo(invocation);
        if (symbolInfo.Symbol is not IMethodSymbol methodSymbol)
            return null;
            
        // 提取投影类型（TResult）
        var resultType = methodSymbol.ReturnType; // IQueryable<TResult>
        if (resultType is not INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
            return null;
            
        var projectionType = namedType.TypeArguments[0];
        
        // 提取 lambda 表达式中的列信息
        var lambda = GetLambdaExpression(invocation);
        var columns = ExtractColumns(lambda, semanticModel);
        
        return new SelectCallInfo
        {
            ProjectionType = projectionType,
            Columns = columns,
            Location = invocation.GetLocation(),
            FilePath = invocation.SyntaxTree.FilePath,
            LineNumber = invocation.GetLocation().GetLineSpan().StartLinePosition.Line + 1,
            CharacterNumber = invocation.GetLocation().GetLineSpan().StartLinePosition.Character + 1
        };
    }
}
```

#### 3. 生成 ResultReader 实现

```csharp
// Generated/SelectProjections.g.cs
// <auto-generated/>
#nullable enable

namespace Sqlx.Generated
{
    using System;
    using System.Data;
    using System.Runtime.CompilerServices;
    
    // 为每个唯一的投影类型生成 ResultReader
    internal sealed class AnonymousType_User_Id_Name_ResultReader<T> : IResultReader<T>
    {
        public T Read(IDataReader reader)
        {
            // 使用 Unsafe.As 转换（AOT 友好）
            var obj = (object)new
            {
                Id = reader.GetInt32(0),
                Name = reader.GetString(1)
            };
            return Unsafe.As<object, T>(ref obj);
        }
        
        public T Read(IDataReader reader, int[] ordinals)
        {
            var obj = (object)new
            {
                Id = reader.GetInt32(ordinals[0]),
                Name = reader.GetString(ordinals[1])
            };
            return Unsafe.As<object, T>(ref obj);
        }
        
        public int[] GetOrdinals(IDataReader reader)
        {
            return new[]
            {
                reader.GetOrdinal("id"),
                reader.GetOrdinal("name")
            };
        }
    }
    
    // 命名类型的 ResultReader
    internal sealed class UserIdName_ResultReader : IResultReader<UserIdName>
    {
        public UserIdName Read(IDataReader reader)
        {
            return new UserIdName
            {
                Id = reader.GetInt32(0),
                Name = reader.GetString(1)
            };
        }
        
        public UserIdName Read(IDataReader reader, int[] ordinals)
        {
            return new UserIdName
            {
                Id = reader.GetInt32(ordinals[0]),
                Name = reader.GetString(ordinals[1])
            };
        }
        
        public int[] GetOrdinals(IDataReader reader)
        {
            return new[]
            {
                reader.GetOrdinal("id"),
                reader.GetOrdinal("name")
            };
        }
    }
}
```

#### 4. ModuleInitializer 自动注册

```csharp
// Generated/SelectProjections.ModuleInit.g.cs
// <auto-generated/>
#nullable enable

namespace Sqlx.Generated
{
    using System.Runtime.CompilerServices;
    
    internal static class SelectProjectionsInitializer
    {
        [ModuleInitializer]
        internal static void Initialize()
        {
            // 自动注册所有生成的 ResultReader
            // 匿名类型
            SelectResultReader<<>f__AnonymousType0<int, string>>.Instance = 
                new AnonymousType_User_Id_Name_ResultReader<<>f__AnonymousType0<int, string>>();
            
            // 命名类型
            SelectResultReader<UserIdName>.Instance = new UserIdName_ResultReader();
            
            // ... 其他投影类型
        }
    }
}
```

#### 5. Interceptor 拦截 Select 调用

```csharp
// Generated/SelectInterceptors.g.cs
// <auto-generated/>
#nullable enable

using System;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;

namespace Sqlx.Generated
{
    internal static class SelectInterceptors
    {
        // 拦截第一个 Select 调用
        [InterceptsLocation("Program.cs", line: 10, character: 5)]
        public static IQueryable<TResult> Select_Intercepted_1<TSource, TResult>(
            this IQueryable<TSource> source,
            Expression<Func<TSource, TResult>> selector)
        {
            // 获取 SqlxQueryProvider
            if (source is not SqlxQueryable<TSource> sqlxQuery)
                return source.Select(selector);
            
            var provider = sqlxQuery.Provider as SqlxQueryProvider<TSource>;
            if (provider == null)
                return source.Select(selector);
            
            // 从泛型静态缓存获取 ResultReader
            var reader = SelectResultReader<TResult>.Instance;
            
            // 创建新的 Provider 并注入 ResultReader
            var newProvider = new SqlxQueryProvider<TResult>(provider.Dialect)
            {
                Connection = provider.Connection,
                ResultReader = reader  // 自动注入
            };
            
            // 构建新的表达式树
            var selectMethod = typeof(Queryable).GetMethods()
                .First(m => m.Name == "Select" && m.GetParameters().Length == 2);
            var genericMethod = selectMethod.MakeGenericMethod(typeof(TSource), typeof(TResult));
            var newExpression = Expression.Call(
                null,
                genericMethod,
                source.Expression,
                Expression.Quote(selector));
            
            return new SqlxQueryable<TResult>(newProvider, newExpression);
        }
        
        // 拦截第二个 Select 调用
        [InterceptsLocation("UserService.cs", line: 25, character: 9)]
        public static IQueryable<TResult> Select_Intercepted_2<TSource, TResult>(
            this IQueryable<TSource> source,
            Expression<Func<TSource, TResult>> selector)
        {
            // 同上...
        }
        
        // ... 为每个 Select 调用生成一个拦截器
    }
}
```

#### 6. SqlxQueryProvider 使用缓存

```csharp
// src/Sqlx/SqlxQueryProvider.cs
public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
{
    // 优先检查泛型静态缓存
    var reader = SelectResultReader<TElement>.Instance;
    
    if (typeof(TElement) == typeof(T))
    {
        var typedReader = ResultReader as IResultReader<TElement>;
        return new SqlxQueryable<TElement>(
            this as SqlxQueryProvider<TElement> ?? throw new InvalidOperationException(), 
            expression, 
            Connection, 
            typedReader ?? reader);
    }
    
    // 创建新的 Provider
    var newProvider = new SqlxQueryProvider<TElement>(Dialect)
    {
        Connection = Connection,
        ResultReader = reader  // 使用缓存的 Reader
    };
    
    return new SqlxQueryable<TElement>(newProvider, expression);
}
```

### 使用示例

```csharp
// 1. 匿名类型（自动支持）
var result = SqlQuery.ForSqlite<User>()
    .WithConnection(conn)
    .Select(u => new { u.Id, u.Name })  // 被拦截器拦截
    .ToList();
// 源生成器自动：
// - 生成 ResultReader
// - ModuleInitializer 注册
// - Interceptor 注入

// 2. 命名类型
public class UserIdName
{
    public int Id { get; set; }
    public string Name { get; set; }
}

var result = SqlQuery.ForSqlite<User>()
    .WithConnection(conn)
    .Select(u => new UserIdName { Id = u.Id, Name = u.Name })
    .ToList();

// 3. 复杂投影
var result = SqlQuery.ForSqlite<User>()
    .WithConnection(conn)
    .Select(u => new 
    { 
        u.Id, 
        u.Name,
        IsAdult = u.Age >= 18  // SQL 端计算
    })
    .ToList();
```

### 架构优势

1. **完全自动化**
   - 用户无需手动注册
   - 无需标记 `[SqlxProjection]`
   - 直接使用标准 LINQ Select

2. **零运行时开销**
   - ModuleInitializer 在模块加载时执行一次
   - 泛型静态缓存，无字典查找
   - Interceptor 在编译时注入代码

3. **完全 AOT 兼容**
   - 无反射
   - 无动态代码生成
   - 所有代码都是编译时生成

4. **类型安全**
   - 编译时检查
   - 完整的 IntelliSense 支持

5. **无重复代码**
   - 复用 `ExpressionParser` 提取列信息
   - 复用 `ColumnMeta` 结构
   - 复用 `IResultReader<T>` 接口

### 实现步骤

#### 阶段 1：基础设施

1. **添加 `SelectResultReader<T>` 泛型静态类**
   ```csharp
   // src/Sqlx/SelectResultReader.cs
   public static class SelectResultReader<T> { ... }
   ```

2. **修改 `SqlxQueryProvider.CreateQuery`**
   ```csharp
   // 检查 SelectResultReader<TElement>.Instance
   ```

#### 阶段 2：源生成器

1. **创建 `SelectInterceptorGenerator`**
   - 检测所有 Select 调用
   - 提取投影类型和列信息
   - 生成唯一的 ResultReader 类

2. **生成 ResultReader 实现**
   - 匿名类型：使用 `Unsafe.As` 转换
   - 命名类型：直接构造

3. **生成 ModuleInitializer**
   - 注册所有 ResultReader 到泛型静态缓存

4. **生成 Interceptor**
   - 为每个 Select 调用生成拦截器
   - 自动注入 ResultReader

#### 阶段 3：优化

1. **去重**
   - 相同投影类型只生成一个 ResultReader
   - 使用类型签名作为键

2. **错误处理**
   - 不支持的投影类型给出友好提示
   - 列不存在时的诊断信息

3. **性能优化**
   - 缓存列序号
   - 使用 ArrayPool 减少分配

### 性能对比

| 特性 | 手动注册 | ModuleInitializer | 差异 |
|------|---------|------------------|------|
| 初始化时机 | 应用启动 | 模块加载 | 更早 |
| 注册开销 | 手动调用 | 自动执行 | 零开销 |
| 运行时查找 | 直接访问 | 直接访问 | 相同 |
| 代码复杂度 | 需要手动 | 完全自动 | 更简单 |

### 与 EntityProvider 的统一

```csharp
// 之前：partial 类 + 静态构造函数
[SqlxEntity]
partial class User
{
    static User()
    {
        SqlQuery<User>.EntityProvider = UserEntityProvider.Default;
    }
}

// 现在：ModuleInitializer 统一注册
[ModuleInitializer]
internal static void Initialize()
{
    // 注册 EntityProvider
    SqlQuery<User>.EntityProvider = UserEntityProvider.Default;
    SqlQuery<Order>.EntityProvider = OrderEntityProvider.Default;
    
    // 注册 SelectResultReader
    SelectResultReader<UserIdName>.Instance = new UserIdName_ResultReader();
    SelectResultReader<<>f__AnonymousType0<int, string>>.Instance = 
        new AnonymousType_User_Id_Name_ResultReader<<>f__AnonymousType0<int, string>>();
}
```

### 结论

**使用 Interceptor + ModuleInitializer 的优势：**

1. ✅ **用户体验最佳** - 无需任何配置，直接使用标准 LINQ
2. ✅ **性能最优** - 编译时生成，零运行时开销
3. ✅ **完全 AOT 兼容** - 无反射，无动态代码
4. ✅ **统一架构** - EntityProvider 和 SelectResultReader 都用 ModuleInitializer
5. ✅ **类型安全** - 编译时检查，完整 IntelliSense

**实现优先级：**
1. ✅ 添加 `SelectResultReader<T>` 基础设施
2. ✅ 创建 `SelectInterceptorGenerator` 源生成器
3. ✅ 生成 ResultReader 实现
4. ✅ 生成 ModuleInitializer 注册代码
5. ✅ 生成 Interceptor 拦截代码
6. ✅ 修改现有 EntityProvider 使用 ModuleInitializer
```




