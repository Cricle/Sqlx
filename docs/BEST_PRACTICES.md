# Best Practices

Recommended patterns and practices for using Sqlx effectively.

## General Principles

### ✅ Use Placeholders for Repetitive SQL

Placeholders reduce boilerplate and adapt to different databases automatically.

**Good:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE id = @id")]
Task<User?> GetByIdAsync(long id);
```

**Bad:**
```csharp
[SqlTemplate("SELECT id, name, email, age, is_active FROM users WHERE id = @id")]
Task<User?> GetByIdAsync(long id);
```

**Why:** Placeholders automatically update when you add/remove entity properties.

---

### ✅ Write Simple SQL Directly

Don't use placeholders for simple SQL that won't change.

**Good:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE email = @email AND is_active = @isActive")]
Task<User?> FindActiveByEmailAsync(string email, bool isActive);
```

**Bad:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}} {{where email=@email AND is_active=@isActive}}")]
Task<User?> FindActiveByEmailAsync(string email, bool isActive);
```

**Why:** Simple WHERE clauses are clearer when written directly.

---

## Entity Design

### ✅ Use Record Types

Records provide immutability and value equality out of the box.

**Good:**
```csharp
[TableName("users")]
public record User
{
    public long Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
}
```

**Why:** Records are concise and provide better semantics for data objects.

---

### ✅ Use Nullable Reference Types

Enable nullable reference types to catch null-related bugs at compile time.

**Good:**
```csharp
public record User
{
    public long Id { get; set; }
    public string Name { get; set; } = string.Empty;  // Required
    public string? Email { get; set; }                 // Optional
}
```

**Why:** Explicit nullability prevents null reference exceptions.

---

### ✅ Initialize Non-Nullable Strings

Always initialize non-nullable string properties.

**Good:**
```csharp
public string Name { get; set; } = string.Empty;
```

**Bad:**
```csharp
public string Name { get; set; }  // Warning: Non-nullable property not initialized
```

---

## Repository Design

### ✅ Use Interfaces for Repositories

Define repository contracts as interfaces.

**Good:**
```csharp
public interface IUserRepository
{
    Task<User?> GetByIdAsync(long id);
    Task<List<User>> GetAllAsync();
    Task<long> InsertAsync(User user);
}

[RepositoryFor(typeof(IUserRepository))]
public partial class UserRepository : IUserRepository { }
```

**Why:** Interfaces enable dependency injection and testing.

---

### ✅ Use Async Methods

All database operations should be asynchronous.

**Good:**
```csharp
Task<User?> GetByIdAsync(long id);
Task<List<User>> GetAllAsync();
```

**Bad:**
```csharp
User? GetById(long id);
List<User> GetAll();
```

**Why:** Async methods prevent thread blocking and improve scalability.

---

### ✅ Return Nullable for Single Results

Use nullable return types for queries that might not find a result.

**Good:**
```csharp
Task<User?> GetByIdAsync(long id);
Task<User?> FindByEmailAsync(string email);
```

**Bad:**
```csharp
Task<User> GetByIdAsync(long id);  // What if not found?
```

---

## SQL Template Patterns

### ✅ Exclude Auto-Increment IDs in INSERT

Always exclude auto-increment primary keys from INSERT statements.

**Good:**
```csharp
[SqlTemplate("INSERT INTO {{table}} ({{columns --exclude Id}}) VALUES ({{values --exclude Id}})")]
[ReturnInsertedId]
Task<long> InsertAsync(User user);
```

**Bad:**
```csharp
[SqlTemplate("INSERT INTO {{table}} ({{columns}}) VALUES ({{values}})")]
Task<long> InsertAsync(User user);
```

**Why:** Auto-increment IDs are generated by the database.

---

### ✅ Exclude Immutable Fields in UPDATE

Don't update fields that shouldn't change.

**Good:**
```csharp
[SqlTemplate("UPDATE {{table}} SET {{set --exclude Id CreatedAt}} WHERE id = @id")]
Task<int> UpdateAsync(User user);
```

**Bad:**
```csharp
[SqlTemplate("UPDATE {{table}} SET {{set}} WHERE id = @id")]
Task<int> UpdateAsync(User user);
```

**Why:** Prevents accidental modification of immutable fields.

---

### ✅ Use Parameterized Queries

Always use parameters, never string concatenation.

**Good:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE name = @name")]
Task<User?> GetByNameAsync(string name);
```

**Bad:**
```csharp
[SqlTemplate($"SELECT {{columns}} FROM {{table}} WHERE name = '{name}'")]
Task<User?> GetByNameAsync(string name);
```

**Why:** Prevents SQL injection attacks.

---

### ✅ Use Dialect Placeholders for Portability

Use dialect-specific placeholders instead of hardcoding values.

**Good:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE is_active = {{bool_true}}")]
Task<List<User>> GetActiveAsync();

[SqlTemplate("UPDATE {{table}} SET updated_at = {{current_timestamp}} WHERE id = @id")]
Task<int> TouchAsync(long id);
```

**Bad:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE is_active = 1")]
Task<List<User>> GetActiveAsync();

[SqlTemplate("UPDATE {{table}} SET updated_at = GETDATE() WHERE id = @id")]
Task<int> TouchAsync(long id);
```

**Why:** Makes code portable across different databases.

---

## Performance Optimization

### ✅ Select Only Required Columns

Don't select columns you don't need.

**Good:**
```csharp
[SqlTemplate("SELECT {{columns --only Id Name Email}} FROM {{table}}")]
Task<List<User>> GetBasicInfoAsync();
```

**Bad:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}}")]
Task<List<User>> GetBasicInfoAsync();
```

**Why:** Reduces network traffic and memory usage.

---

### ✅ Use Pagination for Large Result Sets

Always paginate when querying large datasets.

**Good:**
```csharp
[SqlTemplate(@"
    SELECT {{columns}} 
    FROM {{table}} 
    ORDER BY created_at DESC 
    LIMIT @pageSize 
    OFFSET @skip
")]
Task<List<User>> GetPagedAsync(int pageSize, int skip);
```

**Why:** Prevents memory exhaustion and improves response time.

---

### ✅ Use Batch Operations

Batch multiple operations when possible.

**Good:**
```csharp
[SqlTemplate("INSERT INTO {{table}} (name, age) VALUES {{batch_values}}")]
[BatchOperation(MaxBatchSize = 500)]
Task<int> BatchInsertAsync(IEnumerable<User> users);
```

**Bad:**
```csharp
foreach (var user in users)
{
    await repo.InsertAsync(user);
}
```

**Why:** Reduces round trips to the database.

---

### ✅ Use Indexes

Create indexes on frequently queried columns.

```sql
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

**Why:** Dramatically improves query performance.

---

## Connection Management

### ✅ Use `using` Statements

Always dispose connections properly.

**Good:**
```csharp
await using var connection = new SqliteConnection(connectionString);
await connection.OpenAsync();

var repo = new UserRepository(connection);
var users = await repo.GetAllAsync();
```

**Why:** Ensures connections are returned to the pool.

---

### ✅ Reuse Connections

Reuse the same connection for multiple operations.

**Good:**
```csharp
await using var connection = new SqliteConnection(connectionString);
await connection.OpenAsync();

var repo = new UserRepository(connection);
var user1 = await repo.GetByIdAsync(1);
var user2 = await repo.GetByIdAsync(2);
```

**Bad:**
```csharp
await using var conn1 = new SqliteConnection(connectionString);
await conn1.OpenAsync();
var user1 = await new UserRepository(conn1).GetByIdAsync(1);

await using var conn2 = new SqliteConnection(connectionString);
await conn2.OpenAsync();
var user2 = await new UserRepository(conn2).GetByIdAsync(2);
```

**Why:** Reduces connection overhead.

---

## Transaction Management

### ✅ Use Transactions for Multiple Operations

Wrap related operations in transactions.

**Good:**
```csharp
await using var connection = new SqliteConnection(connectionString);
await connection.OpenAsync();

await using var transaction = await connection.BeginTransactionAsync();
try
{
    var repo = new UserRepository(connection);
    
    var userId = await repo.InsertAsync(user);
    await repo.UpdateAsync(user with { Id = userId });
    
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

**Why:** Ensures data consistency.

---

## Error Handling

### ✅ Handle Specific Exceptions

Catch specific database exceptions.

**Good:**
```csharp
try
{
    await repo.InsertAsync(user);
}
catch (SqliteException ex) when (ex.SqliteErrorCode == 19) // CONSTRAINT
{
    throw new DuplicateEmailException("Email already exists", ex);
}
```

**Bad:**
```csharp
try
{
    await repo.InsertAsync(user);
}
catch (Exception ex)
{
    // Too broad
}
```

---

### ✅ Validate Input

Validate input before database operations.

**Good:**
```csharp
public async Task<long> InsertAsync(User user)
{
    if (string.IsNullOrWhiteSpace(user.Name))
        throw new ArgumentException("Name is required", nameof(user));
    
    if (string.IsNullOrWhiteSpace(user.Email))
        throw new ArgumentException("Email is required", nameof(user));
    
    return await _repo.InsertAsync(user);
}
```

---

## Testing

### ✅ Use In-Memory Databases for Tests

Use SQLite in-memory databases for fast tests.

**Good:**
```csharp
[Fact]
public async Task InsertAsync_ShouldReturnId()
{
    // Arrange
    await using var connection = new SqliteConnection("Data Source=:memory:");
    await connection.OpenAsync();
    
    await connection.ExecuteAsync(@"
        CREATE TABLE users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT NOT NULL
        )
    ");
    
    var repo = new UserRepository(connection);
    
    // Act
    var userId = await repo.InsertAsync(new User 
    { 
        Name = "Alice", 
        Email = "alice@example.com" 
    });
    
    // Assert
    Assert.True(userId > 0);
}
```

---

### ✅ Test with SqlxDebugger

Use `[SqlxDebugger]` to verify generated SQL.

**Good:**
```csharp
[SqlxDebugger]
[SqlDefine(SqlDefineTypes.SQLite)]
[TableName("users")]
[RepositoryFor(typeof(IUserRepository))]
public partial class UserRepository : IUserRepository { }

[Fact]
public void GetByIdAsync_ShouldGenerateCorrectSql()
{
    var repo = new UserRepository(null!);
    var sql = repo.GetGetByIdAsyncSql(123);
    
    Assert.Equal("SELECT id, name, email FROM users WHERE id = @id", sql);
}
```

---

## Security

### ✅ Never Concatenate User Input

Always use parameters for user input.

**Good:**
```csharp
[SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE email = @email")]
Task<User?> FindByEmailAsync(string email);
```

**Bad:**
```csharp
[SqlTemplate($"SELECT {{columns}} FROM {{table}} WHERE email = '{email}'")]
Task<User?> FindByEmailAsync(string email);
```

**Why:** Prevents SQL injection.

---

### ✅ Exclude Sensitive Columns

Don't return sensitive data unless necessary.

**Good:**
```csharp
[SqlTemplate("SELECT {{columns --exclude Password Salt}} FROM {{table}}")]
Task<List<User>> GetAllAsync();
```

**Why:** Reduces exposure of sensitive information.

---

## Code Organization

### ✅ One Repository Per Entity

Create separate repositories for each entity.

**Good:**
```
Repositories/
  ├── IUserRepository.cs
  ├── UserRepository.cs
  ├── IOrderRepository.cs
  └── OrderRepository.cs
```

---

### ✅ Group Related Methods

Organize methods logically within repositories.

**Good:**
```csharp
public interface IUserRepository
{
    // Queries
    Task<User?> GetByIdAsync(long id);
    Task<User?> FindByEmailAsync(string email);
    Task<List<User>> GetAllAsync();
    Task<List<User>> SearchAsync(string query);
    
    // Commands
    Task<long> InsertAsync(User user);
    Task<int> UpdateAsync(User user);
    Task<int> DeleteAsync(long id);
    
    // Aggregates
    Task<long> CountAsync();
    Task<bool> EmailExistsAsync(string email);
}
```

---

## Common Pitfalls

### ❌ Forgetting `partial` Keyword

```csharp
// ❌ Wrong
public class UserRepository : IUserRepository { }

// ✅ Correct
public partial class UserRepository : IUserRepository { }
```

---

### ❌ Including Id in INSERT

```csharp
// ❌ Wrong
[SqlTemplate("INSERT INTO {{table}} ({{columns}}) VALUES ({{values}})")]

// ✅ Correct
[SqlTemplate("INSERT INTO {{table}} ({{columns --exclude Id}}) VALUES ({{values --exclude Id}})")]
```

---

### ❌ Updating Immutable Fields

```csharp
// ❌ Wrong
[SqlTemplate("UPDATE {{table}} SET {{set}} WHERE id = @id")]

// ✅ Correct
[SqlTemplate("UPDATE {{table}} SET {{set --exclude Id CreatedAt}} WHERE id = @id")]
```

---

### ❌ Hardcoding Database-Specific Values

```csharp
// ❌ Wrong
[SqlTemplate("WHERE is_active = 1")]

// ✅ Correct
[SqlTemplate("WHERE is_active = {{bool_true}}")]
```

---

## See Also

- [Quick Start Guide](QUICK_START.md)
- [Placeholder Reference](PLACEHOLDER_REFERENCE.md)
- [API Reference](API_REFERENCE.md)
- [Multi-Database Guide](MULTI_DATABASE.md)
