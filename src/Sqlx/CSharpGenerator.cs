// -----------------------------------------------------------------------
// <copyright file="CSharpGenerator.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Sqlx;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Sqlx.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

/// <summary>
/// Stored procedures generator for C#.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class CSharpGenerator : AbstractGenerator
{
    /// <summary>
    /// Gets the C# attribute source using the optimized generator.
    /// </summary>
    private static string CSharpAttributeSource => AttributeSourceGenerator.GenerateAttributeSource();

    private const string LegacyCSharpAttributeSource = @"// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
namespace Sqlx.Annotations
{
    /// <summary>
    /// Specifies SQL command text for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    public sealed class SqlxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the SqlxAttribute class.
        /// </summary>
        public SqlxAttribute()
            => StoredProcedureName = string.Empty;
        /// <summary>
        /// Initializes a new instance of the SqlxAttribute class with the specified SQL command.
        /// </summary>
        /// <param name=""name"">The SQL command text.</param>
        public SqlxAttribute(string name)
            => StoredProcedureName = name;
        /// <summary>
        /// Gets the SQL command text or stored procedure name.
        /// </summary>
        public string StoredProcedureName { get; }
    }

    /// <summary>
    /// Specifies that a class should act as a repository for the specified service type.
    /// The service type can be an interface or abstract class.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class RepositoryForAttribute : Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""RepositoryForAttribute""/> class.
        /// </summary>
        /// <param name=""serviceType"">The service type this repository implements.</param>
        public RepositoryForAttribute(Type serviceType) => ServiceType = serviceType;
    
        /// <summary>
        /// Gets the service type this repository implements.
        /// </summary>
        public Type ServiceType { get; }
    }

    /// <summary>
    /// Specifies the table name for database operations.
    /// Can be applied to parameters, methods, or types.
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Method 
        | AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
    public sealed class TableNameAttribute : Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""TableNameAttribute""/> class.
        /// </summary>
        /// <param name=""tableName"">The table name to use for database operations.</param>
        public TableNameAttribute(string tableName) => TableName = tableName;
    
        /// <summary>
        /// Gets the table name to use for database operations.
        /// </summary>
        public string TableName { get; }
    }

    /// <summary>
    /// Specifies raw SQL command text for a method or parameter.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter 
        | global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class RawSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the RawSqlAttribute class.
        /// </summary>
        public RawSqlAttribute() { }
        /// <summary>
        /// Initializes a new instance of the RawSqlAttribute class with the specified SQL.
        /// </summary>
        /// <param name=""sql"">The raw SQL command text.</param>
        public RawSqlAttribute(global::System.String sql) { }
    }
    /// <summary>
    /// Specifies that a parameter should be converted from an expression to SQL.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    public sealed class ExpressionToSqlAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the ExpressionToSqlAttribute class.
        /// </summary>
        public ExpressionToSqlAttribute() { }
    }
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class ExecuteNoQueryAttribute : global::System.Attribute { }
    [global::System.AttributeUsage(global::System.AttributeTargets.Method
        | global::System.AttributeTargets.Class
        | global::System.AttributeTargets.Field
        | global::System.AttributeTargets.Property
        | global::System.AttributeTargets.Method
        | global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class TimeoutAttribute : global::System.Attribute
    {
        public TimeoutAttribute() { }
        public TimeoutAttribute(int timeout) => Timeout = timeout;
        public int Timeout { get; }
    }
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class DbColumnAttribute : global::System.Attribute
    {
        public DbColumnAttribute() { }
        public DbColumnAttribute(string? name) => Name = name;
        public string? Name { get; }
        public byte Precision { get; }
        public byte Scale { get; }
        public byte Size { get; }
        public global::System.Data.ParameterDirection Direction { get; }
    }
    /// <summary>
    /// Tag to paramter make it as <see cref=""Func{DbDataReader, Task}""/> 
    /// or <see cref=""Action{DbDataReader}""/> for read data
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class ReadHandlerAttribute : global::System.Attribute { }
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter 
        | global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class DbSetTypeAttribute : global::System.Attribute
    {
        public DbSetTypeAttribute(global::System.Type type) => Type = type;
        public global::System.Type Type { get; }
    }
    [global::System.AttributeUsage(global::System.AttributeTargets.Method 
        | global::System.AttributeTargets.Class, AllowMultiple = false)]
    sealed class SqlDefineAttribute : global::System.Attribute
    {
        public SqlDefineAttribute(SqlDefineTypes type) { }
        public SqlDefineAttribute(global::System.String columnLeft,
                                  global::System.String columnRight,
                                  global::System.String stringLeft,
                                  global::System.String stringRight,
                                  global::System.String ParamterPrefx) { }
    }
    enum SqlDefineTypes
    {
        MySql = 0,
        SqlServer = 1,
        Postgresql = 2,
    }
    /// <summary>
    /// Specifies the SQL execution type and target table for a method.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    public sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the SqlExecuteTypeAttribute class.
        /// </summary>
        /// <param name=""Type"">The type of SQL operation to perform.</param>
        /// <param name=""TableName"">The name of the target database table.</param>
        public SqlExecuteTypeAttribute(SqlExecuteTypes Type, string TableName) { }
    }
    /// <summary>
    /// Defines the types of SQL operations that can be performed.
    /// </summary>
    public enum SqlExecuteTypes
    {
        /// <summary>
        /// Represents a SELECT operation for reading data.
        /// </summary>
        Select = 0,
        /// <summary>
        /// Represents an UPDATE operation for modifying existing data.
        /// </summary>
        Update = 1,
        /// <summary>
        /// Represents an INSERT operation for adding new data.
        /// </summary>
        Insert = 2,
        /// <summary>
        /// Represents a DELETE operation for removing data.
        /// </summary>
        Delete = 3,
    }
    /// <summary>
    /// Represents a SQL template with parameters for efficient query execution.
    /// This class is designed for high performance and security by pre-parsing SQL and parameters.
    /// </summary>
    public record SqlTemplate(string Sql, IReadOnlyList<DbParameter> Parameters)
    {
        /// <summary>
        /// Creates a SQL template with the specified SQL and parameters.
        /// Parameters are validated to prevent SQL injection attacks.
        /// </summary>
        public SqlTemplate(string sql, params DbParameter[] parameters) 
            : this(sql, (IReadOnlyList<DbParameter>)parameters) { }
        /// <summary>
        /// Creates a SQL template with no parameters.
        /// </summary>
        public SqlTemplate(string sql) : this(sql, Array.Empty<DbParameter>()) { }
    }
    /// <summary>
    /// Provides predefined SQL dialects for different database systems.
    /// Each dialect includes proper column wrapping and parameter prefixes for security.
    /// </summary>
    public static class SqlDefine
    {
        /// <summary>
        /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) MySql = (""`"", ""`"", ""'"", ""'"", ""@"");
        /// <summary>
        /// SQL Server dialect configuration with bracket column wrapping and @ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) SqlServer = (""["", ""]"", ""'"", ""'"", ""@"");
        /// <summary>
        /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
        /// </summary>
        public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
            string StringRight, string ParameterPrefix) PgSql = (""\"""", ""\"""", ""'"", ""'"", ""$"");
    }
    /// <summary>
    /// High-performance LINQ expression to SQL converter with type safety and caching.
    /// Provides both direct SQL composition and parameterized query generation.
    /// </summary>
    public class ExpressionToSql<T> : IDisposable
    {
        private readonly List<Expression<Func<T, bool>>> _whereConditions = 
            new List<Expression<Func<T, bool>>>();
        private readonly List<(LambdaExpression Expression, bool Descending)> _orderByExpressions = 
            new List<(LambdaExpression, bool)>();
        private readonly List<(string Column, string Value)> _setClausesConstant = 
            new List<(string, string)>();
        private readonly List<(string Column, string Expression)> _setClausesExpression = 
            new List<(string, string)>();
        private readonly (string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) _dialect;
        private SqlTemplate? _cachedTemplate;
        private int? _take;
        private int? _skip;
        /// <summary>
        /// Initializes a new instance with the specified SQL dialect.
        /// </summary>
        private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft, 
            string StringRight, string ParameterPrefix) dialect)
        {
            _dialect = dialect;
        }
        /// <summary>
        /// Creates an ExpressionToSql builder for SQL Server dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlServer()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);
        /// <summary>
        /// Creates an ExpressionToSql builder for MySQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForMySql()
            => new ExpressionToSql<T>(SqlDefine.MySql);
        /// <summary>
        /// Creates an ExpressionToSql builder for PostgreSQL dialect.
        /// </summary>
        public static ExpressionToSql<T> ForPostgreSQL()
            => new ExpressionToSql<T>(SqlDefine.PgSql);
        /// <summary>
        /// Creates an ExpressionToSql builder for SQLite dialect.
        /// </summary>
        public static ExpressionToSql<T> ForSqlite()
            => new ExpressionToSql<T>(SqlDefine.SqlServer); // SQLite uses same syntax as SQL Server
        /// <summary>
        /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
        /// </summary>
        public static ExpressionToSql<T> Create()
            => new ExpressionToSql<T>(SqlDefine.SqlServer);
        /// <summary>
        /// Adds a WHERE condition to the query.
        /// </summary>
        public ExpressionToSql<T> Where(Expression<Func<T, bool>> predicate)
        {
            if (predicate != null)
                _whereConditions.Add(predicate);
            return this;
        }
        /// <summary>
        /// Adds an ORDER BY clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderBy<TKey>(Expression<Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, false));
            return this;
        }
        /// <summary>
        /// Adds an ORDER BY DESC clause to the query.
        /// </summary>
        public ExpressionToSql<T> OrderByDescending<TKey>(Expression<Func<T, TKey>> keySelector)
        {
            if (keySelector != null)
                _orderByExpressions.Add((keySelector, true));
            return this;
        }
        /// <summary>
        /// Limits the number of returned rows.
        /// </summary>
        public ExpressionToSql<T> Take(int count)
        {
            _take = count;
            return this;
        }
        /// <summary>
        /// Skips the specified number of rows.
        /// </summary>
        public ExpressionToSql<T> Skip(int count)
        {
            _skip = count;
            return this;
        }
        /// <summary>
        /// Adds an AND condition to the query.
        /// </summary>
        public ExpressionToSql<T> And(Expression<Func<T, bool>> predicate)
        {
            return Where(predicate);
        }
        /// <summary>
        /// Sets a value for an UPDATE operation. Supports patterns like a=1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(Expression<Func<T, TValue>> selector, TValue value)
        {
            var columnName = GetColumnName(selector.Body);
            var valueStr = FormatConstantValue(value);
            _setClausesConstant.Add((columnName, valueStr));
            return this;
        }
        /// <summary>
        /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
        /// </summary>
        public ExpressionToSql<T> Set<TValue>(Expression<Func<T, TValue>> selector, 
            Expression<Func<T, TValue>> valueExpression)
        {
            var columnName = GetColumnName(selector.Body);
            var expressionSql = ParseExpression(valueExpression.Body);
            _setClausesExpression.Add((columnName, expressionSql));
            return this;
        }
        /// <summary>
        /// Specifies columns for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Insert(Expression<Func<T, object>> selector)
        {
            return this;
        }
        /// <summary>
        /// Specifies values for an INSERT operation.
        /// </summary>
        public ExpressionToSql<T> Values(params object[] values)
        {
            return this;
        }
        /// <summary>
        /// Converts the built query to a parameterized SQL template.
        /// Results are cached for performance on repeated calls.
        /// </summary>
        public SqlTemplate ToTemplate()
        {
            if (_cachedTemplate != null)
                return _cachedTemplate;
            var sql = BuildSql();
            _cachedTemplate = new SqlTemplate(sql, Array.Empty<DbParameter>());
            return _cachedTemplate;
        }
        /// <summary>
        /// Converts the built query to a SQL string.
        /// </summary>
        public string ToSql()
        {
            return BuildSql();
        }
        /// <summary>
        /// Generates the WHERE clause portion of the query.
        /// </summary>
        public string ToWhereClause()
        {
            if (_whereConditions.Count == 0)
                return string.Empty;
            var conditions = new List<string>();
            foreach (var condition in _whereConditions)
            {
                var conditionSql = ParseExpression(condition.Body);
                conditions.Add($""({conditionSql})"");
            }
            return string.Join("" AND "", conditions);
        }
        /// <summary>
        /// Generates additional clauses for the query.
        /// </summary>
        public string ToAdditionalClause()
        {
            var clauses = new List<string>();
            if (_orderByExpressions.Count > 0)
            {
                var orderClauses = new List<string>();
                foreach (var (expression, descending) in _orderByExpressions)
                {
                    var columnName = GetColumnName(expression.Body);
                    var direction = descending ? "" DESC"" : "" ASC"";
                    orderClauses.Add(columnName + direction);
                }
                clauses.Add(""ORDER BY "" + string.Join("", "", orderClauses));
            }
            if (_skip.HasValue)
            {
                clauses.Add($""OFFSET {_skip.Value}"");
            }
            if (_take.HasValue)
            {
                clauses.Add($""LIMIT {_take.Value}"");
            }
            return string.Join("" "", clauses);
        }
        /// <summary>
        /// Releases resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            _whereConditions.Clear();
            _orderByExpressions.Clear();
            _setClausesConstant.Clear();
            _setClausesExpression.Clear();
            _cachedTemplate = null;
        }
        private string BuildSql()
        {
            var sql = new StringBuilder();
            if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
            {
                sql.Append(""UPDATE "");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                sql.Append("" SET "");
                var setClauses = new List<string>();
                foreach (var (column, value) in _setClausesConstant)
                {
                    setClauses.Add($""{column} = {value}"");
                }
                foreach (var (column, expression) in _setClausesExpression)
                {
                    setClauses.Add($""{column} = {expression}"");
                }
                sql.Append(string.Join("", "", setClauses));
            }
            else
            {
                sql.Append(""SELECT * FROM "");
                sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
            }
            if (_whereConditions.Count > 0)
            {
                sql.Append("" WHERE "");
                var conditions = new List<string>();
                foreach (var condition in _whereConditions)
                {
                    var conditionSql = ParseExpression(condition.Body);
                    conditions.Add($""({conditionSql})"");
                }
                sql.Append(string.Join("" AND "", conditions));
            }
            if (_setClausesConstant.Count == 0 && _setClausesExpression.Count == 0)
            {
                if (_orderByExpressions.Count > 0)
                {
                    sql.Append("" ORDER BY "");
                    var orderClauses = new List<string>();
                    foreach (var (expression, descending) in _orderByExpressions)
                    {
                        var columnName = GetColumnName(expression.Body);
                        var direction = descending ? "" DESC"" : "" ASC"";
                        orderClauses.Add(columnName + direction);
                    }
                    sql.Append(string.Join("", "", orderClauses));
                }
                if (_skip.HasValue)
                {
                    sql.Append($"" OFFSET {_skip.Value}"");
                }
                if (_take.HasValue)
                {
                    sql.Append($"" LIMIT {_take.Value}"");
                }
            }
            return sql.ToString();
        }
        private string ParseExpression(Expression expression)
        {
            switch (expression)
            {
                case BinaryExpression binary:
                    return ParseBinaryExpression(binary);
                case MemberExpression member:
                    return GetColumnName(member);
                case ConstantExpression constant:
                    return GetConstantValue(constant);
                case UnaryExpression unary when unary.NodeType == ExpressionType.Not:
                    return $""NOT ({ParseExpression(unary.Operand)})"";
                default:
                    return ""1=1"";
            }
        }
        private string ParseBinaryExpression(BinaryExpression binary)
        {
            var left = ParseExpression(binary.Left);
            var right = ParseExpression(binary.Right);
            return binary.NodeType switch
            {
                ExpressionType.Equal => $""{left} = {right}"",
                ExpressionType.NotEqual => $""{left} <> {right}"",
                ExpressionType.GreaterThan => $""{left} > {right}"",
                ExpressionType.GreaterThanOrEqual => $""{left} >= {right}"",
                ExpressionType.LessThan => $""{left} < {right}"",
                ExpressionType.LessThanOrEqual => $""{left} <= {right}"",
                ExpressionType.AndAlso => $""({left}) AND ({right})"",
                ExpressionType.OrElse => $""({left}) OR ({right})"",
                _ => $""{left} = {right}""
            };
        }
        private string GetColumnName(Expression expression)
        {
            if (expression is MemberExpression member)
            {
                return _dialect.ColumnLeft + member.Member.Name + _dialect.ColumnRight;
            }
            if (expression is UnaryExpression unary && 
                unary.Operand is MemberExpression unaryMember)
            {
                return _dialect.ColumnLeft + unaryMember.Member.Name + _dialect.ColumnRight;
            }
            return ""UnknownColumn"";
        }
        private string GetConstantValue(ConstantExpression constant)
        {
            if (constant.Value == null)
                return ""NULL"";
            if (constant.Type == typeof(string))
                return _dialect.StringLeft + constant.Value?.ToString() + 
                    _dialect.StringRight;
            if (constant.Type == typeof(int) || constant.Type == typeof(long) ||
                constant.Type == typeof(double) || constant.Type == typeof(decimal))
                return constant.Value?.ToString() ?? ""0"";
            if (constant.Type == typeof(bool))
                return (bool)constant.Value! ? ""1"" : ""0"";
            return _dialect.StringLeft + (constant.Value?.ToString() ?? """") + 
                _dialect.StringRight;
        }
        private string FormatConstantValue<TValue>(TValue value)
        {
            if (value == null)
                return ""NULL"";
            if (value is string stringValue)
                return _dialect.StringLeft + stringValue + _dialect.StringRight;
            if (value is int || value is long || value is double || value is decimal)
                return value.ToString() ?? ""0"";
            if (value is bool boolValue)
                return boolValue ? ""1"" : ""0"";
            return _dialect.StringLeft + value.ToString() + _dialect.StringRight;
        }
    }
}";

    /// <summary>
    /// Initializes a new instance of the <see cref="CSharpGenerator"/> class.
    /// </summary>
    public CSharpGenerator()
    {
        // Initialize performance monitoring for source generation
        Debug.WriteLine("🚀 Sqlx CSharpGenerator initialized with advanced optimizations");
    }









    /// <summary>
    /// C# specific syntax receiver for collecting method symbols and repository classes.
    /// </summary>
    private class CSharpSyntaxReceiver : ISqlxSyntaxReceiver
    {
        public List<IMethodSymbol> Methods { get; } = new List<IMethodSymbol>();
        public List<INamedTypeSymbol> RepositoryClasses { get; } = new List<INamedTypeSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is MethodDeclarationSyntax methodDeclaration)
            {
                var methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodDeclaration);
                if (methodSymbol != null && HasSqlxAttribute(methodSymbol))
                {
                    Methods.Add(methodSymbol);
                }
            }
            else if (context.Node is ClassDeclarationSyntax classDeclaration)
            {
                var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
                if (classSymbol != null)
                {
                    // Debug: log all classes we encounter
                    System.Diagnostics.Debug.WriteLine($"Found class: {classSymbol.Name}");
                    if (HasRepositoryForAttribute(classSymbol))
                    {
                        System.Diagnostics.Debug.WriteLine(
                            $"Adding repository class: {classSymbol.Name}");
                        RepositoryClasses.Add(classSymbol);
                    }
                }
            }
        }

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Legacy method - not used in modern Roslyn
        }

        private static bool HasSqlxAttribute(IMethodSymbol method)
        {
            return method.GetAttributes().Any(attr =>
                attr.AttributeClass?.Name == "SqlxAttribute" ||
                attr.AttributeClass?.Name == "RawSqlAttribute" ||
                attr.AttributeClass?.Name == "SqlExecuteTypeAttribute");
        }

        private static bool HasRepositoryForAttribute(INamedTypeSymbol type)
        {
            var attributes = type.GetAttributes();
            System.Diagnostics.Debug.WriteLine(
                $"Class {type.Name} has {attributes.Length} attributes:");
            foreach (var attr in attributes)
            {
                System.Diagnostics.Debug.WriteLine(
                    $"  - {attr.AttributeClass?.Name} ({attr.AttributeClass?.ToDisplayString()})");
            }
            
            var hasAttr = attributes.Any(attr => attr.AttributeClass?.Name == "RepositoryForAttribute" || attr.AttributeClass?.Name == "RepositoryFor");
            // Debug output - this will show in the compiler output
            if (hasAttr)
            {
                System.Diagnostics.Debug.WriteLine(
                    $"Found RepositoryFor attribute on {type.Name}");
            }
            else
            {
                System.Diagnostics.Debug.WriteLine(
                    $"No RepositoryFor attribute found on {type.Name}");
            }
            return hasAttr;
        }
    }

    /// <summary>
    /// Called to initialize the generator and register for the various 
    /// <see cref="SyntaxNode"/>
    /// callbacks.
    /// </summary>
    /// <param name="context">The generator context.</param>
    public override void Initialize(GeneratorInitializationContext context)
    {
        System.Diagnostics.Debug.WriteLine("CSharpGenerator.Initialize called");
        context.RegisterForSyntaxNotifications(() => new CSharpSyntaxReceiver());
        context.RegisterForPostInitialization(ctx => {
            // Generate the required attributes at compile time
            ctx.AddSource("SqlxAttributes.g.cs", CSharpAttributeSource);
        });
    }

    private static string FilterOutRepositoryAttributes(string source)
    {
        // Remove RepositoryForAttribute and TableNameAttribute definitions
        // since they are now defined in Attributes.cs
        var lines = source.Split('\n');
        var result = new System.Text.StringBuilder();
        bool skipAttribute = false;
        int braceCount = 0;

        foreach (var line in lines)
        {
            if (line.Contains("sealed class RepositoryForAttribute") || 
                line.Contains("sealed class TableNameAttribute"))
            {
                skipAttribute = true;
                braceCount = 0;
                continue;
            }

            if (skipAttribute)
            {
                // Count braces to know when the attribute class ends
                braceCount += line.Count(c => c == '{');
                braceCount -= line.Count(c => c == '}');
                
                if (braceCount <= 0)
                {
                    skipAttribute = false;
                }
                continue;
            }

            result.AppendLine(line);
        }

        return result.ToString();
    }
}

