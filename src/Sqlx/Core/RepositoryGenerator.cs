// -----------------------------------------------------------------------
// <copyright file="RepositoryGenerator.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Sqlx.Core;

/// <summary>
/// Optimized repository implementation generator.
/// </summary>
internal static class RepositoryGenerator
{
    /// <summary>
    /// Generates a complete repository implementation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void GenerateImplementation(IndentedStringBuilder sb, INamedTypeSymbol repositoryClass, INamedTypeSymbol serviceInterface, INamedTypeSymbol? entityType, string tableName)
    {
        GenerateFileHeader(sb);
        GenerateNamespaceAndUsings(sb, repositoryClass);
        GenerateClassDeclaration(sb, repositoryClass, serviceInterface);
        GenerateRepositoryMethods(sb, serviceInterface, entityType, tableName, repositoryClass);
        GenerateClassClosing(sb, repositoryClass);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GenerateFileHeader(IndentedStringBuilder sb)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file was generated by Sqlx Repository Generator");
        sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable disable");
        sb.AppendLine("#pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669, CS8628, CS0266");
        sb.AppendLine();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GenerateNamespaceAndUsings(IndentedStringBuilder sb, INamedTypeSymbol repositoryClass)
    {
        var namespaceName = repositoryClass.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.PushIndent();
        }

        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Data.Common;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Sqlx.Annotations;");
        sb.AppendLine();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GenerateClassDeclaration(IndentedStringBuilder sb, INamedTypeSymbol repositoryClass, INamedTypeSymbol serviceInterface)
    {
        sb.AppendLine($"{repositoryClass.DeclaredAccessibility.GetAccessibility()} partial class {repositoryClass.Name} : {serviceInterface.ToDisplayString()}");
        sb.AppendLine("{");
        sb.PushIndent();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GenerateRepositoryMethods(IndentedStringBuilder sb, INamedTypeSymbol serviceInterface, INamedTypeSymbol? entityType, string tableName, INamedTypeSymbol repositoryClass)
    {
        var connectionFieldName = GetDbConnectionFieldName(repositoryClass);

        // Generate standard CRUD methods
        var methods = serviceInterface.GetMembers().OfType<IMethodSymbol>().ToArray();

        foreach (var method in methods)
        {
            GenerateRepositoryMethod(sb, method, entityType, tableName, connectionFieldName);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GenerateRepositoryMethod(IndentedStringBuilder sb, IMethodSymbol method, INamedTypeSymbol? entityType, string tableName, string connectionFieldName)
    {
        var methodName = method.Name;
        var isAsync = TypeAnalyzer.IsAsyncType(method.ReturnType);
        var sql = GenerateSqlForMethod(methodName, tableName, entityType);

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated implementation of {methodName}.");
        sb.AppendLine($"/// </summary>");

        CodeGenerator.GenerateMethodSignature(sb, method);

        sb.AppendLine($"var connection = {connectionFieldName} ?? throw new ArgumentNullException(nameof({connectionFieldName}));");
        sb.AppendLine("var cancellationToken = cancellationToken;");

        CodeGenerator.GenerateConnectionSetup(sb, isAsync);
        CodeGenerator.GenerateCommandSetup(sb, sql);
        CodeGenerator.GenerateParameterAssignment(sb, method, entityType);

        var operation = GetOperationType(methodName);
        CodeGenerator.GenerateExecutionAndReturn(sb, method, operation, entityType, isAsync);

        sb.PopIndent();
        sb.AppendLine("}");
        sb.AppendLine();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void GenerateClassClosing(IndentedStringBuilder sb, INamedTypeSymbol repositoryClass)
    {
        sb.PopIndent();
        sb.AppendLine("}");

        var namespaceName = repositoryClass.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.PopIndent();
            sb.AppendLine("}");
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static string GetDbConnectionFieldName(INamedTypeSymbol repositoryClass)
    {
        var connectionField = repositoryClass.GetMembers()
            .OfType<IFieldSymbol>()
            .FirstOrDefault(f => f.Type.ToDisplayString().Contains("DbConnection"));

        return connectionField?.Name ?? "_connection";
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static string GenerateSqlForMethod(string methodName, string tableName, INamedTypeSymbol? entityType)
    {
        return methodName.ToLowerInvariant() switch
        {
            var name when name.StartsWith("get") || name.StartsWith("find") || name.StartsWith("select")
                => $"\"SELECT * FROM {tableName}\"",
            var name when name.StartsWith("add") || name.StartsWith("create") || name.StartsWith("insert")
                => GenerateInsertSql(tableName, entityType),
            var name when name.StartsWith("update") || name.StartsWith("modify")
                => GenerateUpdateSql(tableName, entityType),
            var name when name.StartsWith("delete") || name.StartsWith("remove")
                => $"\"DELETE FROM {tableName} WHERE Id = @id\"",
            _ => $"\"SELECT * FROM {tableName}\""
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static string GenerateInsertSql(string tableName, INamedTypeSymbol? entityType)
    {
        if (entityType == null) return $"\"INSERT INTO {tableName} DEFAULT VALUES\"";

        var properties = entityType.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.SetMethod != null && p.SetMethod.DeclaredAccessibility == Accessibility.Public && p.Name != "Id")
            .ToArray();

        if (properties.Length == 0) return $"\"INSERT INTO {tableName} DEFAULT VALUES\"";

        var columns = string.Join(", ", properties.Select(p => p.Name));
        var parameters = string.Join(", ", properties.Select(p => "@" + p.Name.ToLowerInvariant()));

        return $"\"INSERT INTO {tableName} ({columns}) VALUES ({parameters})\"";
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static string GenerateUpdateSql(string tableName, INamedTypeSymbol? entityType)
    {
        if (entityType == null) return $"\"UPDATE {tableName} SET UpdatedAt = GETDATE() WHERE Id = @id\"";

        var properties = entityType.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.SetMethod != null && p.SetMethod.DeclaredAccessibility == Accessibility.Public && p.Name != "Id")
            .ToArray();

        if (properties.Length == 0) return $"\"UPDATE {tableName} SET UpdatedAt = GETDATE() WHERE Id = @id\"";

        var setClause = string.Join(", ", properties.Select(p => $"{p.Name} = @{p.Name.ToLowerInvariant()}"));

        return $"\"UPDATE {tableName} SET {setClause} WHERE Id = @id\"";
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static SqlOperationType GetOperationType(string methodName)
    {
        var name = methodName.ToLowerInvariant();

        if (name.StartsWith("get") || name.StartsWith("find") || name.StartsWith("select"))
            return SqlOperationType.Select;
        if (name.StartsWith("add") || name.StartsWith("create") || name.StartsWith("insert"))
            return SqlOperationType.Insert;
        if (name.StartsWith("update") || name.StartsWith("modify"))
            return SqlOperationType.Update;
        if (name.StartsWith("delete") || name.StartsWith("remove"))
            return SqlOperationType.Delete;
        if (name.StartsWith("count") || name.StartsWith("exists"))
            return SqlOperationType.Scalar;

        return SqlOperationType.Select;
    }
}

