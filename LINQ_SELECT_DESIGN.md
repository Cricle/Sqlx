# LINQ Select 匿名类型支持设计方案

## 最终方案：Interceptor + ModuleInitializer + 泛型静态缓存

### 核心思路

**利用 .NET 的现代特性：**
1. **Interceptor（拦截器）** - 编译时拦截 Select 调用，注入生成的 ResultReader
2. **ModuleInitializer** - 模块初始化时自动注册所有 ResultReader
3. **泛型静态类** - 零开销缓存，无需字典

### 完整实现方案

#### 1. 泛型静态缓存（基础设施）

```csharp
// src/Sqlx/SelectResultReader.cs
namespace Sqlx
{
    /// <summary>
    /// Generic static cache for Select projection result readers.
    /// Each type T has its own static instance (singleton per type).
    /// </summary>
    public static class SelectResultReader<T>
    {
        private static IResultReader<T>? _instance;
        
        public static IResultReader<T>? Instance
        {
            get => _instance;
            set => _instance ??= value;  // Only set once
        }
    }
}
```

#### 2. 源生成器检测 Select 调用

```csharp
// src/Sqlx.Generator/SelectInterceptorGenerator.cs
[Generator(LanguageNames.CSharp)]
public class SelectInterceptorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 检测所有 Select 方法调用
        var selectCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSelectMethodCall(s),
                transform: static (ctx, _) => GetSelectCallInfo(ctx))
            .Where(static m => m is not null);

        var compilationAndCalls = context.CompilationProvider.Combine(selectCalls.Collect());
        context.RegisterSourceOutput(compilationAndCalls, 
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }
    
    private static bool IsSelectMethodCall(SyntaxNode node)
    {
        // 检测：.Select(u => new { ... }) 或 .Select(u => new SomeType { ... })
        return node is InvocationExpressionSyntax invocation &&
               invocation.Expression is MemberAccessExpressionSyntax member &&
               member.Name.Identifier.Text == "Select";
    }
    
    private static SelectCallInfo? GetSelectCallInfo(GeneratorSyntaxContext context)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        // 获取 Select 的返回类型
        var symbolInfo = semanticModel.GetSymbolInfo(invocation);
        if (symbolInfo.Symbol is not IMethodSymbol methodSymbol)
            return null;
            
        // 提取投影类型（TResult）
        var resultType = methodSymbol.ReturnType; // IQueryable<TResult>
        if (resultType is not INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
            return null;
            
        var projectionType = namedType.TypeArguments[0];
        
        // 提取 lambda 表达式中的列信息
        var lambda = GetLambdaExpression(invocation);
        var columns = ExtractColumns(lambda, semanticModel);
        
        return new SelectCallInfo
        {
            ProjectionType = projectionType,
            Columns = columns,
            Location = invocation.GetLocation(),
            FilePath = invocation.SyntaxTree.FilePath,
            LineNumber = invocation.GetLocation().GetLineSpan().StartLinePosition.Line + 1,
            CharacterNumber = invocation.GetLocation().GetLineSpan().StartLinePosition.Character + 1
        };
    }
}
```

#### 3. 生成 ResultReader 实现（正确的匿名类型处理）

**关键问题：** 匿名类型 `new { Id = 1, Name = "test" }` 的类型是编译器生成的，如 `<>f__AnonymousType0<int, string>`，我们无法在源生成器中直接引用它。

**解决方案：** 源生成器分析 Select lambda，提取属性信息，然后生成**相同结构的匿名类型**，利用 C# 编译器的匿名类型统一机制。

```csharp
// Generated/SelectProjections.g.cs
// <auto-generated/>
#nullable enable

namespace Sqlx.Generated
{
    using System;
    using System.Data;
    using System.Linq.Expressions;
    
    // 方案 1：利用 C# 匿名类型统一机制（推荐）
    // 相同结构的匿名类型会被编译器统一为同一个类型
    internal sealed class AnonymousType_User_Id_Name_ResultReader<T> : IResultReader<T>
    {
        // 编译时生成的委托
        private static readonly Func<int, string, T> _createInstance = CreateInstanceFunc();
        
        private static Func<int, string, T> CreateInstanceFunc()
        {
            // 创建表达式：(id, name) => new { Id = id, Name = name }
            var idParam = Expression.Parameter(typeof(int), "id");
            var nameParam = Expression.Parameter(typeof(string), "name");
            
            // 创建匿名类型实例
            // 注意：属性名和顺序必须与用户代码中的匿名类型完全一致
            var anonymousType = new { Id = 0, Name = "" }.GetType();
            var ctor = anonymousType.GetConstructor(new[] { typeof(int), typeof(string) })!;
            var newExpr = Expression.New(ctor, idParam, nameParam);
            
            // 转换为 T（如果 T 就是这个匿名类型，转换会成功）
            var convertExpr = Expression.Convert(newExpr, typeof(T));
            
            return Expression.Lambda<Func<int, string, T>>(convertExpr, idParam, nameParam).Compile();
        }
        
        public T Read(IDataReader reader)
        {
            return _createInstance(
                reader.GetInt32(0),
                reader.GetString(1)
            );
        }
        
        public T Read(IDataReader reader, int[] ordinals)
        {
            return _createInstance(
                reader.GetInt32(ordinals[0]),
                reader.GetString(ordinals[1])
            );
        }
        
        public int[] GetOrdinals(IDataReader reader)
        {
            return new[] { reader.GetOrdinal("id"), reader.GetOrdinal("name") };
        }
    }
    
    // 方案 2：直接在生成的代码中创建匿名类型（最简单，推荐）
    internal sealed class AnonymousType_User_Id_Name_ResultReader_Simple<T> : IResultReader<T>
    {
        public T Read(IDataReader reader)
        {
            // 直接创建匿名类型，让编译器处理类型统一
            // 如果用户代码中的匿名类型结构相同，编译器会将它们统一为同一个类型
            return (T)(object)new
            {
                Id = reader.GetInt32(0),
                Name = reader.GetString(1)
            };
        }
        
        public T Read(IDataReader reader, int[] ordinals)
        {
            return (T)(object)new
            {
                Id = reader.GetInt32(ordinals[0]),
                Name = reader.GetString(ordinals[1])
            };
        }
        
        public int[] GetOrdinals(IDataReader reader)
        {
            return new[] { reader.GetOrdinal("id"), reader.GetOrdinal("name") };
        }
    }
    
    // 方案 3：使用反射获取构造函数（运行时开销，但 AOT 兼容）
    internal sealed class AnonymousType_User_Id_Name_ResultReader_Reflection<T> : IResultReader<T>
    {
        private static readonly Func<IDataReader, T> _readFunc = BuildReadFunc();
        
        private static Func<IDataReader, T> BuildReadFunc()
        {
            var type = typeof(T);
            var ctor = type.GetConstructors()[0];  // 匿名类型只有一个构造函数
            var parameters = ctor.GetParameters();
            
            // 构建表达式树：reader => new T(reader.GetInt32(0), reader.GetString(1))
            var readerParam = Expression.Parameter(typeof(IDataReader), "reader");
            
            var args = new List<Expression>();
            for (int i = 0; i < parameters.Length; i++)
            {
                var paramType = parameters[i].ParameterType;
                var getMethod = GetReaderMethod(paramType);
                var callExpr = Expression.Call(
                    readerParam, 
                    getMethod, 
                    Expression.Constant(i));
                args.Add(callExpr);
            }
            
            var newExpr = Expression.New(ctor, args);
            return Expression.Lambda<Func<IDataReader, T>>(newExpr, readerParam).Compile();
        }
        
        private static System.Reflection.MethodInfo GetReaderMethod(Type type)
        {
            var methodName = type.Name switch
            {
                "Int32" => "GetInt32",
                "Int64" => "GetInt64",
                "String" => "GetString",
                "Boolean" => "GetBoolean",
                "DateTime" => "GetDateTime",
                "Decimal" => "GetDecimal",
                "Double" => "GetDouble",
                "Single" => "GetFloat",
                "Guid" => "GetGuid",
                _ => "GetValue"
            };
            return typeof(IDataReader).GetMethod(methodName, new[] { typeof(int) })!;
        }
        
        public T Read(IDataReader reader) => _readFunc(reader);
        
        public T Read(IDataReader reader, int[] ordinals)
        {
            // 简化：直接调用 Read，因为我们在编译时已经知道列的顺序
            return _readFunc(reader);
        }
        
        public int[] GetOrdinals(IDataReader reader)
        {
            return new[] { reader.GetOrdinal("id"), reader.GetOrdinal("name") };
        }
    }
    
    // 命名类型的 ResultReader（最简单）
    internal sealed class UserIdName_ResultReader : IResultReader<UserIdName>
    {
        public UserIdName Read(IDataReader reader)
        {
            return new UserIdName
            {
                Id = reader.GetInt32(0),
                Name = reader.GetString(1)
            };
        }
        
        public UserIdName Read(IDataReader reader, int[] ordinals)
        {
            return new UserIdName
            {
                Id = reader.GetInt32(ordinals[0]),
                Name = reader.GetString(ordinals[1])
            };
        }
        
        public int[] GetOrdinals(IDataReader reader)
        {
            return new[] { reader.GetOrdinal("id"), reader.GetOrdinal("name") };
        }
    }
}
```

**关键点：C# 匿名类型统一机制**

```csharp
// 这两个匿名类型会被编译器统一为同一个类型
var obj1 = new { Id = 1, Name = "test" };
var obj2 = new { Id = 2, Name = "test2" };

// typeof(obj1) == typeof(obj2)  // true
// 它们的类型都是 <>f__AnonymousType0<int, string>

// 因此，源生成器只需要生成相同结构的匿名类型
// 编译器会自动将它们统一为同一个类型
```

**推荐使用方案 2（最简单）：**

```csharp
public T Read(IDataReader reader)
{
    // 直接创建匿名类型，编译器会处理类型统一
    return (T)(object)new
    {
        Id = reader.GetInt32(0),
        Name = reader.GetString(1)
    };
}
```

这个方案：
- ✅ 完全 AOT 兼容（无反射调用）
- ✅ 利用 C# 编译器的匿名类型统一机制
- ✅ 代码简单清晰
- ✅ 性能优秀（只有一次装箱/拆箱）
```

#### 4. ModuleInitializer 自动注册

```csharp
// Generated/SelectProjections.ModuleInit.g.cs
// <auto-generated/>
#nullable enable

namespace Sqlx.Generated
{
    using System.Runtime.CompilerServices;
    
    internal static class SelectProjectionsInitializer
    {
        [ModuleInitializer]
        internal static void Initialize()
        {
            // 自动注册所有生成的 ResultReader
            // 匿名类型
            SelectResultReader<<>f__AnonymousType0<int, string>>.Instance = 
                new AnonymousType_User_Id_Name_ResultReader<<>f__AnonymousType0<int, string>>();
            
            // 命名类型
            SelectResultReader<UserIdName>.Instance = new UserIdName_ResultReader();
            
            // ... 其他投影类型
        }
    }
}
```

#### 5. Interceptor 拦截 Select 调用

```csharp
// Generated/SelectInterceptors.g.cs
// <auto-generated/>
#nullable enable

using System;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;

namespace Sqlx.Generated
{
    internal static class SelectInterceptors
    {
        // 拦截第一个 Select 调用
        [InterceptsLocation("Program.cs", line: 10, character: 5)]
        public static IQueryable<TResult> Select_Intercepted_1<TSource, TResult>(
            this IQueryable<TSource> source,
            Expression<Func<TSource, TResult>> selector)
        {
            // 获取 SqlxQueryProvider
            if (source is not SqlxQueryable<TSource> sqlxQuery)
                return source.Select(selector);
            
            var provider = sqlxQuery.Provider as SqlxQueryProvider<TSource>;
            if (provider == null)
                return source.Select(selector);
            
            // 从泛型静态缓存获取 ResultReader
            var reader = SelectResultReader<TResult>.Instance;
            
            // 创建新的 Provider 并注入 ResultReader
            var newProvider = new SqlxQueryProvider<TResult>(provider.Dialect)
            {
                Connection = provider.Connection,
                ResultReader = reader  // 自动注入
            };
            
            // 构建新的表达式树
            var selectMethod = typeof(Queryable).GetMethods()
                .First(m => m.Name == "Select" && m.GetParameters().Length == 2);
            var genericMethod = selectMethod.MakeGenericMethod(typeof(TSource), typeof(TResult));
            var newExpression = Expression.Call(
                null,
                genericMethod,
                source.Expression,
                Expression.Quote(selector));
            
            return new SqlxQueryable<TResult>(newProvider, newExpression);
        }
        
        // 拦截第二个 Select 调用
        [InterceptsLocation("UserService.cs", line: 25, character: 9)]
        public static IQueryable<TResult> Select_Intercepted_2<TSource, TResult>(
            this IQueryable<TSource> source,
            Expression<Func<TSource, TResult>> selector)
        {
            // 同上...
        }
        
        // ... 为每个 Select 调用生成一个拦截器
    }
}
```

#### 6. SqlxQueryProvider 使用缓存

```csharp
// src/Sqlx/SqlxQueryProvider.cs
public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
{
    // 优先检查泛型静态缓存
    var reader = SelectResultReader<TElement>.Instance;
    
    if (typeof(TElement) == typeof(T))
    {
        var typedReader = ResultReader as IResultReader<TElement>;
        return new SqlxQueryable<TElement>(
            this as SqlxQueryProvider<TElement> ?? throw new InvalidOperationException(), 
            expression, 
            Connection, 
            typedReader ?? reader);
    }
    
    // 创建新的 Provider
    var newProvider = new SqlxQueryProvider<TElement>(Dialect)
    {
        Connection = Connection,
        ResultReader = reader  // 使用缓存的 Reader
    };
    
    return new SqlxQueryable<TElement>(newProvider, expression);
}
```

### 使用示例

```csharp
// 1. 匿名类型（自动支持）
var result = SqlQuery.ForSqlite<User>()
    .WithConnection(conn)
    .Select(u => new { u.Id, u.Name })  // 被拦截器拦截
    .ToList();
// 源生成器自动：
// - 生成 ResultReader
// - ModuleInitializer 注册
// - Interceptor 注入

// 2. 命名类型
public class UserIdName
{
    public int Id { get; set; }
    public string Name { get; set; }
}

var result = SqlQuery.ForSqlite<User>()
    .WithConnection(conn)
    .Select(u => new UserIdName { Id = u.Id, Name = u.Name })
    .ToList();

// 3. 复杂投影
var result = SqlQuery.ForSqlite<User>()
    .WithConnection(conn)
    .Select(u => new 
    { 
        u.Id, 
        u.Name,
        IsAdult = u.Age >= 18  // SQL 端计算
    })
    .ToList();
```

### 架构优势

1. **完全自动化**
   - 用户无需手动注册
   - 无需标记 `[SqlxProjection]`
   - 直接使用标准 LINQ Select

2. **零运行时开销**
   - ModuleInitializer 在模块加载时执行一次
   - 泛型静态缓存，无字典查找
   - Interceptor 在编译时注入代码

3. **完全 AOT 兼容**
   - 无反射
   - 无动态代码生成
   - 所有代码都是编译时生成

4. **类型安全**
   - 编译时检查
   - 完整的 IntelliSense 支持

5. **无重复代码**
   - 复用 `ExpressionParser` 提取列信息
   - 复用 `ColumnMeta` 结构
   - 复用 `IResultReader<T>` 接口

### 实现步骤

#### 阶段 1：基础设施

1. **添加 `SelectResultReader<T>` 泛型静态类**
   ```csharp
   // src/Sqlx/SelectResultReader.cs
   public static class SelectResultReader<T> { ... }
   ```

2. **修改 `SqlxQueryProvider.CreateQuery`**
   ```csharp
   // 检查 SelectResultReader<TElement>.Instance
   ```

#### 阶段 2：源生成器

1. **创建 `SelectInterceptorGenerator`**
   - 检测所有 Select 调用
   - 提取投影类型和列信息
   - 生成唯一的 ResultReader 类

2. **生成 ResultReader 实现**
   - 匿名类型：使用 `Unsafe.As` 转换
   - 命名类型：直接构造

3. **生成 ModuleInitializer**
   - 注册所有 ResultReader 到泛型静态缓存

4. **生成 Interceptor**
   - 为每个 Select 调用生成拦截器
   - 自动注入 ResultReader

#### 阶段 3：优化

1. **去重**
   - 相同投影类型只生成一个 ResultReader
   - 使用类型签名作为键

2. **错误处理**
   - 不支持的投影类型给出友好提示
   - 列不存在时的诊断信息

3. **性能优化**
   - 缓存列序号
   - 使用 ArrayPool 减少分配

### 性能对比

| 特性 | 手动注册 | ModuleInitializer | 差异 |
|------|---------|------------------|------|
| 初始化时机 | 应用启动 | 模块加载 | 更早 |
| 注册开销 | 手动调用 | 自动执行 | 零开销 |
| 运行时查找 | 直接访问 | 直接访问 | 相同 |
| 代码复杂度 | 需要手动 | 完全自动 | 更简单 |

### 与 EntityProvider 的统一

```csharp
// 之前：partial 类 + 静态构造函数
[SqlxEntity]
partial class User
{
    static User()
    {
        SqlQuery<User>.EntityProvider = UserEntityProvider.Default;
    }
}

// 现在：ModuleInitializer 统一注册
[ModuleInitializer]
internal static void Initialize()
{
    // 注册 EntityProvider
    SqlQuery<User>.EntityProvider = UserEntityProvider.Default;
    SqlQuery<Order>.EntityProvider = OrderEntityProvider.Default;
    
    // 注册 SelectResultReader
    SelectResultReader<UserIdName>.Instance = new UserIdName_ResultReader();
    SelectResultReader<<>f__AnonymousType0<int, string>>.Instance = 
        new AnonymousType_User_Id_Name_ResultReader<<>f__AnonymousType0<int, string>>();
}
```

### 结论

**使用 Interceptor + ModuleInitializer 的优势：**

1. ✅ **用户体验最佳** - 无需任何配置，直接使用标准 LINQ
2. ✅ **性能最优** - 编译时生成，零运行时开销
3. ✅ **完全 AOT 兼容** - 无反射，无动态代码
4. ✅ **统一架构** - EntityProvider 和 SelectResultReader 都用 ModuleInitializer
5. ✅ **类型安全** - 编译时检查，完整 IntelliSense

**实现优先级：**
1. ✅ 添加 `SelectResultReader<T>` 基础设施
2. ✅ 创建 `SelectInterceptorGenerator` 源生成器
3. ✅ 生成 ResultReader 实现
4. ✅ 生成 ModuleInitializer 注册代码
5. ✅ 生成 Interceptor 拦截代码
6. ✅ 修改现有 EntityProvider 使用 ModuleInitializer
```




