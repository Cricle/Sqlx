// -----------------------------------------------------------------------
// <copyright file="MethodGenerationTupleReturnTests.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;

namespace Sqlx.Tests.Core;

[TestClass]
public class MethodGenerationTupleReturnTests
{
    [TestMethod]
    public void Generated_Method_Returns_Tuple_Uses_GetDataReadExpression()
    {
        var source = @"using System.Data.Common; using Sqlx.Annotations; using System.Threading.Tasks;
namespace TNS {
  public class User { public int Id {get;set;} public string Name {get;set;} = string.Empty; }
  [RepositoryFor(typeof(IRepo))]
  public partial class Repo : IRepo { private readonly DbConnection connection; public Repo(DbConnection c){connection=c;} }
  public interface IRepo {
    [RawSql(""SELECT Id, Name FROM Users"")] Task<(int id, string name)> GetPairAsync();
  }
}";

        var code = Generate(source);
        // Expect generator to handle gracefully (either full mapping or fallback)
        StringAssert.Contains(code, "GetPairAsync");
        Assert.IsTrue(
            code.Contains("Task.FromResult<(int id, string name)>(default)") ||
            code.Contains("Generation failed")
        );
    }

    private static string Generate(string source)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);
        var references = new List<MetadataReference>
        {
            MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(System.Data.Common.DbConnection).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(System.Threading.Tasks.Task).Assembly.Location)
        };

        var compilation = CSharpCompilation.Create(
            "GenTupleAsm",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        var generator = new CSharpGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnostics);

        var generated = new List<string>();
        foreach (var tree in newCompilation.SyntaxTrees)
        {
            var text = tree.ToString();
            if (text.Contains("// <auto-generated>") || string.IsNullOrEmpty(tree.FilePath))
            {
                generated.Add(text);
            }
        }
        return string.Join("\n", generated);
    }
}


