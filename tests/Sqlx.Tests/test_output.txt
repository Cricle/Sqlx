C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\bin\Debug\net6.0\Sqlx.Tests.dll (.NETCoreApp,Version=v6.0)鐨勬祴璇曡繍琛?
VSTest 鐗堟湰 17.14.1 (x64)

姝ｅ湪鍚姩娴嬭瘯鎵ц锛岃绋嶅€?..
鎬诲叡 1 涓祴璇曟枃浠朵笌鎸囧畾妯″紡鐩稿尮閰嶃€?
C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\bin\Debug\net8.0\Sqlx.Tests.dll (.NETCoreApp,Version=v8.0)鐨勬祴璇曡繍琛?
VSTest 鐗堟湰 17.14.1 (x64)

姝ｅ湪鍚姩娴嬭瘯鎵ц锛岃绋嶅€?..
鎬诲叡 1 涓祴璇曟枃浠朵笌鎸囧畾妯″紡鐩稿尮閰嶃€?
  宸查€氳繃 ScalarResult [2 s]
  宸查€氳繃 MapResultSetToProcedure [270 ms]
  宸查€氳繃 MapSingleObjectToProcedureFromDbContext [218 ms]
  宸查€氳繃 MapSingleObjectToProcedureConnection [194 ms]
  宸查€氳繃 ScalarResult [3 s]
  宸查€氳繃 MapListFromDbContext [188 ms]
  宸查€氳繃 NoResults [231 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [93 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [68 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [91 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [98 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [99 ms]
  宸查€氳繃 BatchCommand_WithCollectionParameter_GeneratesCorrectCode [284 ms]
  宸查€氳繃 BatchCommand_AsyncMethod_GeneratesAsyncExecution [235 ms]
  宸查€氳繃 MapResultSetToProcedure [191 ms]
  宸查€氳繃 MapSingleObjectToProcedureFromDbContext [201 ms]
  宸查€氳繃 MapSingleObjectToProcedureConnection [208 ms]
  宸查€氳繃 MapListFromDbContext [164 ms]
  宸查€氳繃 NoResults [167 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [71 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [59 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [45 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [56 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [45 ms]
  宸查€氳繃 BatchCommand_WithCollectionParameter_GeneratesCorrectCode [178 ms]
  宸查€氳繃 BatchCommand_AsyncMethod_GeneratesAsyncExecution [183 ms]
  宸查€氳繃 BatchCommand_WithoutCollectionParameter_GeneratesError [178 ms]
  宸查€氳繃 BatchCommand_WithRawSql_GeneratesCorrectImplementation [176 ms]
  宸查€氳繃 BatchCommand_WithComplexEntity_HandlesAllProperties [144 ms]
  宸查€氳繃 BatchCommand_WithTransaction_IncludesTransactionHandling [135 ms]
  宸查€氳繃 BatchCommand_ReturnsCorrectType_BasedOnMethodSignature [128 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [42 ms]
  宸查€氳繃 BatchCommand_WithoutCollectionParameter_GeneratesError [261 ms]
  宸查€氳繃 BatchCommand_WithRawSql_GeneratesCorrectImplementation [222 ms]
  宸查€氳繃 BatchCommand_WithComplexEntity_HandlesAllProperties [298 ms]
  宸查€氳繃 BatchCommand_WithTransaction_IncludesTransactionHandling [224 ms]
  宸查€氳繃 BatchCommand_ReturnsCorrectType_BasedOnMethodSignature [212 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [93 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [67 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [87 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [40 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [48 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [42 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [42 ms]
  宸查€氳繃 ScalarResult [124 ms]
  宸查€氳繃 NoResults [164 ms]
  宸查€氳繃 MapResultSetToProcedure [114 ms]
  宸查€氳繃 MapListFromDbContext [133 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [39 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [38 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [39 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [53 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [40 ms]
  宸查€氳繃 CSharpGenerator_CanBeInstantiated [< 1 ms]
  宸查€氳繃 SourceGenerator_GeneratesBasicMethodImplementation [118 ms]
  宸查€氳繃 SourceGenerator_HandlesAsyncMethods [104 ms]
  宸查€氳繃 SourceGenerator_HandlesRepositoryPattern [115 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [39 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [73 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [84 ms]
  宸查€氳繃 ScalarResult [229 ms]
  宸查€氳繃 NoResults [213 ms]
  宸查€氳繃 MapResultSetToProcedure [225 ms]
  宸查€氳繃 MapListFromDbContext [213 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [95 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [75 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [82 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [38 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [54 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [38 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [49 ms]
  宸查€氳繃 ScalarResult [115 ms]
  宸查€氳繃 MapResultSetToProcedure [109 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [42 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [35 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [45 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [34 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [45 ms]
  宸查€氳繃 DbDataReaderResult [98 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [51 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [32 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [44 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [33 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [34 ms]
  宸查€氳繃 Debug_RepositoryFor_ShowGeneratedCode [43 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [78 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [97 ms]
  宸查€氳繃 CSharpGenerator_CanBeInstantiated [< 1 ms]
  宸查€氳繃 SourceGenerator_GeneratesBasicMethodImplementation [251 ms]
  宸查€氳繃 SourceGenerator_HandlesAsyncMethods [223 ms]
  宸查€氳繃 SourceGenerator_HandlesRepositoryPattern [228 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [74 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [100 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [68 ms]
  宸查€氳繃 EntityInference_SimpleReturnType_InfersCorrectly [33 ms]
  宸查€氳繃 EntityInference_GenericCollections_InfersCorrectly [127 ms]
  宸查€氳繃 EntityInference_AsyncReturnTypes_InfersCorrectly [32 ms]
  宸查€氳繃 EntityInference_MethodParameters_InfersCorrectly [45 ms]
  宸查€氳繃 EntityInference_InterfaceNameFallback_WorksCorrectly [31 ms]
  宸查€氳繃 EntityInference_SystemTypesFiltered_WorksCorrectly [45 ms]
  宸查€氳繃 EntityInference_MultipleCandidates_SelectsMostFrequent [35 ms]
  宸查€氳繃 EntityInference_NestedGenerics_HandlesCorrectly [39 ms]
  宸查€氳繃 EntityInference_EmptyInterface_HandlesGracefully [32 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [59 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [34 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [44 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [36 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [41 ms]
  宸查€氳繃 ExpressionToSql_ModuloOperator_GeneratesCorrectSql [96 ms]
  宸查€氳繃 ExpressionToSql_ArithmeticOperators_AllSupported [113 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_InComplexExpressions [88 ms]
  宸查€氳繃 ExpressionToSql_AllArithmeticOperators_GenerateCorrectSql [102 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [77 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [74 ms]
  宸查€氳繃 ScalarResult [239 ms]
  宸查€氳繃 MapResultSetToProcedure [216 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [101 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [71 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [87 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [69 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [81 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_WithDifferentDataTypes [96 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_InWhereAndOrderBy [108 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_WithConstants [108 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [42 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [57 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [32 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [43 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [32 ms]
  宸查€氳繃 ScalarResult [99 ms]
  宸茶烦杩?ScalarResultDbContext [34 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [32 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [49 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [33 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [47 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [31 ms]
  宸查€氳繃 Extensions_IsNullableType_WorksWithRealTypes [6 ms]
  宸查€氳繃 Extensions_GetDataReadExpression_GeneratesValidCode [5 ms]
  宸查€氳繃 Extensions_GetParameterName_GeneratesUniqueNames [9 ms]
  宸查€氳繃 Extensions_IsDbConnection_VariousSymbolTypes_WorksCorrectly [121 ms]
  宸查€氳繃 Extensions_IsDbTransaction_VariousSymbolTypes_WorksCorrectly [10 ms]
  宸查€氳繃 Extensions_IsDbContext_VariousSymbolTypes_WorksCorrectly [7 ms]
  宸查€氳繃 Extensions_IsCancellationToken_VariousSymbolTypes_WorksCorrectly [7 ms]
  宸查€氳繃 Extensions_UnwrapTaskType_VariousTypes_WorksCorrectly [6 ms]
  宸查€氳繃 Extensions_UnwrapListType_VariousTypes_WorksCorrectly [8 ms]
  宸查€氳繃 Extensions_UnwrapNullableType_VariousTypes_WorksCorrectly [6 ms]
  宸查€氳繃 Extensions_IsScalarType_VariousTypes_WorksCorrectly [12 ms]
  宸查€氳繃 Extensions_IsTuple_VariousTypes_WorksCorrectly [11 ms]
  宸查€氳繃 DbDataReaderResult [237 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [76 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [86 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [68 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [93 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [76 ms]
  宸查€氳繃 Debug_RepositoryFor_ShowGeneratedCode [81 ms]
  宸查€氳繃 EntityInference_SimpleReturnType_InfersCorrectly [66 ms]
  宸查€氳繃 EntityInference_GenericCollections_InfersCorrectly [83 ms]
  宸查€氳繃 Extensions_GetSqlName_VariousTypes_WorksCorrectly [4 ms]
  宸查€氳繃 Extensions_IsTypes_VariousSymbolTypes_WorksCorrectly [3 ms]
  宸查€氳繃 Extensions_CanHaveNullValue_NullableTypes_WorksCorrectly [10 ms]
  宸查€氳繃 Extensions_IsNullableType_NullableTypes_WorksCorrectly [8 ms]
  宸查€氳繃 Extensions_GetDataReadExpression_VariousTypes_WorksCorrectly [12 ms]
  宸查€氳繃 Extensions_GetDataReaderMethod_VariousTypes_WorksCorrectly [8 ms]
  宸查€氳繃 Extensions_GetParameterName_VariousTypes_WorksCorrectly [12 ms]
  宸查€氳繃 Extensions_GetParameterName_DifferentTypes_GeneratesUniqueNames [9 ms]
  宸查€氳繃 Extensions_GetParameterName_SpecialCharacters_HandlesCorrectly [8 ms]
  宸查€氳繃 Extensions_GetParameterName_EmptyAndNullInputs_HandlesCorrectly [4 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [33 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [40 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [31 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [29 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [39 ms]
  宸查€氳繃 GenericRepository_BasicInterface_GeneratesImplementation [140 ms]
  宸查€氳繃 GenericRepository_MultipleTypeParameters_GeneratesImplementation [97 ms]
  宸查€氳繃 GenericRepository_SqlExecuteTypeAttributes_GeneratesCorrectSql [90 ms]
  宸查€氳繃 EntityInference_AsyncReturnTypes_InfersCorrectly [104 ms]
  宸查€氳繃 EntityInference_MethodParameters_InfersCorrectly [72 ms]
  宸查€氳繃 EntityInference_InterfaceNameFallback_WorksCorrectly [77 ms]
  宸查€氳繃 EntityInference_SystemTypesFiltered_WorksCorrectly [67 ms]
  宸查€氳繃 EntityInference_MultipleCandidates_SelectsMostFrequent [82 ms]
  宸查€氳繃 EntityInference_NestedGenerics_HandlesCorrectly [67 ms]
  宸查€氳繃 EntityInference_EmptyInterface_HandlesGracefully [82 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [70 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [82 ms]
  宸查€氳繃 GenericRepository_InterfaceInheritance_GeneratesImplementation [173 ms]
  宸查€氳繃 GenericRepository_GenericConstraints_HandledCorrectly [112 ms]
  宸查€氳繃 GenericRepository_NullableReferenceTypes_HandledCorrectly [95 ms]
  宸查€氳繃 GenericRepository_AsyncMethods_GeneratedCorrectly [119 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [31 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [37 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [29 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [39 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [31 ms]
  宸查€氳繃 GetOrdinalCaching_ListReturnType_GeneratesCachedOrdinals [116 ms]
  宸查€氳繃 GetOrdinalCaching_TupleReturnType_GeneratesCachedOrdinals [101 ms]
  宸查€氳繃 GetOrdinalCaching_ScalarReturnType_GeneratesCachedOrdinal [89 ms]
  宸查€氳繃 GetOrdinalCaching_DefaultColumnNames_GeneratesCachedOrdinals [110 ms]
  宸查€氳繃 GetOrdinalCaching_SingleResult_GeneratesCaching [95 ms]
  宸查€氳繃 GetOrdinalCaching_PerformanceCharacteristics_CorrectPattern [122 ms]
  宸查€氳繃 GetOrdinalCaching_IEnumerableReturnType_GeneratesCachedOrdinals [97 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [38 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [31 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [79 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [86 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [99 ms]
  宸查€氳繃 ExpressionToSql_ModuloOperator_GeneratesCorrectSql [212 ms]
  宸查€氳繃 ExpressionToSql_ArithmeticOperators_AllSupported [277 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_InComplexExpressions [211 ms]
  宸查€氳繃 ExpressionToSql_AllArithmeticOperators_GenerateCorrectSql [209 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_WithDifferentDataTypes [189 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [44 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [38 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [49 ms]
  宸查€氳繃 SELECT_WithExpressionToSql_GeneratesCorrectly [94 ms]
  宸查€氳繃 SELECT_WithoutParameters_GeneratesCorrectly [103 ms]
  宸查€氳繃 INSERT_WithEntity_GeneratesCorrectly [112 ms]
  宸查€氳繃 UPDATE_WithExpressionToSql_GeneratesCorrectly [96 ms]
  宸查€氳繃 DELETE_WithExpressionToSql_GeneratesCorrectly [98 ms]
  宸查€氳繃 CRUD_WithMultipleParameters_HandlesCorrectly [88 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_InWhereAndOrderBy [173 ms]
  宸查€氳繃 ExpressionToSql_ModOperator_WithConstants [190 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [64 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [53 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [61 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [47 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [72 ms]
  宸查€氳繃 ScalarResult [160 ms]
  宸茶烦杩?ScalarResultDbContext [9 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [38 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [32 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [59 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [31 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [43 ms]
  宸查€氳繃 SystemParameters_AreIdentifiedCorrectly [< 1 ms]
  宸查€氳繃 Constructor_EmptyString_InitializesCorrectly [< 1 ms]
  宸查€氳繃 Constructor_WithContent_PreservesContent [< 1 ms]
  宸查€氳繃 Append_WithoutIndent_AppendsDirectly [< 1 ms]
  宸查€氳繃 Append_WithCurrentIndent_AppendsWithIndentation [< 1 ms]
  宸查€氳繃 AppendLine_WithContent_AppendsLineWithNewline [< 1 ms]
  宸查€氳繃 AppendLine_Empty_AppendsNewlineOnly [< 1 ms]
  宸查€氳繃 Append_Char_AppendsCharacterWithIndentation [< 1 ms]
  宸查€氳繃 AppendLineIf_TrueCondition_AppendsTrueValue [< 1 ms]
  宸查€氳繃 AppendLineIf_FalseCondition_AppendsFalseValue [< 1 ms]
  宸查€氳繃 PopIndent_AtDepthZero_ThrowsInvalidOperationException [< 1 ms]
  宸查€氳繃 PopIndent_AfterPushIndent_ReducesIndentation [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_MultipleIndentationLevels_WorkCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationAppliedToAllAppendOperations [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationNotAppliedToEmptyStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationNotAppliedToWhitespaceOnlyStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithMixedContent [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithSpecialCharacters [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithUnicodeCharacters [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithVeryLongStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithNullStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithNullCharacters [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStrings_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLine_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIf_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIfFalse_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIfBothNull_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIfBothNullFalse_Gracefully [< 1 ms]
  宸查€氳繃 IncreaseIndent_IncreasesIndentationLevel [< 1 ms]
  宸查€氳繃 DecreaseIndent_DecreasesIndentationLevel [< 1 ms]
  宸查€氳繃 NestedIndentation_ProducesCorrectIndents [< 1 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [79 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [52 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [62 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [48 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [60 ms]
  宸查€氳繃 Extensions_IsNullableType_WorksWithRealTypes [8 ms]
  宸查€氳繃 Extensions_GetDataReadExpression_GeneratesValidCode [7 ms]
  宸查€氳繃 Extensions_GetParameterName_GeneratesUniqueNames [9 ms]
  宸查€氳繃 Extensions_IsDbConnection_VariousSymbolTypes_WorksCorrectly [107 ms]
  宸查€氳繃 DbConectionCanJoinTransactions [106 ms]
  宸查€氳繃 DbContextCanJoinTransactions [93 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [44 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [30 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [40 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [31 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [51 ms]
  宸查€氳繃 RecommendedApproach_TestStaticMethods_DirectTesting [< 1 ms]
  宸查€氳繃 RecommendedApproach_TestConcreteClasses_DirectInstantiation [< 1 ms]
  宸查€氳繃 Extensions_IsDbTransaction_VariousSymbolTypes_WorksCorrectly [12 ms]
  宸查€氳繃 Extensions_IsDbContext_VariousSymbolTypes_WorksCorrectly [10 ms]
  宸查€氳繃 Extensions_IsCancellationToken_VariousSymbolTypes_WorksCorrectly [10 ms]
  宸查€氳繃 Extensions_UnwrapTaskType_VariousTypes_WorksCorrectly [10 ms]
  宸查€氳繃 Extensions_UnwrapListType_VariousTypes_WorksCorrectly [11 ms]
  宸查€氳繃 Extensions_UnwrapNullableType_VariousTypes_WorksCorrectly [11 ms]
  宸查€氳繃 Extensions_IsScalarType_VariousTypes_WorksCorrectly [17 ms]
  宸查€氳繃 Extensions_IsTuple_VariousTypes_WorksCorrectly [15 ms]
  宸查€氳繃 Extensions_GetSqlName_VariousTypes_WorksCorrectly [5 ms]
  宸查€氳繃 RecommendedApproach_TestValueObjects_DirectComparison [< 1 ms]
  宸查€氳繃 LimitedRecommendation_SimpleMock_ForSimpleInterfaces [40 ms]
  宸查€氳繃 NotRecommended_ComplexMocking_ExplanationOnly [< 1 ms]
  宸查€氳繃 AlternativeApproach_TestCoreLogic_WithoutComplexMocking [< 1 ms]
  宸查€氳繃 Guidelines_WhenToUseMoq [< 1 ms]
  宸查€氳繃 UseTestData_InsteadOfMocking [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("PersonId","person_id") [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("FirstName","first_name") [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("XMLHttpRequest","x_m_l_http_request") [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("ID","i_d") [< 1 ms]
  宸查€氳繃 UseHelperMethods_ToBuildTestData [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("personId","person_id") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("name","name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("Name","name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("PersonId","person_id") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("","") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("a","a") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("A","a") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("userName","user_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("UserName","user_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("firstName","first_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("FirstName","first_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("lastName","last_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("LastName","last_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("emailAddress","email_address") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("EmailAddress","email_address") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("phoneNumber","phone_number") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("PhoneNumber","phone_number") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("isActive","is_active") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("IsActive","is_active") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("hasPermission","has_permission") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("HasPermission","has_permission") [< 1 ms]
  宸查€氳繃 MapName_SingleUppercaseLetter_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_SingleLowercaseLetter_ReturnsSame [< 1 ms]
  宸查€氳繃 MapName_EmptyString_ReturnsEmptyString [< 1 ms]
  宸查€氳繃 MapName_ComplexCamelCase_ReturnsCorrectFormat [< 1 ms]
  宸查€氳繃 MapName_WithNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_ConsecutiveUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_AllUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_MixedCaseAndNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithUnderscores_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithHyphens_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithSpaces_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_LeadingUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_TrailingUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_SingleUppercaseInMiddle_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_MultipleConsecutiveUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_NumbersAtBeginning_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_NumbersAtEnd_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_MixedCaseAndSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_OnlyNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_OnlySpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException [< 1 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException_Alternative [1 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException_TryCatch [< 1 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException_AssertThrows [< 1 ms]
  宸查€氳繃 GeneratedCode_SupportsNullableReferenceTypes [< 1 ms]
  宸查€氳繃 GeneratedCode_HandlesNullableValueTypes [< 1 ms]
  宸查€氳繃 GeneratedCode_EnforcesNonNullableTypes [< 1 ms]
  宸查€氳繃 GeneratedCode_HandlesDatabaseNulls [< 1 ms]
  宸查€氳繃 GeneratedCode_HandlesStringNulls [< 1 ms]
  澶辫触 PrimaryConstructor_BasicClass_GeneratesCorrectCode [108 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for primary constructor
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.PrimaryConstructor_BasicClass_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 54

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class ProductRepository : TestNamespace.IProductService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllProducts using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Product entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Product> GetAllProducts()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Product>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllProducts", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Product>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Price = reader.GetOrdinal("Price");
                     var entity = new TestNamespace.Product(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.GetDecimal(reader.GetOrdinal("Price"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Product>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllProducts", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllProducts", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertProduct using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="product">The Product entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "products")]
         public int InsertProduct(TestNamespace.Product product)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [products] ([name], [price]) VALUES (@name, @price)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = (object?)product.Name ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramPrice = __cmd__.CreateParameter();
                 paramPrice.ParameterName = "@price";
                 paramPrice.DbType = global::System.Data.DbType.Decimal;
                 paramPrice.Value = product.Price;
                 __cmd__.Parameters.Add(paramPrice);
 
                 OnExecuting("InsertProduct", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertProduct", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertProduct", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Product has 0 attributes:
 No RepositoryFor attribute found on Product
 Class ProductRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on ProductRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  宸查€氳繃 Extensions_IsTypes_VariousSymbolTypes_WorksCorrectly [5 ms]
  宸查€氳繃 Extensions_CanHaveNullValue_NullableTypes_WorksCorrectly [12 ms]
  宸查€氳繃 Extensions_IsNullableType_NullableTypes_WorksCorrectly [36 ms]
  宸查€氳繃 Extensions_GetDataReadExpression_VariousTypes_WorksCorrectly [18 ms]
  宸查€氳繃 Extensions_GetDataReaderMethod_VariousTypes_WorksCorrectly [12 ms]
  宸查€氳繃 Extensions_GetParameterName_VariousTypes_WorksCorrectly [16 ms]
  宸查€氳繃 Extensions_GetParameterName_DifferentTypes_GeneratesUniqueNames [10 ms]
  宸查€氳繃 Extensions_GetParameterName_SpecialCharacters_HandlesCorrectly [6 ms]
  宸查€氳繃 Extensions_GetParameterName_EmptyAndNullInputs_HandlesCorrectly [5 ms]
  澶辫触 Record_BasicRecord_GeneratesCorrectCode [107 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for record
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.Record_BasicRecord_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 94

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class UserRepository : TestNamespace.IUserService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllUsers using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of User entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.User> GetAllUsers()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.User>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllUsers", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.User>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Email = reader.GetOrdinal("Email");
                     var entity = new TestNamespace.User(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.IsDBNull(reader.GetOrdinal("Email")) ? string.Empty : reader.GetString(reader.GetOrdinal("Email"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.User>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllUsers", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllUsers", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertUser using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="user">The User entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "users")]
         public int InsertUser(TestNamespace.User user)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [users] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = (object?)user.Name ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = (object?)user.Email ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("InsertUser", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertUser", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertUser", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class UserRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on UserRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  澶辫触 RecordWithAdditionalProperties_GeneratesCorrectCode [91 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for record
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.RecordWithAdditionalProperties_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 138

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class ProductRepository : TestNamespace.IProductService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllProducts using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Product entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Product> GetAllProducts()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Product>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllProducts", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Product>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Price = reader.GetOrdinal("Price");
                     int __ordinal_Description = reader.GetOrdinal("Description");
                     int __ordinal_IsActive = reader.GetOrdinal("IsActive");
                     var entity = new TestNamespace.Product(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.GetDecimal(reader.GetOrdinal("Price"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Product>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllProducts", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllProducts", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertProduct using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="product">The Product entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "products")]
         public int InsertProduct(TestNamespace.Product product)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [products] ([name], [price], [description], [is_active]) VALUES (@name, @price, @description, @is_active)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = (object?)product.Name ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramPrice = __cmd__.CreateParameter();
                 paramPrice.ParameterName = "@price";
                 paramPrice.DbType = global::System.Data.DbType.Decimal;
                 paramPrice.Value = product.Price;
                 __cmd__.Parameters.Add(paramPrice);
 
                 var paramDescription = __cmd__.CreateParameter();
                 paramDescription.ParameterName = "@description";
                 paramDescription.DbType = global::System.Data.DbType.String;
                 paramDescription.Value = (object?)product.Description ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramDescription);
 
                 var paramIsActive = __cmd__.CreateParameter();
                 paramIsActive.ParameterName = "@is_active";
                 paramIsActive.DbType = global::System.Data.DbType.Boolean;
                 paramIsActive.Value = product.IsActive;
                 __cmd__.Parameters.Add(paramIsActive);
 
                 OnExecuting("InsertProduct", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertProduct", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertProduct", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class ProductRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on ProductRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  宸查€氳繃 BatchCommand_WithRecord_GeneratesCorrectCode [101 ms]
  澶辫触 PrimaryConstructor_WithPartialProperties_GeneratesCorrectCode [82 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for primary constructor
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.PrimaryConstructor_WithPartialProperties_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 222

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class OrderRepository : TestNamespace.IOrderService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllOrders using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Order entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Order> GetAllOrders()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Order>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllOrders", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Order>();
 
                 while (reader.Read())
                 {
                     int __ordinal_OrderDate = reader.GetOrdinal("OrderDate");
                     int __ordinal_TotalAmount = reader.GetOrdinal("TotalAmount");
                     int __ordinal_OrderId = reader.GetOrdinal("OrderId");
                     int __ordinal_CustomerName = reader.GetOrdinal("CustomerName");
                     var entity = new TestNamespace.Order(
                         reader.GetInt32(reader.GetOrdinal("OrderId")),
                         reader.IsDBNull(reader.GetOrdinal("CustomerName")) ? string.Empty : reader.GetString(reader.GetOrdinal("CustomerName"))
                     );
                     entity.OrderDate = reader.GetDateTime(reader.GetOrdinal("OrderDate"));
                     entity.TotalAmount = reader.GetDecimal(reader.GetOrdinal("TotalAmount"));
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Order>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllOrders", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllOrders", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertOrder using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="order">The Order entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "orders")]
         public int InsertOrder(TestNamespace.Order order)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [orders] ([order_date], [total_amount], [order_id], [customer_name]) VALUES (@order_date, @total_amount, @order_id, @customer_name)";
 
                 var paramOrderDate = __cmd__.CreateParameter();
                 paramOrderDate.ParameterName = "@order_date";
                 paramOrderDate.DbType = global::System.Data.DbType.DateTime;
                 paramOrderDate.Value = order.OrderDate;
                 __cmd__.Parameters.Add(paramOrderDate);
 
                 var paramTotalAmount = __cmd__.CreateParameter();
                 paramTotalAmount.ParameterName = "@total_amount";
                 paramTotalAmount.DbType = global::System.Data.DbType.Decimal;
                 paramTotalAmount.Value = order.TotalAmount;
                 __cmd__.Parameters.Add(paramTotalAmount);
 
                 var paramOrderId = __cmd__.CreateParameter();
                 paramOrderId.ParameterName = "@order_id";
                 paramOrderId.DbType = global::System.Data.DbType.Int32;
                 paramOrderId.Value = order.OrderId;
                 __cmd__.Parameters.Add(paramOrderId);
 
                 var paramCustomerName = __cmd__.CreateParameter();
                 paramCustomerName.ParameterName = "@customer_name";
                 paramCustomerName.DbType = global::System.Data.DbType.String;
                 paramCustomerName.Value = (object?)order.CustomerName ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramCustomerName);
 
                 OnExecuting("InsertOrder", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertOrder", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertOrder", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Order has 0 attributes:
 No RepositoryFor attribute found on Order
 Class OrderRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on OrderRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  澶辫触 MixedClassTypes_GeneratesCorrectCode [120 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for modern types
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.MixedClassTypes_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 284

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class MixedRepository : TestNamespace.IMixedService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetCategories using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Category entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Category> GetCategories()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Category>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetCategories", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Category>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     var entity = new TestNamespace.Category
                     {
                         Id = reader.GetInt32(reader.GetOrdinal("Id")),
                         Name = reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name"))
                     };
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Category>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetCategories", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetCategories", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetProducts using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Product entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Product> GetProducts()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Product>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetProducts", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Product>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Price = reader.GetOrdinal("Price");
                     int __ordinal_CategoryId = reader.GetOrdinal("CategoryId");
                     var entity = new TestNamespace.Product(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.GetDecimal(reader.GetOrdinal("Price")),
                         reader.GetInt32(reader.GetOrdinal("CategoryId"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Product>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetProducts", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetProducts", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetOrders using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Order entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Order> GetOrders()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Order>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetOrders", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Order>();
 
                 while (reader.Read())
                 {
                     int __ordinal_OrderDate = reader.GetOrdinal("OrderDate");
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_CustomerName = reader.GetOrdinal("CustomerName");
                     var entity = new TestNamespace.Order(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("CustomerName")) ? string.Empty : reader.GetString(reader.GetOrdinal("CustomerName"))
                     );
                     entity.OrderDate = reader.GetDateTime(reader.GetOrdinal("OrderDate"));
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Order>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetOrders", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetOrders", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Category has 0 attributes:
 No RepositoryFor attribute found on Category
 Class Order has 0 attributes:
 No RepositoryFor attribute found on Order
 Class MixedRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on MixedRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [33 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [42 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [35 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [43 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [46 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [50 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [64 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [46 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [55 ms]
  宸查€氳繃 GenericRepository_BasicInterface_GeneratesImplementation [137 ms]
  宸查€氳繃 GenericRepository_MultipleTypeParameters_GeneratesImplementation [155 ms]
  宸查€氳繃 GenericRepository_SqlExecuteTypeAttributes_GeneratesCorrectSql [177 ms]
  宸查€氳繃 GenericRepository_InterfaceInheritance_GeneratesImplementation [138 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [35 ms]
  宸查€氳繃 EdgeCase_MissingServiceTypeParameter_HandlesGracefully [70 ms]
  宸查€氳繃 EdgeCase_NullServiceType_HandlesGracefully [68 ms]
  宸查€氳繃 EdgeCase_AbstractClassServiceType_IsSkipped [101 ms]
  宸查€氳繃 EdgeCase_ConcreteClassServiceType_IsSkipped [37 ms]
  宸查€氳繃 EdgeCase_GenericInterface_HandlesCorrectly [45 ms]
  宸查€氳繃 EdgeCase_NonEntityInterface_HandlesGracefully [31 ms]
  宸查€氳繃 EdgeCase_InheritedInterface_HandlesCorrectly [45 ms]
  宸查€氳繃 EdgeCase_LongMethodNamesAndParameters_HandlesCorrectly [32 ms]
  宸查€氳繃 EdgeCase_SpecialCharactersInNames_HandlesCorrectly [40 ms]
  宸查€氳繃 EdgeCase_GlobalNamespace_HandlesCorrectly [34 ms]
  宸查€氳繃 EdgeCase_MultipleRepositoryForAttributes_HandlesGracefully [61 ms]
  宸查€氳繃 EdgeCase_CircularReferences_HandlesGracefully [33 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [42 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [31 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [43 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [32 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [45 ms]
  宸查€氳繃 GenericRepository_GenericConstraints_HandledCorrectly [158 ms]
  宸查€氳繃 GenericRepository_NullableReferenceTypes_HandledCorrectly [148 ms]
  宸查€氳繃 GenericRepository_AsyncMethods_GeneratedCorrectly [138 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [68 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [44 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [63 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [53 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [54 ms]
  宸查€氳繃 GetOrdinalCaching_ListReturnType_GeneratesCachedOrdinals [137 ms]
  宸查€氳繃 RepositoryFor_BasicRepository_GeneratesImplementation [37 ms]
  宸查€氳繃 RepositoryFor_EntityTypeInference_FromReturnTypes [60 ms]
  宸查€氳繃 RepositoryFor_EntityTypeInference_FromInterfaceName [32 ms]
  宸查€氳繃 RepositoryFor_TableNameAttribute_IsRespected [34 ms]
  宸查€氳繃 RepositoryFor_AsyncMethods_AreHandled [39 ms]
  宸查€氳繃 RepositoryFor_MethodNamePatterns_GenerateCorrectAttributes [30 ms]
  宸查€氳繃 RepositoryFor_NonInterfaceServiceType_IsSkipped [41 ms]
  宸查€氳繃 RepositoryFor_SqlTemplateAttribute_IsSkipped [27 ms]
  宸查€氳繃 RepositoryFor_MissingAttribute_NoGeneration [38 ms]
  宸查€氳繃 RepositoryFor_InvalidParameters_HandledGracefully [26 ms]
  宸查€氳繃 RepositoryFor_ComplexGenericTypes_AreHandled [56 ms]
  宸查€氳繃 RepositoryFor_NullableReferenceTypes_AreHandled [30 ms]
  宸查€氳繃 RepositoryFor_MultipleRepositories_AreHandled [40 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [32 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [44 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [35 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [48 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [37 ms]
  宸查€氳繃 SourceGenerator_GeneratesValidCode_ForBasicSqlxAttribute [51 ms]
  宸查€氳繃 SourceGenerator_GeneratesSqlDefineConstants [20 ms]
  宸查€氳繃 SourceGenerator_GeneratesExpressionToSqlWithFactoryMethods [38 ms]
  宸查€氳繃 SourceGenerator_GeneratesCorrectImplementation_ForRawSqlAttribute [23 ms]
  宸查€氳繃 SourceGenerator_GeneratesCorrectDialectConstants ("MySql","`","`","@") [29 ms]
  宸查€氳繃 SourceGenerator_GeneratesCorrectDialectConstants ("SqlServer","[","]","@") [19 ms]
  宸查€氳繃 SourceGenerator_MissingAttributes_ReportsDiagnostic [21 ms]
  宸查€氳繃 SourceGenerator_NullSyntaxReceiver_HandlesGracefully [45 ms]
  宸查€氳繃 SourceGenerator_EmptyMethodList_HandlesGracefully [19 ms]
  宸查€氳繃 SourceGenerator_MissingSqlxAttribute_ReportsDiagnostic [33 ms]
  宸查€氳繃 SourceGenerator_MissingRawSqlAttribute_ReportsDiagnostic [21 ms]
  宸查€氳繃 SourceGenerator_MissingExpressionToSqlAttribute_ReportsDiagnostic [36 ms]
  宸查€氳繃 SourceGenerator_NullableContextOptions_HandlesCorrectly [19 ms]
  宸查€氳繃 SourceGenerator_ClassGrouping_HandlesCorrectly [34 ms]
  宸查€氳繃 AbstractGenerator_MissingSqlxAttribute_ReportsDiagnostic [19 ms]
  宸查€氳繃 AbstractGenerator_MissingRawSqlAttribute_ReportsDiagnostic [38 ms]
  宸查€氳繃 AbstractGenerator_MissingExpressionToSqlAttribute_ReportsDiagnostic [22 ms]
  宸查€氳繃 AbstractGenerator_NullableContextOptions_HandlesCorrectly [21 ms]
  宸查€氳繃 GetOrdinalCaching_TupleReturnType_GeneratesCachedOrdinals [130 ms]
  宸查€氳繃 GetOrdinalCaching_ScalarReturnType_GeneratesCachedOrdinal [232 ms]
  宸查€氳繃 GetOrdinalCaching_DefaultColumnNames_GeneratesCachedOrdinals [149 ms]
  宸查€氳繃 GetOrdinalCaching_SingleResult_GeneratesCaching [126 ms]
  宸查€氳繃 GetOrdinalCaching_PerformanceCharacteristics_CorrectPattern [139 ms]
  宸查€氳繃 GetOrdinalCaching_IEnumerableReturnType_GeneratesCachedOrdinals [125 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [46 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [37 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [49 ms]
  宸查€氳繃 AbstractGenerator_EmptyMethodList_HandlesGracefully [28 ms]
  宸查€氳繃 AbstractGenerator_NullSyntaxReceiver_HandlesGracefully [20 ms]
  宸查€氳繃 SqlGeneration_GetAllMethods_GenerateSelectAll [43 ms]
  宸查€氳繃 SqlGeneration_GetByIdMethods_GenerateWhereId [32 ms]
  宸查€氳繃 SqlGeneration_CreateMethods_GenerateInsertExecuteType [43 ms]
  宸查€氳繃 SqlGeneration_UpdateMethods_GenerateUpdateExecuteType [33 ms]
  宸查€氳繃 SqlGeneration_DeleteMethods_GenerateDeleteExecuteType [62 ms]
  宸查€氳繃 SqlGeneration_CountMethods_GenerateCountQueries [27 ms]
  宸查€氳繃 SqlGeneration_ExistsMethods_GenerateExistsQueries [38 ms]
  宸查€氳繃 SqlGeneration_ComplexMethodNames_DefaultToSelect [29 ms]
  宸查€氳繃 SqlGeneration_TableNameResolution_WorksCorrectly [37 ms]
  宸查€氳繃 SqlGeneration_MethodBodies_IncludeNotImplementedException [28 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [42 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [30 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [60 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [33 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [41 ms]
  宸查€氳繃 SqlDefine_GeneratesCorrectConstants [84 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [41 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [74 ms]
  宸查€氳繃 SELECT_WithExpressionToSql_GeneratesCorrectly [121 ms]
  宸查€氳繃 SELECT_WithoutParameters_GeneratesCorrectly [130 ms]
  宸查€氳繃 INSERT_WithEntity_GeneratesCorrectly [151 ms]
  宸查€氳繃 UPDATE_WithExpressionToSql_GeneratesCorrectly [122 ms]
  宸查€氳繃 DELETE_WithExpressionToSql_GeneratesCorrectly [141 ms]
  宸查€氳繃 CRUD_WithMultipleParameters_HandlesCorrectly [121 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [39 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [46 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [38 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [67 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [38 ms]
  宸查€氳繃 SystemParameters_AreIdentifiedCorrectly [< 1 ms]
  宸查€氳繃 Constructor_EmptyString_InitializesCorrectly [< 1 ms]
  宸查€氳繃 Constructor_WithContent_PreservesContent [< 1 ms]
  宸查€氳繃 Append_WithoutIndent_AppendsDirectly [< 1 ms]
  宸查€氳繃 Append_WithCurrentIndent_AppendsWithIndentation [< 1 ms]
  宸查€氳繃 AppendLine_WithContent_AppendsLineWithNewline [< 1 ms]
  宸查€氳繃 AppendLine_Empty_AppendsNewlineOnly [< 1 ms]
  宸查€氳繃 Append_Char_AppendsCharacterWithIndentation [< 1 ms]
  宸查€氳繃 AppendLineIf_TrueCondition_AppendsTrueValue [< 1 ms]
  宸查€氳繃 AppendLineIf_FalseCondition_AppendsFalseValue [< 1 ms]
  宸查€氳繃 PopIndent_AtDepthZero_ThrowsInvalidOperationException [< 1 ms]
  宸查€氳繃 PopIndent_AfterPushIndent_ReducesIndentation [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_MultipleIndentationLevels_WorkCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationAppliedToAllAppendOperations [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationNotAppliedToEmptyStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationNotAppliedToWhitespaceOnlyStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithMixedContent [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithSpecialCharacters [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithUnicodeCharacters [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithVeryLongStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithNullStrings [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_IndentationWorksWithNullCharacters [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStrings_Gracefully [< 1 ms]
  宸查€氳繃 SqlDefine_MySql_HasCorrectValues [106 ms]
  宸查€氳繃 SqlDefine_SqlServer_HasCorrectValues [90 ms]
  宸查€氳繃 SqlDefine_PostgreSql_HasCorrectValues [95 ms]
  宸查€氳繃 SqlDefine_DialectConstants_HaveCorrectFormat ("MySql","`","`","@") [98 ms]
  宸查€氳繃 SqlDefine_DialectConstants_HaveCorrectFormat ("SqlServer","[","]","@") [94 ms]
  宸查€氳繃 SqlDefine_DialectConstants_HaveCorrectFormat ("PgSql","\"","\"","$") [85 ms]
  宸查€氳繃 SqlDefine_WrapString_WorksForAllDialects [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WorksForAllDialects [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithEmptyString_ReturnsQuotedEmptyString [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithEmptyString_ReturnsQuotedEmptyString [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectParameterCounts [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectParameterNames [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_AreImmutable [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectStringRepresentations [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_CanBeUsedInPatternMatching [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectEqualityBehavior [1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLine_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIf_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIfFalse_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIfBothNull_Gracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesNullStringsInAppendLineIfBothNullFalse_Gracefully [< 1 ms]
  宸查€氳繃 IncreaseIndent_IncreasesIndentationLevel [< 1 ms]
  宸查€氳繃 DecreaseIndent_DecreasesIndentationLevel [< 1 ms]
  宸查€氳繃 NestedIndentation_ProducesCorrectIndents [< 1 ms]
  宸查€氳繃 DbConectionCanJoinTransactions [122 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectHashCodeBehavior [< 1 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [42 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [30 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [41 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [31 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [45 ms]
  宸查€氳繃 SqlGenerator_BasicOperations_WorkCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_UtilityMethods_WorkCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParameterName_GeneratesCorrectly [< 1 ms]
  宸查€氳繃 SqlDefine_StaticInstances_AreConsistent [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_HasAllExpectedValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_HasCorrectNumericValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_StringConversion_WorksCorrectly [1 ms]
  宸查€氳繃 SqlGenerator_SupportsAllOperationTypes [2 ms]
  宸查€氳繃 SqlDefine_WrapColumn_GeneratesCorrectFormat [< 1 ms]
  宸查€氳繃 SqlDefine_ParameterPrefix_IsCorrect [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_ConvertsCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParameterName_GeneratesCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_HandlesEdgeCases [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_HasAllRequiredValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_CanParseFromString [< 1 ms]
  宸查€氳繃 GetColumnName_ConvertsCorrectly [< 1 ms]
  宸查€氳繃 GetParameterName_GeneratesCorrectly [< 1 ms]
  宸查€氳繃 GetColumnName_HandlesEdgeCases [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_EnumValues_Defined [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_GeneratesCorrectSyntax [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_ConvertsNamesCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParamterName_GeneratesCorrectParameterNames [< 1 ms]
  宸查€氳繃 SqlGenerator_Generate_NonInsertTypes_ReturnsEmptyString [< 1 ms]
  宸查€氳繃 ObjectMap_ListTypes_IdentifiedCorrectly [< 1 ms]
  宸查€氳繃 ObjectMap_NonListTypes_IdentifiedCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_UtilityMethods_WorkCorrectly [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_EnumValues_AreCorrect [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_VariousInputs_WorksCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParamterName_VariousInputs_WorksCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_WithIPropertySymbol_WorksCorrectly [< 1 ms]
  宸查€氳繃 InsertGenerateContext_GetParamterNames_WorksCorrectly [< 1 ms]
  宸查€氳繃 InsertGenerateContext_GetColumnNames_WorksCorrectly [< 1 ms]
  宸查€氳繃 ObjectMap_Constructor_VariousParameterTypes_WorksCorrectly [< 1 ms]
  宸查€氳繃 ObjectMap_Properties_AreAccessible [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasGenerateMethod [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectMethodSignatures [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasPrivateGenerateInsertMethod [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectPrivateMethodSignatures [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_CanBeInstantiated [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectReturnTypes [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectAccessibility [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectInheritance [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectStructure [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectProperties [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectPropertyTypes [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectMethodSignatures [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectReturnTypes [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectAccessibility [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectInheritance [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectStructure [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectProperties [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectPropertyTypes [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectMethodSignatures [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectReturnTypes [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectAccessibility [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectInheritance [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectConstructor [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectPropertyAccessibility [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectPropertyTypes [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesAreUnique [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesAreSequential [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeCastToInt [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeCastFromInt [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeCompared [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeUsedInSwitchStatements [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeUsedInPatternMatching [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_GeneratesCorrectIndentedCode [1 ms]
  宸查€氳繃 CSharpGenerator_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 AbstractGenerator_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 Messages_Class_HasCorrectStructure [2 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0001") [1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0002") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0003") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0004") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0005") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0006") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0007") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0008") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0009") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0010") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0011") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0012") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0013") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0014") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0015") [< 1 ms]
  宸查€氳繃 Messages_AllDiagnostics_HaveCorrectProperties [< 1 ms]
  宸查€氳繃 Messages_AllDiagnostics_HaveUniqueIds [< 1 ms]
  宸查€氳繃 Consts_ContainsValidConstantValues [< 1 ms]
  宸查€氳繃 Consts_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 Extensions_GetParameterName_GeneratesUniqueNames [2 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.Int32","GetInt32") [5 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.String","GetString") [4 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.Boolean","GetBoolean") [4 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.DateTime","GetDateTime") [5 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.Decimal","GetDecimal") [4 ms]
  宸查€氳繃 Extensions_HandlesNullableTypesCorrectly [4 ms]
  宸查€氳繃 Extensions_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 NameMapper_GeneratesUniqueParameterNames [< 1 ms]
  宸查€氳繃 NameMapper_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 ClassGenerationContext_Class_HasCorrectStructure [1 ms]
  宸查€氳繃 MethodGenerationContext_Class_HasCorrectStructure [1 ms]
  宸查€氳繃 ISqlxSyntaxReceiver_Interface_HasCorrectStructure [< 1 ms]
  宸查€氳繃 GenerationContextBase_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 IsExternalInit_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_HasCorrectValues [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlDefine_Record_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlDefine_StaticInstances_AreReadOnly [< 1 ms]
  宸查€氳繃 SqlDefine_Properties_AreReadOnly [< 1 ms]
  宸查€氳繃 DatabaseDialectProviders_ImplementCorrectInterface [< 1 ms]
  宸查€氳繃 DatabaseDialectProviders_HaveConsistentNaming [< 1 ms]
  宸查€氳繃 TypeAnalyzer_SimplifiedDesign_NoCache [< 1 ms]
  宸查€氳繃 NameMapper_HandlesEdgeCases [< 1 ms]
  宸查€氳繃 SqlDefine_Equality_IsValueBased [< 1 ms]
  宸查€氳繃 SqlDefine_ToString_ReturnsUsefulInformation [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesLargeContent [1 ms]
  宸查€氳繃 DatabaseDialectFactory_CacheClearing_Works [< 1 ms]
  宸查€氳繃 SqlOperationInferrer_MethodPatterns_AreCaseInsensitive [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithMySqlDefine_ReturnsMySqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlServerDefine_ReturnsSqlServerProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithPostgreSqlDefine_ReturnsPostgreSqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSQLiteDefine_ReturnsSQLiteProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_MySql_ReturnsMySqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_SqlServer_ReturnsSqlServerProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_PostgreSql_ReturnsPostgreSqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_SQLite_ReturnsSQLiteProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithOracleDefineTypes_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithDB2DefineTypes_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithOracleDefine_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithDB2Define_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 MySqlDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlServerDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 PostgreSqlDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 SQLiteDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 MySqlDialectProvider_GenerateLimitClause_ReturnsCorrectSyntax [< 1 ms]
  宸查€氳繃 SqlServerDialectProvider_GenerateInsertWithReturning_ReturnsCorrectSyntax [< 1 ms]
  宸查€氳繃 PostgreSqlDialectProvider_GetCurrentDateTimeSyntax_ReturnsCorrectValue [< 1 ms]
  宸查€氳繃 AllDialectProviders_HaveConsistentInterface [< 1 ms]
  宸查€氳繃 AllDialectProviders_HandleEmptyString [< 1 ms]
  宸查€氳繃 AllDialectProviders_HandleSpecialCharacters [< 1 ms]
  宸查€氳繃 WrapColumn_WithMySqlProvider_UsesBackticks [< 1 ms]
  宸查€氳繃 WrapColumn_WithSqlServerProvider_UsesBrackets [< 1 ms]
  宸查€氳繃 WrapColumn_WithPostgreSqlProvider_UsesDoubleQuotes [< 1 ms]
  宸查€氳繃 WrapColumn_WithSQLiteProvider_UsesBrackets [< 1 ms]
  宸查€氳繃 WrapString_WithAllProviders_UsesCorrectQuotes [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithMySqlProvider_ReturnsAtSign [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithSqlServerProvider_ReturnsAtSign [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithPostgreSqlProvider_ReturnsDollarSign [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithSQLiteProvider_ReturnsAtSign [< 1 ms]
  宸查€氳繃 WrapColumn_WithEmptyString_ReturnsWrappedEmptyString [< 1 ms]
  宸查€氳繃 WrapString_WithEmptyString_ReturnsWrappedEmptyString [< 1 ms]
  宸查€氳繃 WrapColumn_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 WrapString_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Constructor_WithNullContent_CreatesEmptyBuilder [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Constructor_WithContent_InitializesWithContent [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithoutIndent_AppendsDirectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithIndent_AppendsWithSpaces [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_PushIndent_IncreasesIndentLevel [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_PopIndent_DecreasesIndentLevel [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_PopIndent_AtZeroLevel_ThrowsException [1 ms]
  宸查€氳繃 IndentedStringBuilder_MultipleIndentLevels_AppliesCorrectSpacing [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Append_WithoutNewline_AppendsDirectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendChar_Works [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendEmptyLine_AddsNewline [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithNullString_HandlesGracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithEmptyString_AddsOnlyNewline [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLineIf_WithTrueCondition_AppendsTrue [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLineIf_WithFalseCondition_AppendsFalse [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_ComplexCodeGeneration_FormatsCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_WithInitialContent_AppendsCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendWithIndent_HandlesWhitespace [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_LargeContent_HandlesEfficiently [< 1 ms]
  宸查€氳繃 MapName_WithSimpleName_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithPascalCase_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithCamelCase_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithMultipleWords_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithLongCamelCase_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithSpecialCharacters_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithHashPrefix_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithUnderscores_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithNumbersAtEnd_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithAllUppercase_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithSingleCharacter_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithSingleLowercaseCharacter_ReturnsSame [< 1 ms]
  宸查€氳繃 MapName_WithEmptyString_ReturnsEmpty [< 1 ms]
  宸查€氳繃 MapName_WithNullParameter_ThrowsArgumentNullException [< 1 ms]
  宸查€氳繃 MapName_WithMixedCaseAndNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithConsecutiveUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithDatabaseParameterName_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithComplexSpecialCharacters_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithOnlyNumbers_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithStartingNumber_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithAcronyms_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithLongParameterName_HandlesCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_LargeContent_PerformanceTest [16 ms]
  宸查€氳繃 NameMapper_BatchMapping_PerformanceTest [15 ms]
  宸查€氳繃 SqlDefine_Creation_PerformanceTest [6 ms]
  宸查€氳繃 DatabaseDialectFactory_Caching_PerformanceTest [2 ms]
  宸查€氳繃 TypeAnalyzer_CacheStatistics_PerformanceTest [< 1 ms]
  宸查€氳繃 SqlOperationInferrer_BatchInference_PerformanceTest [2 ms]
  宸查€氳繃 SqlDefine_StaticInstances_PerformanceTest [28 ms]
  宸查€氳繃 WrapColumns_WithMultipleColumns_ReturnsWrappedArray [< 1 ms]
  宸查€氳繃 WrapColumns_WithEmptyArray_ReturnsEmptyArray [< 1 ms]
  宸查€氳繃 WrapColumns_WithNullArray_ReturnsEmptyArray [< 1 ms]
  宸查€氳繃 WrapAndJoinColumns_WithMultipleColumns_ReturnsCommaSeparated [< 1 ms]
  宸查€氳繃 WrapAndJoinColumns_WithCollection_ReturnsCommaSeparated [< 1 ms]
  宸查€氳繃 WrapAndJoinColumns_WithNullCollection_ReturnsEmpty [< 1 ms]
  宸查€氳繃 CreateParameter_WithParameterName_ReturnsWithPrefix [< 1 ms]
  宸查€氳繃   宸查€氳繃 CreateParameter_WithSQLite_HandlesSpecialCase [< 1 ms]
DbContextCanJoinTransactions [107 ms]
  宸查€氳繃   宸查€氳繃 CreateParameter_WithEmptyName_ReturnsOnlyPrefix [< 1 ms]
CodeGeneration_BaseFunctionality_WorksCorrectly [44 ms]
  宸查€氳繃 CreateParameters_WithMultipleNames_ReturnsArray [< 1 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [59 ms]
  宸查€氳繃   宸查€氳繃 CreateAndJoinParameters_WithMultipleNames_ReturnsCommaSeparated [< 1 ms]
CodeGeneration_NullSymbols_HandlesGracefully [36 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [49 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [42 ms]
  宸查€氳繃 RecommendedApproach_TestStaticMethods_DirectTesting [< 1 ms]
  宸查€氳繃 RecommendedApproach_TestConcreteClasses_DirectInstantiation [< 1 ms]
  宸查€氳繃 RecommendedApproach_TestValueObjects_DirectComparison [< 1 ms]
  宸查€氳繃 CreateAndJoinParameters_WithCollection_ReturnsCommaSeparated [< 1 ms]
  宸查€氳繃 CreateSetClauses_WithColumns_ReturnsSetStatements [< 1 ms]
  宸查€氳繃 CreateSetClauses_WithCollection_ReturnsSetStatements [< 1 ms]
  宸查€氳繃 CreateSetClauses_WithEmptyArray_ReturnsEmpty [< 1 ms]
  宸查€氳繃 CreateWhereConditions_WithColumns_ReturnsConditions [< 1 ms]
  宸查€氳繃 CreateWhereConditions_WithCollection_ReturnsConditions [< 1 ms]
  宸查€氳繃 CreateWhereConditions_WithEmptyArray_ReturnsEmpty [< 1 ms]
  宸查€氳繃 UsesParameterPrefix_WithMatchingPrefix_ReturnsTrue [< 1 ms]
  宸查€氳繃 UsesParameterPrefix_WithNonMatchingPrefix_ReturnsFalse [< 1 ms]
  宸查€氳繃 UsesParameterPrefix_WithSQLiteSpecialCase_ReturnsTrue [< 1 ms]
  宸查€氳繃 GetEffectiveParameterPrefix_WithNormalPrefix_ReturnsSame [< 1 ms]
  宸查€氳繃 GetEffectiveParameterPrefix_WithSQLiteSpecialCase_ReturnsAt [< 1 ms]
  宸查€氳繃 GetEffectiveParameterPrefix_WithPostgreSQL_ReturnsDollar [< 1 ms]
  宸查€氳繃 ExtensionMethods_WorkWithAllDialects [< 1 ms]
  宸查€氳繃 SqlDefine_Constructor_SetsAllProperties [< 1 ms]
  宸查€氳繃 SqlDefine_Deconstruct_ReturnsAllValues [< 1 ms]
  宸查€氳繃 SqlDefine_MySql_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_SqlServer_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_PgSql_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_Oracle_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_DB2_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_SQLite_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithSimpleColumn_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithEmptyString_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithSimpleString_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithEmptyString_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_Equality_SameValues_ReturnsTrue [< 1 ms]
  宸查€氳繃 LimitedRecommendation_SimpleMock_ForSimpleInterfaces [33 ms]
  宸查€氳繃 NotRecommended_ComplexMocking_ExplanationOnly [< 1 ms]
  宸查€氳繃 AlternativeApproach_TestCoreLogic_WithoutComplexMocking [< 1 ms]
  宸查€氳繃 Guidelines_WhenToUseMoq [< 1 ms]
  宸查€氳繃 UseTestData_InsteadOfMocking [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("PersonId","person_id") [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("FirstName","first_name") [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("XMLHttpRequest","x_m_l_http_request") [< 1 ms]
  宸查€氳繃 ParameterizedTest_ReducesDuplication ("ID","i_d") [< 1 ms]
  宸查€氳繃 UseHelperMethods_ToBuildTestData [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("personId","person_id") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("name","name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("Name","name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("PersonId","person_id") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("","") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("a","a") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("A","a") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("userName","user_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("UserName","user_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("firstName","first_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("FirstName","first_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("lastName","last_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("LastName","last_name") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("emailAddress","email_address") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("EmailAddress","email_address") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("phoneNumber","phone_number") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("PhoneNumber","phone_number") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("isActive","is_active") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("IsActive","is_active") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("hasPermission","has_permission") [< 1 ms]
  宸查€氳繃 MapName_VariousInputs_ReturnsExpectedOutput ("HasPermission","has_permission") [< 1 ms]
  宸查€氳繃 MapName_SingleUppercaseLetter_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_SingleLowercaseLetter_ReturnsSame [< 1 ms]
  宸查€氳繃 MapName_EmptyString_ReturnsEmptyString [< 1 ms]
  宸查€氳繃 MapName_ComplexCamelCase_ReturnsCorrectFormat [< 1 ms]
  宸查€氳繃 MapName_WithNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_ConsecutiveUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_AllUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_MixedCaseAndNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithUnderscores_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithHyphens_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithSpaces_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_LeadingUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_TrailingUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_SingleUppercaseInMiddle_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_MultipleConsecutiveUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_NumbersAtBeginning_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_NumbersAtEnd_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_MixedCaseAndSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_OnlyNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_OnlySpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException [< 1 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException_Alternative [< 1 ms]
  宸查€氳繃 SqlDefine_Equality_DifferentValues_ReturnsFalse [< 1 ms]
  宸查€氳繃 SqlDefine_GetHashCode_SameValues_ReturnsSameHash [< 1 ms]
  宸查€氳繃 SqlDefine_GetHashCode_DifferentValues_ReturnsDifferentHash [< 1 ms]
  宸查€氳繃 SqlDefine_ToString_ReturnsReadableString [< 1 ms]
  宸查€氳繃 InferOperation_WithGetMethod_ReturnsSelect [19 ms]
  宸查€氳繃 InferOperation_WithCreateMethod_ReturnsInsert [12 ms]
  宸查€氳繃 InferOperation_WithUpdateMethod_ReturnsUpdate [16 ms]
  宸查€氳繃 InferOperation_WithDeleteMethod_ReturnsDelete [16 ms]
  宸查€氳繃 InferOperation_WithFindMethod_ReturnsSelect [21 ms]
  宸查€氳繃 InferOperation_WithSearchMethod_ReturnsSelect [15 ms]
  宸查€氳繃 InferOperation_WithInsertMethod_ReturnsInsert [14 ms]
  宸查€氳繃 InferOperation_WithRemoveMethod_ReturnsDelete [15 ms]
  宸查€氳繃 InferOperation_WithSelectMethod_ReturnsSelect [15 ms]
  宸查€氳繃 InferOperation_WithListMethod_ReturnsSelect [15 ms]
  宸查€氳繃 InferOperation_WithSaveMethod_ReturnsInsert [14 ms]
  宸查€氳繃 InferOperation_WithAddMethod_ReturnsInsert [14 ms]
  宸查€氳繃 InferOperation_WithEditMethod_ReturnsUpdate [13 ms]
  宸查€氳繃 InferOperation_WithDestroyMethod_ReturnsDelete [16 ms]
  宸查€氳繃 InferOperation_WithLoadMethod_ReturnsSelect [22 ms]
  宸查€氳繃 GenerateSqlTemplate_WithSelectOperation_ReturnsSelectSql [13 ms]
  宸查€氳繃 GenerateSqlTemplate_WithInsertOperation_ReturnsInsertSql [14 ms]
  宸查€氳繃 GenerateSqlTemplate_WithUpdateOperation_ReturnsUpdateSql [13 ms]
  宸查€氳繃 GenerateSqlTemplate_WithDeleteOperation_ReturnsDeleteSql [11 ms]
  宸查€氳繃 GenerateSqlTemplate_WithNullEntityType_ReturnsBasicSql [10 ms]
  宸查€氳繃 GenerateSqlTemplate_WithEmptyTableName_HandlesGracefully [11 ms]
  宸查€氳繃 InferOperation_WithNullMethod_ReturnsDefaultOperation [9 ms]
  宸查€氳繃 InferOperation_CaseInsensitive_WorksCorrectly [17 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException_TryCatch [< 1 ms]
  宸查€氳繃 MapName_NullInput_ThrowsArgumentNullException_AssertThrows [< 1 ms]
  宸查€氳繃 GeneratedCode_SupportsNullableReferenceTypes [< 1 ms]
  宸查€氳繃 GeneratedCode_HandlesNullableValueTypes [< 1 ms]
  宸查€氳繃 GeneratedCode_EnforcesNonNullableTypes [< 1 ms]
  宸查€氳繃 GeneratedCode_HandlesDatabaseNulls [< 1 ms]
  宸查€氳繃 GeneratedCode_HandlesStringNulls [< 1 ms]
  澶辫触 PrimaryConstructor_BasicClass_GeneratesCorrectCode [153 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for primary constructor
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.PrimaryConstructor_BasicClass_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 54
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class ProductRepository : TestNamespace.IProductService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllProducts using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Product entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Product> GetAllProducts()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Product>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllProducts", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Product>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Price = reader.GetOrdinal("Price");
                     var entity = new TestNamespace.Product(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.GetDecimal(reader.GetOrdinal("Price"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Product>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllProducts", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllProducts", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertProduct using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="product">The Product entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "products")]
         public int InsertProduct(TestNamespace.Product product)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [products] ([name], [price]) VALUES (@name, @price)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = (object?)product.Name ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramPrice = __cmd__.CreateParameter();
                 paramPrice.ParameterName = "@price";
                 paramPrice.DbType = global::System.Data.DbType.Decimal;
                 paramPrice.Value = product.Price;
                 __cmd__.Parameters.Add(paramPrice);
 
                 OnExecuting("InsertProduct", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertProduct", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertProduct", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Product has 0 attributes:
 No RepositoryFor attribute found on Product
 Class ProductRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on ProductRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  澶辫触 Record_BasicRecord_GeneratesCorrectCode [139 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for record
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.Record_BasicRecord_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 94
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class UserRepository : TestNamespace.IUserService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllUsers using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of User entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.User> GetAllUsers()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.User>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllUsers", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.User>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Email = reader.GetOrdinal("Email");
                     var entity = new TestNamespace.User(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.IsDBNull(reader.GetOrdinal("Email")) ? string.Empty : reader.GetString(reader.GetOrdinal("Email"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.User>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllUsers", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllUsers", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertUser using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="user">The User entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "users")]
         public int InsertUser(TestNamespace.User user)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [users] ([name], [email]) VALUES (@name, @email)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = (object?)user.Name ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramEmail = __cmd__.CreateParameter();
                 paramEmail.ParameterName = "@email";
                 paramEmail.DbType = global::System.Data.DbType.String;
                 paramEmail.Value = (object?)user.Email ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramEmail);
 
                 OnExecuting("InsertUser", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertUser", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertUser", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class UserRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on UserRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  宸查€氳繃 IsLikelyEntityType_WithEntityClass_ReturnsTrue [12 ms]
  宸查€氳繃 IsLikelyEntityType_WithPrimitiveType_ReturnsFalse [15 ms]
  宸查€氳繃 IsLikelyEntityType_WithStringType_ReturnsFalse [15 ms]
  宸查€氳繃 IsLikelyEntityType_WithNullType_ReturnsFalse [12 ms]
  宸查€氳繃 IsCollectionType_WithListType_ReturnsTrue [12 ms]
  宸查€氳繃 IsCollectionType_WithNonCollectionType_ReturnsFalse [10 ms]
  宸查€氳繃 IsAsyncType_WithTaskType_ReturnsTrue [13 ms]
  宸查€氳繃 IsAsyncType_WithGenericTaskType_ReturnsTrue [12 ms]
  宸查€氳繃 IsAsyncType_WithNonAsyncType_ReturnsFalse [10 ms]
  宸查€氳繃 IsScalarReturnType_WithIntType_ReturnsTrue [13 ms]
  宸查€氳繃 IsScalarReturnType_WithStringType_ReturnsTrue [12 ms]
  宸查€氳繃 IsScalarReturnType_WithEntityType_ReturnsFalse [12 ms]
  宸查€氳繃 GetDefaultValue_WithIntType_ReturnsCorrectDefault [15 ms]
  宸查€氳繃 GetDefaultValue_WithStringType_ReturnsCorrectDefault [13 ms]
  宸查€氳繃 GetDefaultValue_WithBoolType_ReturnsCorrectDefault [17 ms]
  宸查€氳繃 GetInnerType_WithListOfUser_ReturnsListType [19 ms]
  宸查€氳繃 GetInnerType_WithTaskOfUser_ReturnsUserType [15 ms]
  宸查€氳繃 GetInnerType_WithNonGenericType_ReturnsOriginalType [13 ms]

娴嬭瘯杩愯澶辫触銆?
娴嬭瘯鎬绘暟: 649
     閫氳繃鏁? 643
     澶辫触鏁? 5
    璺宠繃鏁? 1
鎬绘椂闂? 19.7432 绉?
  澶辫触 RecordWithAdditionalProperties_GeneratesCorrectCode [134 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for record
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.RecordWithAdditionalProperties_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 138
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class ProductRepository : TestNamespace.IProductService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllProducts using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Product entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Product> GetAllProducts()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Product>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllProducts", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Product>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Price = reader.GetOrdinal("Price");
                     int __ordinal_Description = reader.GetOrdinal("Description");
                     int __ordinal_IsActive = reader.GetOrdinal("IsActive");
                     var entity = new TestNamespace.Product(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.GetDecimal(reader.GetOrdinal("Price"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Product>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllProducts", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllProducts", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertProduct using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="product">The Product entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "products")]
         public int InsertProduct(TestNamespace.Product product)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [products] ([name], [price], [description], [is_active]) VALUES (@name, @price, @description, @is_active)";
 
                 var paramName = __cmd__.CreateParameter();
                 paramName.ParameterName = "@name";
                 paramName.DbType = global::System.Data.DbType.String;
                 paramName.Value = (object?)product.Name ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramName);
 
                 var paramPrice = __cmd__.CreateParameter();
                 paramPrice.ParameterName = "@price";
                 paramPrice.DbType = global::System.Data.DbType.Decimal;
                 paramPrice.Value = product.Price;
                 __cmd__.Parameters.Add(paramPrice);
 
                 var paramDescription = __cmd__.CreateParameter();
                 paramDescription.ParameterName = "@description";
                 paramDescription.DbType = global::System.Data.DbType.String;
                 paramDescription.Value = (object?)product.Description ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramDescription);
 
                 var paramIsActive = __cmd__.CreateParameter();
                 paramIsActive.ParameterName = "@is_active";
                 paramIsActive.DbType = global::System.Data.DbType.Boolean;
                 paramIsActive.Value = product.IsActive;
                 __cmd__.Parameters.Add(paramIsActive);
 
                 OnExecuting("InsertProduct", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertProduct", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertProduct", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class ProductRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on ProductRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  宸查€氳繃 BatchCommand_WithRecord_GeneratesCorrectCode [119 ms]
  澶辫触 PrimaryConstructor_WithPartialProperties_GeneratesCorrectCode [142 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for primary constructor
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.PrimaryConstructor_WithPartialProperties_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 222
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class OrderRepository : TestNamespace.IOrderService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetAllOrders using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Order entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Order> GetAllOrders()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Order>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetAllOrders", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Order>();
 
                 while (reader.Read())
                 {
                     int __ordinal_OrderDate = reader.GetOrdinal("OrderDate");
                     int __ordinal_TotalAmount = reader.GetOrdinal("TotalAmount");
                     int __ordinal_OrderId = reader.GetOrdinal("OrderId");
                     int __ordinal_CustomerName = reader.GetOrdinal("CustomerName");
                     var entity = new TestNamespace.Order(
                         reader.GetInt32(reader.GetOrdinal("OrderId")),
                         reader.IsDBNull(reader.GetOrdinal("CustomerName")) ? string.Empty : reader.GetString(reader.GetOrdinal("CustomerName"))
                     );
                     entity.OrderDate = reader.GetDateTime(reader.GetOrdinal("OrderDate"));
                     entity.TotalAmount = reader.GetDecimal(reader.GetOrdinal("TotalAmount"));
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Order>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetAllOrders", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetAllOrders", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of InsertOrder using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <param name="order">The Order entity to process.</param>
         /// <returns>The number of affected rows.</returns>
         [SqlExecuteType(SqlExecuteTypes.Insert, "orders")]
         public int InsertOrder(TestNamespace.Order order)
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             int __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "INSERT INTO [orders] ([order_date], [total_amount], [order_id], [customer_name]) VALUES (@order_date, @total_amount, @order_id, @customer_name)";
 
                 var paramOrderDate = __cmd__.CreateParameter();
                 paramOrderDate.ParameterName = "@order_date";
                 paramOrderDate.DbType = global::System.Data.DbType.DateTime;
                 paramOrderDate.Value = order.OrderDate;
                 __cmd__.Parameters.Add(paramOrderDate);
 
                 var paramTotalAmount = __cmd__.CreateParameter();
                 paramTotalAmount.ParameterName = "@total_amount";
                 paramTotalAmount.DbType = global::System.Data.DbType.Decimal;
                 paramTotalAmount.Value = order.TotalAmount;
                 __cmd__.Parameters.Add(paramTotalAmount);
 
                 var paramOrderId = __cmd__.CreateParameter();
                 paramOrderId.ParameterName = "@order_id";
                 paramOrderId.DbType = global::System.Data.DbType.Int32;
                 paramOrderId.Value = order.OrderId;
                 __cmd__.Parameters.Add(paramOrderId);
 
                 var paramCustomerName = __cmd__.CreateParameter();
                 paramCustomerName.ParameterName = "@customer_name";
                 paramCustomerName.DbType = global::System.Data.DbType.String;
                 paramCustomerName.Value = (object?)order.CustomerName ?? global::System.DBNull.Value;
                 __cmd__.Parameters.Add(paramCustomerName);
 
                 OnExecuting("InsertOrder", __cmd__);
 
                 __result__ = __cmd__.ExecuteNonQuery();
                 return System.Convert.ToInt32(__result__);
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("InsertOrder", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("InsertOrder", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Order has 0 attributes:
 No RepositoryFor attribute found on Order
 Class OrderRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on OrderRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  澶辫触 MixedClassTypes_GeneratesCorrectCode [150 ms]
  閿欒娑堟伅:
   Assert.IsTrue 澶辫触銆係hould use enhanced entity mapping for modern types
  鍫嗘爤璺熻釜:
     at Sqlx.Tests.PrimaryConstructorTests.MixedClassTypes_GeneratesCorrectCode() in C:\Users\huaji\Workplace\github\Sqlx\tests\Sqlx.Tests\PrimaryConstructorTests.cs:line 284
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)
   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)

  鏍囧噯杈撳嚭娑堟伅:
 Generated code:
 // <auto-generated>
 // This code was generated by Sqlx Source Generator.
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable enable
 
 namespace Sqlx.Annotations
 {
     /// <summary>
     /// Specifies SQL command text or stored procedure name for a method.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = true, Inherited = false)]
     public sealed class SqlxAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         public SqlxAttribute()
         {
             StoredProcedureName = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlxAttribute"/> class.
         /// </summary>
         /// <param name="storedProcedureName">The stored procedure name.</param>
         public SqlxAttribute(string storedProcedureName)
         {
             StoredProcedureName = storedProcedureName ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the stored procedure name.
         /// </summary>
         public string StoredProcedureName { get; set; }
     }
 
     /// <summary>
     /// Specifies raw SQL command text for methods or parameters.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class RawSqlAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         public RawSqlAttribute()
         {
             Sql = string.Empty;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="RawSqlAttribute"/> class.
         /// </summary>
         /// <param name="sql">The raw SQL command text.</param>
         public RawSqlAttribute(string sql)
         {
             Sql = sql ?? string.Empty;
         }
 
         /// <summary>
         /// Gets or sets the raw SQL command text.
         /// </summary>
         public string Sql { get; set; }
     }
 
     /// <summary>
     /// Indicates that a parameter should be converted from a LINQ expression to SQL.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter,
         AllowMultiple = false, Inherited = false)]
     public sealed class ExpressionToSqlAttribute : global::System.Attribute
     {
     }
 
     /// <summary>
     /// Specifies CRUD operation types and target table names.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method,
         AllowMultiple = false, Inherited = false)]
     public sealed class SqlExecuteTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlExecuteTypeAttribute"/> class.
         /// </summary>
         /// <param name="executeType">The SQL operation type.</param>
         /// <param name="tableName">The target table name.</param>
         public SqlExecuteTypeAttribute(SqlExecuteTypes executeType, string tableName)
         {
             ExecuteType = executeType;
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the SQL operation type.
         /// </summary>
         public SqlExecuteTypes ExecuteType { get; }
 
         /// <summary>
         /// Gets the target table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Marks a class as a repository for a specified service interface.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class,
         AllowMultiple = false, Inherited = false)]
     public sealed class RepositoryForAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="RepositoryForAttribute"/> class.
         /// </summary>
         /// <param name="serviceType">The service interface type.</param>
         public RepositoryForAttribute(global::System.Type serviceType)
         {
             ServiceType = serviceType ?? throw new global::System.ArgumentNullException(nameof(serviceType));
         }
 
         /// <summary>
         /// Gets the service interface type.
         /// </summary>
         public global::System.Type ServiceType { get; }
     }
 
     /// <summary>
     /// Specifies the database table name for an entity.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Class |
         global::System.AttributeTargets.Interface | global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
     public sealed class TableNameAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="TableNameAttribute"/> class.
         /// </summary>
         /// <param name="tableName">The database table name.</param>
         public TableNameAttribute(string tableName)
         {
             TableName = tableName ?? throw new global::System.ArgumentNullException(nameof(tableName));
         }
 
         /// <summary>
         /// Gets the database table name.
         /// </summary>
         public string TableName { get; }
     }
 
     /// <summary>
     /// Defines SQL operation types for CRUD operations.
     /// </summary>
     public enum SqlExecuteTypes
     {
         /// <summary>SELECT operation.</summary>
         Select = 0,
         /// <summary>UPDATE operation.</summary>
         Update = 1,
         /// <summary>INSERT operation.</summary>
         Insert = 2,
         /// <summary>DELETE operation.</summary>
         Delete = 3,
         /// <summary>Batch INSERT operation.</summary>
         BatchInsert = 4,
         /// <summary>Batch UPDATE operation.</summary>
         BatchUpdate = 5,
         /// <summary>Batch DELETE operation.</summary>
         BatchDelete = 6,
         /// <summary>ADO.NET BatchCommand operation.</summary>
         BatchCommand = 7
     }
 
     /// <summary>
     /// Defines database dialect types for SQL generation.
     /// </summary>
     public enum SqlDefineTypes
     {
         /// <summary>MySQL dialect with backtick column wrapping.</summary>
         MySql = 0,
         /// <summary>SQL Server dialect with square bracket column wrapping.</summary>
         SqlServer = 1,
         /// <summary>PostgreSQL dialect with double quote column wrapping.</summary>
         Postgresql = 2,
         /// <summary>Oracle dialect with double quote column wrapping and colon parameters.</summary>
         Oracle = 3,
         /// <summary>DB2 dialect with double quote column wrapping and question mark parameters.</summary>
         DB2 = 4,
         /// <summary>SQLite dialect with square bracket column wrapping.</summary>
         SQLite = 5
     }
 
     /// <summary>
     /// Provides database dialect-specific SQL formatting definitions.
     /// </summary>
     public static class SqlDefine
     {
         /// <summary>
         /// MySQL dialect configuration with backtick column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) MySql = ("`", "`", "'", "'", "@");
 
         /// <summary>
         /// SQL Server dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) SqlServer = ("[", "]", "'", "'", "@");
 
         /// <summary>
         /// PostgreSQL dialect configuration with double quote column wrapping and $ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) PgSql = ("\"", "\"", "'", "'", "$");
 
         /// <summary>
         /// Oracle dialect configuration with double quote column wrapping and : parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Oracle = ("\"", "\"", "'", "'", ":");
 
         /// <summary>
         /// DB2 dialect configuration with double quote column wrapping and ? parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) DB2 = ("\"", "\"", "'", "'", "?");
 
         /// <summary>
         /// SQLite dialect configuration with square bracket column wrapping and @ parameter prefix.
         /// </summary>
         public static readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) Sqlite = ("[", "]", "'", "'", "@");
     }
 
     /// <summary>
     /// Represents a SQL template with parameterized command text and parameters.
     /// </summary>
     public readonly record struct SqlTemplate(string Sql, global::System.Data.Common.DbParameter[] Parameters);
 
     /// <summary>
     /// Provides LINQ expression to SQL conversion functionality.
     /// </summary>
     /// <typeparam name="T">The entity type for expressions.</typeparam>
     public class ExpressionToSql<T> : global::System.IDisposable
     {
         private readonly global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>> _whereConditions =
             new global::System.Collections.Generic.List<global::System.Linq.Expressions.Expression<global::System.Func<T, bool>>>();
         private readonly global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression Expression, bool Descending)> _orderByExpressions =
             new global::System.Collections.Generic.List<(global::System.Linq.Expressions.LambdaExpression, bool)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Value)> _setClausesConstant =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly global::System.Collections.Generic.List<(string Column, string Expression)> _setClausesExpression =
             new global::System.Collections.Generic.List<(string, string)>();
         private readonly (string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) _dialect;
         private SqlTemplate? _cachedTemplate;
         private int? _take;
         private int? _skip;
 
         /// <summary>
         /// Initializes a new instance with the specified SQL dialect.
         /// </summary>
         private ExpressionToSql((string ColumnLeft, string ColumnRight, string StringLeft,
             string StringRight, string ParameterPrefix) dialect)
         {
             _dialect = dialect;
         }
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQL Server dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlServer()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for MySQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForMySql()
             => new ExpressionToSql<T>(SqlDefine.MySql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for PostgreSQL dialect.
         /// </summary>
         public static ExpressionToSql<T> ForPostgreSQL()
             => new ExpressionToSql<T>(SqlDefine.PgSql);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for Oracle dialect.
         /// </summary>
         public static ExpressionToSql<T> ForOracle()
             => new ExpressionToSql<T>(SqlDefine.Oracle);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for DB2 dialect.
         /// </summary>
         public static ExpressionToSql<T> ForDB2()
             => new ExpressionToSql<T>(SqlDefine.DB2);
 
         /// <summary>
         /// Creates an ExpressionToSql builder for SQLite dialect.
         /// </summary>
         public static ExpressionToSql<T> ForSqlite()
             => new ExpressionToSql<T>(SqlDefine.Sqlite);
 
         /// <summary>
         /// Creates an ExpressionToSql builder with default (SQL Server) dialect.
         /// </summary>
         public static ExpressionToSql<T> Create()
             => new ExpressionToSql<T>(SqlDefine.SqlServer);
 
         /// <summary>
         /// Adds a WHERE condition to the query.
         /// </summary>
         public ExpressionToSql<T> Where(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             if (predicate != null)
                 _whereConditions.Add(predicate);
             return this;
         }
 
         /// <summary>
         /// Adds an AND condition to the query.
         /// </summary>
         public ExpressionToSql<T> And(global::System.Linq.Expressions.Expression<global::System.Func<T, bool>> predicate)
         {
             return Where(predicate);
         }
 
         /// <summary>
         /// Adds an ORDER BY clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderBy<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, false));
             return this;
         }
 
         /// <summary>
         /// Adds an ORDER BY DESC clause to the query.
         /// </summary>
         public ExpressionToSql<T> OrderByDescending<TKey>(global::System.Linq.Expressions.Expression<global::System.Func<T, TKey>> keySelector)
         {
             if (keySelector != null)
                 _orderByExpressions.Add((keySelector, true));
             return this;
         }
 
         /// <summary>
         /// Limits the number of returned rows.
         /// </summary>
         public ExpressionToSql<T> Take(int count)
         {
             _take = count;
             return this;
         }
 
         /// <summary>
         /// Skips the specified number of rows.
         /// </summary>
         public ExpressionToSql<T> Skip(int count)
         {
             _skip = count;
             return this;
         }
 
         /// <summary>
         /// Sets a value for an UPDATE operation. Supports patterns like a=1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector, TValue value)
         {
             var columnName = GetColumnName(selector.Body);
             var valueStr = FormatConstantValue(value);
             _setClausesConstant.Add((columnName, valueStr));
             return this;
         }
 
         /// <summary>
         /// Sets a value using an expression for an UPDATE operation. Supports patterns like a=a+1.
         /// </summary>
         public ExpressionToSql<T> Set<TValue>(global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> selector,
             global::System.Linq.Expressions.Expression<global::System.Func<T, TValue>> valueExpression)
         {
             var columnName = GetColumnName(selector.Body);
             var expressionSql = ParseExpression(valueExpression.Body);
             _setClausesExpression.Add((columnName, expressionSql));
             return this;
         }
 
         /// <summary>
         /// Specifies columns for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Insert(global::System.Linq.Expressions.Expression<global::System.Func<T, object>> selector)
         {
             return this;
         }
 
         /// <summary>
         /// Specifies values for an INSERT operation.
         /// </summary>
         public ExpressionToSql<T> Values(params object[] values)
         {
             return this;
         }
 
         private string BuildSql()
         {
             if (_setClausesConstant.Count > 0 || _setClausesExpression.Count > 0)
             {
                 var sql = new global::System.Text.StringBuilder();
                 sql.Append("UPDATE ");
                 sql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
                 sql.Append(" SET ");
                 var setClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (column, value) in _setClausesConstant)
                 {
                     setClauses.Add($"{column} = {value}");
                 }
                 foreach (var (column, expression) in _setClausesExpression)
                 {
                     setClauses.Add($"{column} = {expression}");
                 }
                 sql.Append(string.Join(", ", setClauses));
 
                 if (_whereConditions.Count > 0)
                 {
                     sql.Append(" WHERE ");
                     var conditions = new global::System.Collections.Generic.List<string>();
                     foreach (var condition in _whereConditions)
                     {
                         var conditionSql = ParseExpression(condition.Body);
                         conditions.Add($"({conditionSql})");
                     }
                     sql.Append(string.Join(" AND ", conditions));
                 }
                 return sql.ToString();
             }
 
             var selectSql = new global::System.Text.StringBuilder();
             selectSql.Append("SELECT * FROM ");
             selectSql.Append(_dialect.ColumnLeft + typeof(T).Name + _dialect.ColumnRight);
 
             if (_whereConditions.Count > 0)
             {
                 selectSql.Append(" WHERE ");
                 var conditions = new global::System.Collections.Generic.List<string>();
                 foreach (var condition in _whereConditions)
                 {
                     var conditionSql = ParseExpression(condition.Body);
                     conditions.Add($"({conditionSql})");
                 }
                 selectSql.Append(string.Join(" AND ", conditions));
             }
 
             if (_orderByExpressions.Count > 0)
             {
                 selectSql.Append(" ORDER BY ");
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 selectSql.Append(string.Join(", ", orderClauses));
             }
 
             if (_skip.HasValue)
             {
                 selectSql.Append($" OFFSET {_skip.Value}");
             }
 
             if (_take.HasValue)
             {
                 selectSql.Append($" LIMIT {_take.Value}");
             }
 
             return selectSql.ToString();
         }
 
         /// <summary>
         /// Converts the built query to a parameterized SQL template.
         /// Results are cached for performance on repeated calls.
         /// </summary>
         public SqlTemplate ToTemplate()
         {
             if (_cachedTemplate.HasValue)
                 return _cachedTemplate.Value;
             var sql = BuildSql();
             _cachedTemplate = new SqlTemplate(sql, global::System.Array.Empty<global::System.Data.Common.DbParameter>());
             return _cachedTemplate.Value;
         }
 
         /// <summary>
         /// Converts the built query to a SQL string.
         /// </summary>
         public string ToSql()
         {
             return BuildSql();
         }
 
         /// <summary>
         /// Generates the WHERE clause portion of the query.
         /// </summary>
         public string ToWhereClause()
         {
             if (_whereConditions.Count == 0)
                 return string.Empty;
             var conditions = new global::System.Collections.Generic.List<string>();
             foreach (var condition in _whereConditions)
             {
                 var conditionSql = ParseExpression(condition.Body);
                 conditions.Add($"({conditionSql})");
             }
             return string.Join(" AND ", conditions);
         }
 
         /// <summary>
         /// Generates additional clauses for the query.
         /// </summary>
         public string ToAdditionalClause()
         {
             var clauses = new global::System.Collections.Generic.List<string>();
             if (_orderByExpressions.Count > 0)
             {
                 var orderClauses = new global::System.Collections.Generic.List<string>();
                 foreach (var (expression, descending) in _orderByExpressions)
                 {
                     var columnName = GetColumnName(expression.Body);
                     var direction = descending ? " DESC" : " ASC";
                     orderClauses.Add(columnName + direction);
                 }
                 clauses.Add("ORDER BY " + string.Join(", ", orderClauses));
             }
             if (_skip.HasValue)
             {
                 clauses.Add($"OFFSET {_skip.Value}");
             }
             if (_take.HasValue)
             {
                 clauses.Add($"LIMIT {_take.Value}");
             }
             return string.Join(" ", clauses);
         }
 
         /// <summary>
         /// Releases resources used by this instance.
         /// </summary>
         public void Dispose()
         {
             _whereConditions.Clear();
             _orderByExpressions.Clear();
             _setClausesConstant.Clear();
             _setClausesExpression.Clear();
             _cachedTemplate = null;
         }
 
         private string ParseExpression(global::System.Linq.Expressions.Expression expression)
         {
             switch (expression)
             {
                 case global::System.Linq.Expressions.BinaryExpression binary:
                     return ParseBinaryExpression(binary);
                 case global::System.Linq.Expressions.MemberExpression member:
                     return GetColumnName(member);
                 case global::System.Linq.Expressions.ConstantExpression constant:
                     return GetConstantValue(constant);
                 case global::System.Linq.Expressions.UnaryExpression unary when unary.NodeType == global::System.Linq.Expressions.ExpressionType.Not:
                     return $"NOT ({ParseExpression(unary.Operand)})";
                 default:
                     return "1=1";
             }
         }
 
         private string ParseBinaryExpression(global::System.Linq.Expressions.BinaryExpression binary)
         {
             var left = ParseExpression(binary.Left);
             var right = ParseExpression(binary.Right);
             return binary.NodeType switch
             {
                 global::System.Linq.Expressions.ExpressionType.Equal => $"{left} = {right}",
                 global::System.Linq.Expressions.ExpressionType.NotEqual => $"{left} <> {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThan => $"{left} > {right}",
                 global::System.Linq.Expressions.ExpressionType.GreaterThanOrEqual => $"{left} >= {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThan => $"{left} < {right}",
                 global::System.Linq.Expressions.ExpressionType.LessThanOrEqual => $"{left} <= {right}",
                 global::System.Linq.Expressions.ExpressionType.AndAlso => $"({left} AND {right})",
                 global::System.Linq.Expressions.ExpressionType.OrElse => $"({left} OR {right})",
                 global::System.Linq.Expressions.ExpressionType.Add => $"{left} + {right}",
                 global::System.Linq.Expressions.ExpressionType.Subtract => $"{left} - {right}",
                 global::System.Linq.Expressions.ExpressionType.Multiply => $"{left} * {right}",
                 global::System.Linq.Expressions.ExpressionType.Divide => $"{left} / {right}",
                 global::System.Linq.Expressions.ExpressionType.Modulo => $"{left} % {right}",
                 _ => $"{left} = {right}"
             };
         }
 
         private string GetColumnName(global::System.Linq.Expressions.Expression expression)
         {
             if (expression is global::System.Linq.Expressions.MemberExpression member)
             {
                 var columnName = member.Member.Name;
                 return _dialect.ColumnLeft + columnName + _dialect.ColumnRight;
             }
             return "Column";
         }
 
         private string GetConstantValue(global::System.Linq.Expressions.ConstantExpression constant)
         {
             return FormatConstantValue(constant.Value);
         }
 
         private string FormatConstantValue(object? value)
         {
             if (value == null)
                 return "NULL";
             return value switch
             {
                 string s => _dialect.StringLeft + s.Replace("'", "''") + _dialect.StringRight,
                 bool b => b ? "1" : "0",
                 global::System.DateTime dt => _dialect.StringLeft + dt.ToString("yyyy-MM-dd HH:mm:ss") + _dialect.StringRight,
                 _ => value.ToString() ?? "NULL"
             };
         }
     }
 
     /// <summary>
     /// Specifies the entity type for DbContext methods returning tuples or generic collections.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Parameter |
         global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
     public sealed class DbSetTypeAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="DbSetTypeAttribute"/> class.
         /// </summary>
         /// <param name="type">The entity type.</param>
         public DbSetTypeAttribute(global::System.Type type)
         {
             Type = type ?? throw new global::System.ArgumentNullException(nameof(type));
         }
 
         /// <summary>
         /// Gets the entity type.
         /// </summary>
         public global::System.Type Type { get; }
     }
 
     /// <summary>
     /// Specifies the database dialect for SQL generation.
     /// </summary>
     [global::System.AttributeUsage(global::System.AttributeTargets.Method |
         global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class SqlDefineAttribute : global::System.Attribute
     {
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with a predefined dialect.
         /// </summary>
         /// <param name="dialectType">The database dialect type.</param>
         public SqlDefineAttribute(SqlDefineTypes dialectType)
         {
             DialectType = dialectType;
         }
 
         /// <summary>
         /// Initializes a new instance of the <see cref="SqlDefineAttribute"/> class with custom dialect settings.
         /// </summary>
         /// <param name="columnLeft">Left column delimiter.</param>
         /// <param name="columnRight">Right column delimiter.</param>
         /// <param name="stringLeft">Left string delimiter.</param>
         /// <param name="stringRight">Right string delimiter.</param>
         /// <param name="parameterPrefix">Parameter prefix.</param>
         public SqlDefineAttribute(string columnLeft, string columnRight, string stringLeft, string stringRight, string parameterPrefix)
         {
             ColumnLeft = columnLeft ?? throw new global::System.ArgumentNullException(nameof(columnLeft));
             ColumnRight = columnRight ?? throw new global::System.ArgumentNullException(nameof(columnRight));
             StringLeft = stringLeft ?? throw new global::System.ArgumentNullException(nameof(stringLeft));
             StringRight = stringRight ?? throw new global::System.ArgumentNullException(nameof(stringRight));
             ParameterPrefix = parameterPrefix ?? throw new global::System.ArgumentNullException(nameof(parameterPrefix));
         }
 
         /// <summary>
         /// Gets the database dialect type.
         /// </summary>
         public SqlDefineTypes? DialectType { get; }
 
         /// <summary>
         /// Gets the left column delimiter.
         /// </summary>
         public string? ColumnLeft { get; }
 
         /// <summary>
         /// Gets the right column delimiter.
         /// </summary>
         public string? ColumnRight { get; }
 
         /// <summary>
         /// Gets the left string delimiter.
         /// </summary>
         public string? StringLeft { get; }
 
         /// <summary>
         /// Gets the right string delimiter.
         /// </summary>
         public string? StringRight { get; }
 
         /// <summary>
         /// Gets the parameter prefix.
         /// </summary>
         public string? ParameterPrefix { get; }
     }
 }

// <auto-generated>
 // This file was generated by Sqlx Repository Generator
 // Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 // </auto-generated>
 
 #nullable disable
 #pragma warning disable CS8618, CS8625, CS8629, CS8601, CS8600, CS8603, CS8669
 
 namespace TestNamespace
 {
     using System;
     using System.Collections.Generic;
     using System.Data;
     using System.Data.Common;
     using System.Threading;
     using System.Threading.Tasks;
     using Sqlx.Annotations;
 
     public partial class MixedRepository : TestNamespace.IMixedService
     {
         // ===================================================================
         // Interceptor partial methods
         // Implement these in your partial class to add custom logic:
         //
         // partial void OnExecuting(string methodName, DbCommand command)
         // {
         //     // Add logic before SQL execution
         //     // e.g., logging, parameter validation, caching
         // }
         //
         // partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed)
         // {
         //     // Add logic after successful execution
         //     // e.g., result caching, metrics, logging
         // }
         //
         // partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed)
         // {
         //     // Add logic when execution fails
         //     // e.g., error logging, retry logic, fallback handling
         // }
         // ===================================================================
 
         partial void OnExecuting(string methodName, DbCommand command);
 
         partial void OnExecuted(string methodName, DbCommand command, object? result, long elapsed);
 
         partial void OnExecuteFail(string methodName, DbCommand? command, Exception exception, long elapsed);
 
         /// <summary>
         /// Generated implementation of GetCategories using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Category entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Category> GetCategories()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Category>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetCategories", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Category>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     var entity = new TestNamespace.Category
                     {
                         Id = reader.GetInt32(reader.GetOrdinal("Id")),
                         Name = reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name"))
                     };
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Category>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetCategories", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetCategories", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetProducts using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Product entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Product> GetProducts()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Product>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetProducts", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Product>();
 
                 while (reader.Read())
                 {
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_Name = reader.GetOrdinal("Name");
                     int __ordinal_Price = reader.GetOrdinal("Price");
                     int __ordinal_CategoryId = reader.GetOrdinal("CategoryId");
                     var entity = new TestNamespace.Product(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("Name")) ? string.Empty : reader.GetString(reader.GetOrdinal("Name")),
                         reader.GetDecimal(reader.GetOrdinal("Price")),
                         reader.GetInt32(reader.GetOrdinal("CategoryId"))
                     );
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Product>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetProducts", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetProducts", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
         /// <summary>
         /// Generated implementation of GetOrders using Sqlx.
         /// This method was automatically generated by the RepositoryFor source generator.
         /// </summary>
         /// <returns>A collection of Order entities.</returns>
         [Sqlx()]
         public System.Collections.Generic.IList<TestNamespace.Order> GetOrders()
         {
             var __startTime__ = System.Diagnostics.Stopwatch.GetTimestamp();
             System.Data.Common.DbCommand? __cmd__ = null;
             global::System.Collections.Generic.IList<global::TestNamespace.Order>? __result__ = default;
             System.Exception? __exception__ = null;
 
             try
             {
                 if (connection.State != global::System.Data.ConnectionState.Open)
                 {
                     connection.Open();
                 }
 
                 __cmd__ = connection.CreateCommand();
                 __cmd__.CommandText = "SELECT 1";
 
                 OnExecuting("GetOrders", __cmd__);
 
                 using var reader = __cmd__.ExecuteReader();
                 var results = new global::System.Collections.Generic.List<TestNamespace.Order>();
 
                 while (reader.Read())
                 {
                     int __ordinal_OrderDate = reader.GetOrdinal("OrderDate");
                     int __ordinal_Id = reader.GetOrdinal("Id");
                     int __ordinal_CustomerName = reader.GetOrdinal("CustomerName");
                     var entity = new TestNamespace.Order(
                         reader.GetInt32(reader.GetOrdinal("Id")),
                         reader.IsDBNull(reader.GetOrdinal("CustomerName")) ? string.Empty : reader.GetString(reader.GetOrdinal("CustomerName"))
                     );
                     entity.OrderDate = reader.GetDateTime(reader.GetOrdinal("OrderDate"));
                     results.Add(entity);
                 }
 
                 __result__ = results;
                 return (System.Collections.Generic.IList<TestNamespace.Order>)results;
             }
             catch (System.Exception ex)
             {
                 __exception__ = ex;
                 var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                 OnExecuteFail("GetOrders", __cmd__, ex, __elapsed__);
                 throw;
             }
             finally
             {
                 if (__exception__ == null)
                 {
                     var __elapsed__ = System.Diagnostics.Stopwatch.GetTimestamp() - __startTime__;
                     OnExecuted("GetOrders", __cmd__, __result__, __elapsed__);
                 }
                 __cmd__?.Dispose();
             }
         }
 
     }
 }
 
 
 
 璋冭瘯璺熻釜:
 馃殌 Sqlx CSharpGenerator initialized with advanced optimizations
 CSharpGenerator.Initialize called
 Class Category has 0 attributes:
 No RepositoryFor attribute found on Category
 Class Order has 0 attributes:
 No RepositoryFor attribute found on Order
 Class MixedRepository has 1 attributes:
   - RepositoryForAttribute (Sqlx.Annotations.RepositoryForAttribute)
 Found RepositoryFor attribute on MixedRepository
 Class SqlxAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlxAttribute
 Class RawSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RawSqlAttribute
 Class ExpressionToSqlAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on ExpressionToSqlAttribute
 Class SqlExecuteTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlExecuteTypeAttribute
 Class RepositoryForAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on RepositoryForAttribute
 Class TableNameAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on TableNameAttribute
 Class SqlDefine has 0 attributes:
 No RepositoryFor attribute found on SqlDefine
 Class ExpressionToSql has 0 attributes:
 No RepositoryFor attribute found on ExpressionToSql
 Class DbSetTypeAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on DbSetTypeAttribute
 Class SqlDefineAttribute has 1 attributes:
   - AttributeUsageAttribute (System.AttributeUsageAttribute)
 No RepositoryFor attribute found on SqlDefineAttribute


  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [45 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [35 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [44 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [34 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [55 ms]
  宸查€氳繃 EdgeCase_MissingServiceTypeParameter_HandlesGracefully [64 ms]
  宸查€氳繃 EdgeCase_NullServiceType_HandlesGracefully [40 ms]
  宸查€氳繃 EdgeCase_AbstractClassServiceType_IsSkipped [41 ms]
  宸查€氳繃 EdgeCase_ConcreteClassServiceType_IsSkipped [32 ms]
  宸查€氳繃 EdgeCase_GenericInterface_HandlesCorrectly [53 ms]
  宸查€氳繃 EdgeCase_NonEntityInterface_HandlesGracefully [34 ms]
  宸查€氳繃 EdgeCase_InheritedInterface_HandlesCorrectly [58 ms]
  宸查€氳繃 EdgeCase_LongMethodNamesAndParameters_HandlesCorrectly [45 ms]
  宸查€氳繃 EdgeCase_SpecialCharactersInNames_HandlesCorrectly [52 ms]
  宸查€氳繃 EdgeCase_GlobalNamespace_HandlesCorrectly [33 ms]
  宸查€氳繃 EdgeCase_MultipleRepositoryForAttributes_HandlesGracefully [43 ms]
  宸查€氳繃 EdgeCase_CircularReferences_HandlesGracefully [33 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [45 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [38 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [31 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [39 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [32 ms]
  宸查€氳繃 RepositoryFor_BasicRepository_GeneratesImplementation [50 ms]
  宸查€氳繃 RepositoryFor_EntityTypeInference_FromReturnTypes [28 ms]
  宸查€氳繃 RepositoryFor_EntityTypeInference_FromInterfaceName [38 ms]
  宸查€氳繃 RepositoryFor_TableNameAttribute_IsRespected [29 ms]
  宸查€氳繃 RepositoryFor_AsyncMethods_AreHandled [38 ms]
  宸查€氳繃 RepositoryFor_MethodNamePatterns_GenerateCorrectAttributes [28 ms]
  宸查€氳繃 RepositoryFor_NonInterfaceServiceType_IsSkipped [48 ms]
  宸查€氳繃 RepositoryFor_SqlTemplateAttribute_IsSkipped [36 ms]
  宸查€氳繃 RepositoryFor_MissingAttribute_NoGeneration [25 ms]
  宸查€氳繃 RepositoryFor_InvalidParameters_HandledGracefully [37 ms]
  宸查€氳繃 RepositoryFor_ComplexGenericTypes_AreHandled [28 ms]
  宸查€氳繃 RepositoryFor_NullableReferenceTypes_AreHandled [65 ms]
  宸查€氳繃 RepositoryFor_MultipleRepositories_AreHandled [80 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [92 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [33 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [39 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [30 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [52 ms]
  宸查€氳繃 SourceGenerator_GeneratesValidCode_ForBasicSqlxAttribute [21 ms]
  宸查€氳繃 SourceGenerator_GeneratesSqlDefineConstants [18 ms]
  宸查€氳繃 SourceGenerator_GeneratesExpressionToSqlWithFactoryMethods [26 ms]
  宸查€氳繃 SourceGenerator_GeneratesCorrectImplementation_ForRawSqlAttribute [20 ms]
  宸查€氳繃 SourceGenerator_GeneratesCorrectDialectConstants ("MySql","`","`","@") [38 ms]
  宸查€氳繃 SourceGenerator_GeneratesCorrectDialectConstants ("SqlServer","[","]","@") [18 ms]
  宸查€氳繃 SourceGenerator_MissingAttributes_ReportsDiagnostic [29 ms]
  宸查€氳繃 SourceGenerator_NullSyntaxReceiver_HandlesGracefully [18 ms]
  宸查€氳繃 SourceGenerator_EmptyMethodList_HandlesGracefully [29 ms]
  宸查€氳繃 SourceGenerator_MissingSqlxAttribute_ReportsDiagnostic [19 ms]
  宸查€氳繃 SourceGenerator_MissingRawSqlAttribute_ReportsDiagnostic [39 ms]
  宸查€氳繃 SourceGenerator_MissingExpressionToSqlAttribute_ReportsDiagnostic [19 ms]
  宸查€氳繃 SourceGenerator_NullableContextOptions_HandlesCorrectly [28 ms]
  宸查€氳繃 SourceGenerator_ClassGrouping_HandlesCorrectly [19 ms]
  宸查€氳繃 AbstractGenerator_MissingSqlxAttribute_ReportsDiagnostic [32 ms]
  宸查€氳繃 AbstractGenerator_MissingRawSqlAttribute_ReportsDiagnostic [19 ms]
  宸查€氳繃 AbstractGenerator_MissingExpressionToSqlAttribute_ReportsDiagnostic [38 ms]
  宸查€氳繃 AbstractGenerator_NullableContextOptions_HandlesCorrectly [19 ms]
  宸查€氳繃 AbstractGenerator_EmptyMethodList_HandlesGracefully [28 ms]
  宸查€氳繃 AbstractGenerator_NullSyntaxReceiver_HandlesGracefully [19 ms]
  宸查€氳繃 SqlGeneration_GetAllMethods_GenerateSelectAll [37 ms]
  宸查€氳繃 SqlGeneration_GetByIdMethods_GenerateWhereId [27 ms]
  宸查€氳繃 SqlGeneration_CreateMethods_GenerateInsertExecuteType [46 ms]
  宸查€氳繃 SqlGeneration_UpdateMethods_GenerateUpdateExecuteType [36 ms]
  宸查€氳繃 SqlGeneration_DeleteMethods_GenerateDeleteExecuteType [28 ms]
  宸查€氳繃 SqlGeneration_CountMethods_GenerateCountQueries [43 ms]
  宸查€氳繃 SqlGeneration_ExistsMethods_GenerateExistsQueries [27 ms]
  宸查€氳繃 SqlGeneration_ComplexMethodNames_DefaultToSelect [49 ms]
  宸查€氳繃 SqlGeneration_TableNameResolution_WorksCorrectly [29 ms]
  宸查€氳繃 SqlGeneration_MethodBodies_IncludeNotImplementedException [35 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [30 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [37 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [30 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [50 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [37 ms]
  宸查€氳繃 SqlDefine_GeneratesCorrectConstants [89 ms]
  宸查€氳繃 SqlDefine_MySql_HasCorrectValues [108 ms]
  宸查€氳繃 SqlDefine_SqlServer_HasCorrectValues [104 ms]
  宸查€氳繃 SqlDefine_PostgreSql_HasCorrectValues [99 ms]
  宸查€氳繃 SqlDefine_DialectConstants_HaveCorrectFormat ("MySql","`","`","@") [104 ms]
  宸查€氳繃 SqlDefine_DialectConstants_HaveCorrectFormat ("SqlServer","[","]","@") [91 ms]
  宸查€氳繃 SqlDefine_DialectConstants_HaveCorrectFormat ("PgSql","\"","\"","$") [100 ms]
  宸查€氳繃 SqlDefine_WrapString_WorksForAllDialects [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WorksForAllDialects [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithEmptyString_ReturnsQuotedEmptyString [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithEmptyString_ReturnsQuotedEmptyString [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectParameterCounts [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectParameterNames [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_AreImmutable [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectStringRepresentations [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_CanBeUsedInPatternMatching [< 1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectEqualityBehavior [1 ms]
  宸查€氳繃 SqlDefine_Constants_HaveCorrectHashCodeBehavior [< 1 ms]
  宸查€氳繃 CodeGeneration_BaseFunctionality_WorksCorrectly [31 ms]
  宸查€氳繃 CodeGeneration_MissingAttributes_HandlesGracefully [37 ms]
  宸查€氳繃 CodeGeneration_NullSymbols_HandlesGracefully [41 ms]
  宸查€氳繃 CodeGeneration_EmptyMethodList_HandlesGracefully [32 ms]
  宸查€氳繃 CodeGeneration_MultipleClasses_HandlesCorrectly [41 ms]
  宸查€氳繃 SqlGenerator_BasicOperations_WorkCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_UtilityMethods_WorkCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParameterName_GeneratesCorrectly [< 1 ms]
  宸查€氳繃 SqlDefine_StaticInstances_AreConsistent [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_HasAllExpectedValues [2 ms]
  宸查€氳繃 SqlExecuteTypes_HasCorrectNumericValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_StringConversion_WorksCorrectly [1 ms]
  宸查€氳繃 SqlGenerator_SupportsAllOperationTypes [1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_GeneratesCorrectFormat [< 1 ms]
  宸查€氳繃 SqlDefine_ParameterPrefix_IsCorrect [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_ConvertsCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParameterName_GeneratesCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_HandlesEdgeCases [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_HasAllRequiredValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_CanParseFromString [< 1 ms]
  宸查€氳繃 GetColumnName_ConvertsCorrectly [< 1 ms]
  宸查€氳繃 GetParameterName_GeneratesCorrectly [< 1 ms]
  宸查€氳繃 GetColumnName_HandlesEdgeCases [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_EnumValues_Defined [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_GeneratesCorrectSyntax [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_ConvertsNamesCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParamterName_GeneratesCorrectParameterNames [< 1 ms]
  宸查€氳繃 SqlGenerator_Generate_NonInsertTypes_ReturnsEmptyString [< 1 ms]
  宸查€氳繃 ObjectMap_ListTypes_IdentifiedCorrectly [< 1 ms]
  宸查€氳繃 ObjectMap_NonListTypes_IdentifiedCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_UtilityMethods_WorkCorrectly [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_EnumValues_AreCorrect [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_VariousInputs_WorksCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetParamterName_VariousInputs_WorksCorrectly [< 1 ms]
  宸查€氳繃 GenerateContext_GetColumnName_WithIPropertySymbol_WorksCorrectly [< 1 ms]
  宸查€氳繃 InsertGenerateContext_GetParamterNames_WorksCorrectly [< 1 ms]
  宸查€氳繃 InsertGenerateContext_GetColumnNames_WorksCorrectly [< 1 ms]
  宸查€氳繃 ObjectMap_Constructor_VariousParameterTypes_WorksCorrectly [< 1 ms]
  宸查€氳繃 ObjectMap_Properties_AreAccessible [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasGenerateMethod [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectMethodSignatures [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasPrivateGenerateInsertMethod [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectPrivateMethodSignatures [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_CanBeInstantiated [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectReturnTypes [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectAccessibility [< 1 ms]
  宸查€氳繃 SqlGenerator_Class_HasCorrectInheritance [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectStructure [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectProperties [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectPropertyTypes [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectMethodSignatures [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectReturnTypes [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectAccessibility [< 1 ms]
  宸查€氳繃 GenerateContext_Record_HasCorrectInheritance [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectStructure [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectProperties [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectPropertyTypes [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectMethodSignatures [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectReturnTypes [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectAccessibility [< 1 ms]
  宸查€氳繃 InsertGenerateContext_Record_HasCorrectInheritance [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectConstructor [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectPropertyAccessibility [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectPropertyTypes [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesAreUnique [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesAreSequential [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeCastToInt [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeCastFromInt [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeCompared [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeUsedInSwitchStatements [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_ValuesCanBeUsedInPatternMatching [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_GeneratesCorrectIndentedCode [1 ms]
  宸查€氳繃 CSharpGenerator_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 AbstractGenerator_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 Messages_Class_HasCorrectStructure [2 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0001") [1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0002") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0003") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0004") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0005") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0006") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0007") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0008") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0009") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0010") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0011") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0012") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0013") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0014") [< 1 ms]
  宸查€氳繃 Messages_ContainsWellFormattedErrorMessages ("SP0015") [< 1 ms]
  宸查€氳繃 Messages_AllDiagnostics_HaveCorrectProperties [< 1 ms]
  宸查€氳繃 Messages_AllDiagnostics_HaveUniqueIds [< 1 ms]
  宸查€氳繃 Consts_ContainsValidConstantValues [< 1 ms]
  宸查€氳繃 Consts_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 Extensions_GetParameterName_GeneratesUniqueNames [1 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.Int32","GetInt32") [6 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.String","GetString") [4 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.Boolean","GetBoolean") [3 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.DateTime","GetDateTime") [5 ms]
  宸查€氳繃 Extensions_GeneratesCorrectDataReadExpression ("System.Decimal","GetDecimal") [4 ms]
  宸查€氳繃 Extensions_HandlesNullableTypesCorrectly [4 ms]
  宸查€氳繃 Extensions_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 NameMapper_GeneratesUniqueParameterNames [< 1 ms]
  宸查€氳繃 NameMapper_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 ClassGenerationContext_Class_HasCorrectStructure [1 ms]
  宸查€氳繃 MethodGenerationContext_Class_HasCorrectStructure [1 ms]
  宸查€氳繃 ISqlxSyntaxReceiver_Interface_HasCorrectStructure [< 1 ms]
  宸查€氳繃 GenerationContextBase_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 IsExternalInit_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlExecuteTypes_Enum_HasCorrectValues [< 1 ms]
  宸查€氳繃 ObjectMap_Class_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlDefine_Record_HasCorrectStructure [< 1 ms]
  宸查€氳繃 SqlDefine_StaticInstances_AreReadOnly [< 1 ms]
  宸查€氳繃 SqlDefine_Properties_AreReadOnly [< 1 ms]
  宸查€氳繃 DatabaseDialectProviders_ImplementCorrectInterface [< 1 ms]
  宸查€氳繃 DatabaseDialectProviders_HaveConsistentNaming [< 1 ms]
  宸查€氳繃 TypeAnalyzer_SimplifiedDesign_NoCache [< 1 ms]
  宸查€氳繃 NameMapper_HandlesEdgeCases [< 1 ms]
  宸查€氳繃 SqlDefine_Equality_IsValueBased [< 1 ms]
  宸查€氳繃 SqlDefine_ToString_ReturnsUsefulInformation [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_HandlesLargeContent [5 ms]
  宸查€氳繃 DatabaseDialectFactory_CacheClearing_Works [< 1 ms]
  宸查€氳繃 SqlOperationInferrer_MethodPatterns_AreCaseInsensitive [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithMySqlDefine_ReturnsMySqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlServerDefine_ReturnsSqlServerProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithPostgreSqlDefine_ReturnsPostgreSqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSQLiteDefine_ReturnsSQLiteProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_MySql_ReturnsMySqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_SqlServer_ReturnsSqlServerProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_PostgreSql_ReturnsPostgreSqlProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithSqlDefineTypes_SQLite_ReturnsSQLiteProvider [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithOracleDefineTypes_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithDB2DefineTypes_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithOracleDefine_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 GetDialectProvider_WithDB2Define_ThrowsNotSupportedException [< 1 ms]
  宸查€氳繃 MySqlDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlServerDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 PostgreSqlDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 SQLiteDialectProvider_SqlDefine_HasCorrectValues [< 1 ms]
  宸查€氳繃 MySqlDialectProvider_GenerateLimitClause_ReturnsCorrectSyntax [< 1 ms]
  宸查€氳繃 SqlServerDialectProvider_GenerateInsertWithReturning_ReturnsCorrectSyntax [< 1 ms]
  宸查€氳繃 PostgreSqlDialectProvider_GetCurrentDateTimeSyntax_ReturnsCorrectValue [< 1 ms]
  宸查€氳繃 AllDialectProviders_HaveConsistentInterface [< 1 ms]
  宸查€氳繃 AllDialectProviders_HandleEmptyString [< 1 ms]
  宸查€氳繃 AllDialectProviders_HandleSpecialCharacters [< 1 ms]
  宸查€氳繃 WrapColumn_WithMySqlProvider_UsesBackticks [< 1 ms]
  宸查€氳繃 WrapColumn_WithSqlServerProvider_UsesBrackets [< 1 ms]
  宸查€氳繃 WrapColumn_WithPostgreSqlProvider_UsesDoubleQuotes [< 1 ms]
  宸查€氳繃 WrapColumn_WithSQLiteProvider_UsesBrackets [< 1 ms]
  宸查€氳繃 WrapString_WithAllProviders_UsesCorrectQuotes [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithMySqlProvider_ReturnsAtSign [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithSqlServerProvider_ReturnsAtSign [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithPostgreSqlProvider_ReturnsDollarSign [< 1 ms]
  宸查€氳繃 GetParameterPrefix_WithSQLiteProvider_ReturnsAtSign [< 1 ms]
  宸查€氳繃 WrapColumn_WithEmptyString_ReturnsWrappedEmptyString [< 1 ms]
  宸查€氳繃 WrapString_WithEmptyString_ReturnsWrappedEmptyString [< 1 ms]
  宸查€氳繃 WrapColumn_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 WrapString_WithSpecialCharacters_HandlesCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Constructor_WithNullContent_CreatesEmptyBuilder [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Constructor_WithContent_InitializesWithContent [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithoutIndent_AppendsDirectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithIndent_AppendsWithSpaces [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_PushIndent_IncreasesIndentLevel [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_PopIndent_DecreasesIndentLevel [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_PopIndent_AtZeroLevel_ThrowsException [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_MultipleIndentLevels_AppliesCorrectSpacing [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_Append_WithoutNewline_AppendsDirectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendChar_Works [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendEmptyLine_AddsNewline [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithNullString_HandlesGracefully [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLine_WithEmptyString_AddsOnlyNewline [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLineIf_WithTrueCondition_AppendsTrue [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendLineIf_WithFalseCondition_AppendsFalse [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_ComplexCodeGeneration_FormatsCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_WithInitialContent_AppendsCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_AppendWithIndent_HandlesWhitespace [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_LargeContent_HandlesEfficiently [< 1 ms]
  宸查€氳繃 MapName_WithSimpleName_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithPascalCase_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithCamelCase_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithMultipleWords_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithLongCamelCase_ReturnsSnakeCase [< 1 ms]
  宸查€氳繃 MapName_WithSpecialCharacters_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithHashPrefix_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithUnderscores_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithNumbersAtEnd_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithAllUppercase_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithSingleCharacter_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithSingleLowercaseCharacter_ReturnsSame [< 1 ms]
  宸查€氳繃 MapName_WithEmptyString_ReturnsEmpty [< 1 ms]
  宸查€氳繃 MapName_WithNullParameter_ThrowsArgumentNullException [< 1 ms]
  宸查€氳繃 MapName_WithMixedCaseAndNumbers_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithConsecutiveUppercase_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithDatabaseParameterName_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithComplexSpecialCharacters_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithOnlyNumbers_ReturnsLowercase [< 1 ms]
  宸查€氳繃 MapName_WithStartingNumber_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithAcronyms_HandlesCorrectly [< 1 ms]
  宸查€氳繃 MapName_WithLongParameterName_HandlesCorrectly [< 1 ms]
  宸查€氳繃 IndentedStringBuilder_LargeContent_PerformanceTest [28 ms]
  宸查€氳繃 NameMapper_BatchMapping_PerformanceTest [31 ms]
  宸查€氳繃 SqlDefine_Creation_PerformanceTest [4 ms]
  宸查€氳繃 DatabaseDialectFactory_Caching_PerformanceTest [1 ms]
  宸查€氳繃 TypeAnalyzer_CacheStatistics_PerformanceTest [< 1 ms]
  宸查€氳繃 SqlOperationInferrer_BatchInference_PerformanceTest [1 ms]
  宸查€氳繃 SqlDefine_StaticInstances_PerformanceTest [26 ms]
  宸查€氳繃 WrapColumns_WithMultipleColumns_ReturnsWrappedArray [< 1 ms]
  宸查€氳繃 WrapColumns_WithEmptyArray_ReturnsEmptyArray [< 1 ms]
  宸查€氳繃 WrapColumns_WithNullArray_ReturnsEmptyArray [< 1 ms]
  宸查€氳繃 WrapAndJoinColumns_WithMultipleColumns_ReturnsCommaSeparated [< 1 ms]
  宸查€氳繃 WrapAndJoinColumns_WithCollection_ReturnsCommaSeparated [< 1 ms]
  宸查€氳繃 WrapAndJoinColumns_WithNullCollection_ReturnsEmpty [< 1 ms]
  宸查€氳繃 CreateParameter_WithParameterName_ReturnsWithPrefix [< 1 ms]
  宸查€氳繃 CreateParameter_WithSQLite_HandlesSpecialCase [< 1 ms]
  宸查€氳繃 CreateParameter_WithEmptyName_ReturnsOnlyPrefix [< 1 ms]
  宸查€氳繃 CreateParameters_WithMultipleNames_ReturnsArray [< 1 ms]
  宸查€氳繃 CreateAndJoinParameters_WithMultipleNames_ReturnsCommaSeparated [< 1 ms]
  宸查€氳繃 CreateAndJoinParameters_WithCollection_ReturnsCommaSeparated [< 1 ms]
  宸查€氳繃 CreateSetClauses_WithColumns_ReturnsSetStatements [< 1 ms]
  宸查€氳繃 CreateSetClauses_WithCollection_ReturnsSetStatements [< 1 ms]
  宸查€氳繃 CreateSetClauses_WithEmptyArray_ReturnsEmpty [< 1 ms]
  宸查€氳繃 CreateWhereConditions_WithColumns_ReturnsConditions [< 1 ms]
  宸查€氳繃 CreateWhereConditions_WithCollection_ReturnsConditions [< 1 ms]
  宸查€氳繃 CreateWhereConditions_WithEmptyArray_ReturnsEmpty [< 1 ms]
  宸查€氳繃 UsesParameterPrefix_WithMatchingPrefix_ReturnsTrue [< 1 ms]
  宸查€氳繃 UsesParameterPrefix_WithNonMatchingPrefix_ReturnsFalse [< 1 ms]
  宸查€氳繃 UsesParameterPrefix_WithSQLiteSpecialCase_ReturnsTrue [< 1 ms]
  宸查€氳繃 GetEffectiveParameterPrefix_WithNormalPrefix_ReturnsSame [< 1 ms]
  宸查€氳繃 GetEffectiveParameterPrefix_WithSQLiteSpecialCase_ReturnsAt [< 1 ms]
  宸查€氳繃 GetEffectiveParameterPrefix_WithPostgreSQL_ReturnsDollar [< 1 ms]
  宸查€氳繃 ExtensionMethods_WorkWithAllDialects [< 1 ms]
  宸查€氳繃 SqlDefine_Constructor_SetsAllProperties [< 1 ms]
  宸查€氳繃 SqlDefine_Deconstruct_ReturnsAllValues [< 1 ms]
  宸查€氳繃 SqlDefine_MySql_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_SqlServer_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_PgSql_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_Oracle_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_DB2_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_SQLite_HasCorrectValues [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithSimpleColumn_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_WrapColumn_WithEmptyString_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithSimpleString_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_WrapString_WithEmptyString_ReturnsWrapped [< 1 ms]
  宸查€氳繃 SqlDefine_Equality_SameValues_ReturnsTrue [< 1 ms]
  宸查€氳繃 SqlDefine_Equality_DifferentValues_ReturnsFalse [< 1 ms]
  宸查€氳繃 SqlDefine_GetHashCode_SameValues_ReturnsSameHash [< 1 ms]
  宸查€氳繃 SqlDefine_GetHashCode_DifferentValues_ReturnsDifferentHash [< 1 ms]
  宸查€氳繃 SqlDefine_ToString_ReturnsReadableString [< 1 ms]
  宸查€氳繃 InferOperation_WithGetMethod_ReturnsSelect [19 ms]
  宸查€氳繃 InferOperation_WithCreateMethod_ReturnsInsert [12 ms]
  宸查€氳繃 InferOperation_WithUpdateMethod_ReturnsUpdate [13 ms]
  宸查€氳繃 InferOperation_WithDeleteMethod_ReturnsDelete [12 ms]
  宸查€氳繃 InferOperation_WithFindMethod_ReturnsSelect [11 ms]
  宸查€氳繃 InferOperation_WithSearchMethod_ReturnsSelect [12 ms]
  宸查€氳繃 InferOperation_WithInsertMethod_ReturnsInsert [13 ms]
  宸查€氳繃 InferOperation_WithRemoveMethod_ReturnsDelete [13 ms]
  宸查€氳繃 InferOperation_WithSelectMethod_ReturnsSelect [12 ms]
  宸查€氳繃 InferOperation_WithListMethod_ReturnsSelect [11 ms]
  宸查€氳繃 InferOperation_WithSaveMethod_ReturnsInsert [12 ms]
  宸查€氳繃 InferOperation_WithAddMethod_ReturnsInsert [13 ms]
  宸查€氳繃 InferOperation_WithEditMethod_ReturnsUpdate [12 ms]
  宸查€氳繃 InferOperation_WithDestroyMethod_ReturnsDelete [11 ms]
  宸查€氳繃 InferOperation_WithLoadMethod_ReturnsSelect [23 ms]
  宸查€氳繃 GenerateSqlTemplate_WithSelectOperation_ReturnsSelectSql [19 ms]
  宸查€氳繃 GenerateSqlTemplate_WithInsertOperation_ReturnsInsertSql [14 ms]
  宸查€氳繃 GenerateSqlTemplate_WithUpdateOperation_ReturnsUpdateSql [13 ms]
  宸查€氳繃 GenerateSqlTemplate_WithDeleteOperation_ReturnsDeleteSql [10 ms]
  宸查€氳繃 GenerateSqlTemplate_WithNullEntityType_ReturnsBasicSql [11 ms]
  宸查€氳繃 GenerateSqlTemplate_WithEmptyTableName_HandlesGracefully [12 ms]
  宸查€氳繃 InferOperation_WithNullMethod_ReturnsDefaultOperation [10 ms]
  宸查€氳繃 InferOperation_CaseInsensitive_WorksCorrectly [17 ms]
  宸查€氳繃 IsLikelyEntityType_WithEntityClass_ReturnsTrue [12 ms]
  宸查€氳繃 IsLikelyEntityType_WithPrimitiveType_ReturnsFalse [12 ms]
  宸查€氳繃 IsLikelyEntityType_WithStringType_ReturnsFalse [12 ms]
  宸查€氳繃 IsLikelyEntityType_WithNullType_ReturnsFalse [11 ms]
  宸查€氳繃 IsCollectionType_WithListType_ReturnsTrue [12 ms]
  宸查€氳繃 IsCollectionType_WithNonCollectionType_ReturnsFalse [11 ms]
  宸查€氳繃 IsAsyncType_WithTaskType_ReturnsTrue [12 ms]
  宸查€氳繃 IsAsyncType_WithGenericTaskType_ReturnsTrue [11 ms]
  宸查€氳繃 IsAsyncType_WithNonAsyncType_ReturnsFalse [10 ms]
  宸查€氳繃 IsScalarReturnType_WithIntType_ReturnsTrue [12 ms]
  宸查€氳繃 IsScalarReturnType_WithStringType_ReturnsTrue [12 ms]
  宸查€氳繃 IsScalarReturnType_WithEntityType_ReturnsFalse [10 ms]
  宸查€氳繃 GetDefaultValue_WithIntType_ReturnsCorrectDefault [11 ms]
  宸查€氳繃 GetDefaultValue_WithStringType_ReturnsCorrectDefault [12 ms]
  宸查€氳繃 GetDefaultValue_WithBoolType_ReturnsCorrectDefault [11 ms]
  宸查€氳繃 GetInnerType_WithListOfUser_ReturnsListType [11 ms]
  宸查€氳繃 GetInnerType_WithTaskOfUser_ReturnsUserType [12 ms]
  宸查€氳繃 GetInnerType_WithNonGenericType_ReturnsOriginalType [12 ms]

娴嬭瘯杩愯澶辫触銆?
娴嬭瘯鎬绘暟: 649
     閫氳繃鏁? 643
     澶辫触鏁? 5
    璺宠繃鏁? 1
鎬绘椂闂? 24.1333 绉?

鏈夊彲鐢ㄧ殑宸ヤ綔璐熻浇鏇存柊銆傛湁鍏宠缁嗕俊鎭紝璇疯繍琛?`dotnet workload list`銆?
