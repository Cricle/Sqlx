// -----------------------------------------------------------------------
// <copyright file="IMaintenanceRepositoryTests.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Sqlx;
using Sqlx.Annotations;

namespace Sqlx.Tests.Predefined
{
    /// <summary>
    /// Tests for IMaintenanceRepository predefined interface.
    /// Validates that all methods are correctly defined and can be generated by the source generator.
    /// Requirements: 11.5, 15.3 - Ensure IMaintenanceRepository methods generate correct implementation code.
    /// </summary>
    [TestClass]
    public class IMaintenanceRepositoryTests : IDisposable
    {
        private readonly SqliteConnection _connection;

        public IMaintenanceRepositoryTests()
        {
            _connection = new SqliteConnection("Data Source=:memory:");
            _connection.Open();
        }

        public void Dispose()
        {
            _connection?.Dispose();
        }

        #region Interface Method Coverage Tests

        /// <summary>
        /// Verifies all IMaintenanceRepository methods are defined.
        /// </summary>
        [TestMethod]
        public void IMaintenanceRepository_AllMethodsShouldBeDefined()
        {
            var interfaceType = typeof(IMaintenanceRepository<>);
            var methods = interfaceType.GetMethods();
            var methodNames = methods.Select(m => m.Name).ToList();

            // Destructive Operations
            CollectionAssert.Contains(methodNames, "TruncateAsync");
            CollectionAssert.Contains(methodNames, "DropTableAsync");
            CollectionAssert.Contains(methodNames, "DeleteAllAsync");

            // Maintenance Operations
            CollectionAssert.Contains(methodNames, "RebuildIndexesAsync");
            CollectionAssert.Contains(methodNames, "UpdateStatisticsAsync");
            CollectionAssert.Contains(methodNames, "ShrinkTableAsync");
        }

        /// <summary>
        /// Verifies IMaintenanceRepository method signatures are correct.
        /// </summary>
        [TestMethod]
        public void IMaintenanceRepository_MethodSignatures_ShouldBeCorrect()
        {
            var interfaceType = typeof(IMaintenanceRepository<>);
            var methods = interfaceType.GetMethods();

            // TruncateAsync should return Task (void async)
            var truncateMethod = methods.FirstOrDefault(m => m.Name == "TruncateAsync");
            Assert.IsNotNull(truncateMethod, "TruncateAsync should exist");
            Assert.AreEqual(typeof(Task), truncateMethod.ReturnType, "TruncateAsync should return Task");
            Assert.AreEqual(1, truncateMethod.GetParameters().Length, "TruncateAsync should have 1 parameter (CancellationToken)");
            Assert.AreEqual(typeof(CancellationToken), truncateMethod.GetParameters()[0].ParameterType);

            // DropTableAsync should return Task (void async)
            var dropMethod = methods.FirstOrDefault(m => m.Name == "DropTableAsync");
            Assert.IsNotNull(dropMethod, "DropTableAsync should exist");
            Assert.AreEqual(typeof(Task), dropMethod.ReturnType, "DropTableAsync should return Task");

            // DeleteAllAsync should return Task<int>
            var deleteAllMethod = methods.FirstOrDefault(m => m.Name == "DeleteAllAsync");
            Assert.IsNotNull(deleteAllMethod, "DeleteAllAsync should exist");
            Assert.AreEqual(typeof(Task<int>), deleteAllMethod.ReturnType, "DeleteAllAsync should return Task<int>");

            // RebuildIndexesAsync should return Task (void async)
            var rebuildMethod = methods.FirstOrDefault(m => m.Name == "RebuildIndexesAsync");
            Assert.IsNotNull(rebuildMethod, "RebuildIndexesAsync should exist");
            Assert.AreEqual(typeof(Task), rebuildMethod.ReturnType, "RebuildIndexesAsync should return Task");

            // UpdateStatisticsAsync should return Task (void async)
            var updateStatsMethod = methods.FirstOrDefault(m => m.Name == "UpdateStatisticsAsync");
            Assert.IsNotNull(updateStatsMethod, "UpdateStatisticsAsync should exist");
            Assert.AreEqual(typeof(Task), updateStatsMethod.ReturnType, "UpdateStatisticsAsync should return Task");

            // ShrinkTableAsync should return Task<long>
            var shrinkMethod = methods.FirstOrDefault(m => m.Name == "ShrinkTableAsync");
            Assert.IsNotNull(shrinkMethod, "ShrinkTableAsync should exist");
            Assert.AreEqual(typeof(Task<long>), shrinkMethod.ReturnType, "ShrinkTableAsync should return Task<long>");
        }

        /// <summary>
        /// Verifies IMaintenanceRepository has SqlTemplate attributes on methods.
        /// </summary>
        [TestMethod]
        public void IMaintenanceRepository_Methods_ShouldHaveSqlTemplateAttributes()
        {
            var interfaceType = typeof(IMaintenanceRepository<>);
            var methods = interfaceType.GetMethods();

            // TruncateAsync should have SqlTemplate
            var truncateMethod = methods.FirstOrDefault(m => m.Name == "TruncateAsync");
            Assert.IsNotNull(truncateMethod);
            var truncateAttr = truncateMethod.GetCustomAttribute<SqlTemplateAttribute>();
            Assert.IsNotNull(truncateAttr, "TruncateAsync should have SqlTemplate attribute");
            Assert.IsTrue(truncateAttr.Template.Contains("TRUNCATE"), "TruncateAsync template should contain TRUNCATE");

            // DropTableAsync should have SqlTemplate
            var dropMethod = methods.FirstOrDefault(m => m.Name == "DropTableAsync");
            Assert.IsNotNull(dropMethod);
            var dropAttr = dropMethod.GetCustomAttribute<SqlTemplateAttribute>();
            Assert.IsNotNull(dropAttr, "DropTableAsync should have SqlTemplate attribute");
            Assert.IsTrue(dropAttr.Template.Contains("DROP TABLE"), "DropTableAsync template should contain DROP TABLE");

            // DeleteAllAsync should have SqlTemplate
            var deleteAllMethod = methods.FirstOrDefault(m => m.Name == "DeleteAllAsync");
            Assert.IsNotNull(deleteAllMethod);
            var deleteAllAttr = deleteAllMethod.GetCustomAttribute<SqlTemplateAttribute>();
            Assert.IsNotNull(deleteAllAttr, "DeleteAllAsync should have SqlTemplate attribute");
            Assert.IsTrue(deleteAllAttr.Template.Contains("DELETE FROM"), "DeleteAllAsync template should contain DELETE FROM");
        }

        /// <summary>
        /// Verifies IMaintenanceRepository has no object parameters (AOT compatible).
        /// </summary>
        [TestMethod]
        public void IMaintenanceRepository_ShouldNotHaveObjectParameters_AOTCompatible()
        {
            var interfaceType = typeof(IMaintenanceRepository<>);
            var methods = interfaceType.GetMethods();

            foreach (var method in methods)
            {
                var parameters = method.GetParameters();
                foreach (var param in parameters)
                {
                    Assert.AreNotEqual(typeof(object), param.ParameterType,
                        $"Method {method.Name} has 'object' parameter which is not AOT compatible");
                }
            }
        }

        /// <summary>
        /// Verifies IMaintenanceRepository has correct generic constraint (TEntity : class).
        /// </summary>
        [TestMethod]
        public void IMaintenanceRepository_GenericConstraint_ShouldBeClass()
        {
            var interfaceType = typeof(IMaintenanceRepository<>);
            var typeParam = interfaceType.GetGenericArguments()[0];
            
            var hasClassConstraint = (typeParam.GenericParameterAttributes & 
                GenericParameterAttributes.ReferenceTypeConstraint) != 0;
            Assert.IsTrue(hasClassConstraint, "TEntity should have 'class' constraint");
        }

        #endregion

        #region Source Generator Tests - DeleteAllAsync

        /// <summary>
        /// Tests that the source generator generates DeleteAllAsync correctly.
        /// </summary>
        [TestMethod]
        public async Task SourceGenerated_DeleteAllAsync_DeletesAllRows()
        {
            // Arrange
            await CreateMaintenanceTestTableAsync();
            await InsertTestDataAsync(10);
            var repo = new MaintenanceTestRepository(_connection);

            // Verify data exists
            var countBefore = await GetRowCountAsync();
            Assert.AreEqual(10L, countBefore);

            // Act
            var deleted = await repo.DeleteAllAsync();

            // Assert
            Assert.AreEqual(10, deleted);
            var countAfter = await GetRowCountAsync();
            Assert.AreEqual(0L, countAfter);
        }

        /// <summary>
        /// Tests that the source generator generates DeleteAllAsync correctly when table is empty.
        /// </summary>
        [TestMethod]
        public async Task SourceGenerated_DeleteAllAsync_WhenEmpty_ReturnsZero()
        {
            // Arrange
            await CreateMaintenanceTestTableAsync();
            var repo = new MaintenanceTestRepository(_connection);

            // Act
            var deleted = await repo.DeleteAllAsync();

            // Assert
            Assert.AreEqual(0, deleted);
        }

        #endregion

        #region Source Generator Tests - SQLite TRUNCATE Fallback

        /// <summary>
        /// Tests that SQLite uses DELETE as fallback for TRUNCATE.
        /// SQLite doesn't support TRUNCATE TABLE, so the source generator should use DELETE FROM.
        /// </summary>
        [TestMethod]
        public async Task SourceGenerated_TruncateAsync_SQLite_UsesDeleteFallback()
        {
            // Arrange
            await CreateMaintenanceTestTableAsync();
            await InsertTestDataAsync(5);
            var repo = new MaintenanceTestRepository(_connection);

            // Act - SQLite implementation should use DELETE instead of TRUNCATE
            var deleted = await repo.TruncateAsync();

            // Assert
            Assert.AreEqual(5, deleted);
            var count = await GetRowCountAsync();
            Assert.AreEqual(0L, count);
        }

        #endregion

        #region Source Generator Tests - Maintenance Operations

        /// <summary>
        /// Tests that the source generator generates UpdateStatisticsAsync correctly.
        /// </summary>
        [TestMethod]
        public async Task SourceGenerated_UpdateStatisticsAsync_ExecutesSuccessfully()
        {
            // Arrange
            await CreateMaintenanceTestTableAsync();
            await InsertTestDataAsync(10);
            var repo = new MaintenanceTestRepository(_connection);

            // Act & Assert - Should not throw
            var result = await repo.UpdateStatisticsAsync();
            // ANALYZE doesn't return affected rows, so result may be 0
            Assert.IsTrue(result >= 0);
        }

        #endregion

        #region Helper Methods

        private const string TableName = "maintenance_test_entities";

        private async Task CreateMaintenanceTestTableAsync()
        {
            using var cmd = _connection.CreateCommand();
            cmd.CommandText = $@"
                CREATE TABLE IF NOT EXISTS {TableName} (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    value INTEGER NOT NULL
                )";
            await cmd.ExecuteNonQueryAsync();
        }

        private async Task InsertTestDataAsync(int count)
        {
            for (int i = 1; i <= count; i++)
            {
                using var cmd = _connection.CreateCommand();
                cmd.CommandText = $"INSERT INTO {TableName} (name, value) VALUES ('Item{i}', {i * 10})";
                await cmd.ExecuteNonQueryAsync();
            }
        }

        private async Task<long> GetRowCountAsync()
        {
            using var cmd = _connection.CreateCommand();
            cmd.CommandText = $"SELECT COUNT(*) FROM {TableName}";
            var result = await cmd.ExecuteScalarAsync();
            return Convert.ToInt64(result);
        }

        private async Task<bool> TableExistsAsync()
        {
            using var cmd = _connection.CreateCommand();
            cmd.CommandText = $"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='{TableName}'";
            var result = await cmd.ExecuteScalarAsync();
            return Convert.ToInt64(result) > 0;
        }

        #endregion
    }

    #region Test Entity

    /// <summary>
    /// Test entity for maintenance repository tests.
    /// </summary>
    [TableName("maintenance_test_entities")]
    public class MaintenanceTestEntity
    {
        public long Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public int Value { get; set; }
    }

    #endregion

    #region Source-Generated Maintenance Repository Interface

    /// <summary>
    /// Custom interface for maintenance operations that the source generator can implement.
    /// Uses SqlTemplate attributes to define the SQL for each method.
    /// Note: SQLite doesn't support TRUNCATE, so we use DELETE FROM as fallback.
    /// Note: Using Task<int> return type to get affected rows count.
    /// Note: DROP TABLE is not tested because the source generator blocks it as potential SQL injection.
    /// </summary>
    public interface IMaintenanceTestRepository
    {
        /// <summary>
        /// Truncates table - SQLite fallback uses DELETE FROM.
        /// Note: Real TRUNCATE would be "TRUNCATE TABLE {{table}}" but SQLite doesn't support it.
        /// </summary>
        [SqlTemplate("DELETE FROM {{table}}")]
        Task<int> TruncateAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>Deletes all rows from table.</summary>
        [SqlTemplate("DELETE FROM {{table}}")]
        Task<int> DeleteAllAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>Updates statistics using SQLite ANALYZE.</summary>
        [SqlTemplate("ANALYZE {{table}}")]
        Task<int> UpdateStatisticsAsync(System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Source-generated repository for maintenance operations.
    /// The source generator will implement the interface methods.
    /// </summary>
    [SqlDefine(SqlDefineTypes.SQLite)]
    [RepositoryFor(typeof(IMaintenanceTestRepository))]
    [TableName("maintenance_test_entities")]
    public partial class MaintenanceTestRepository : IMaintenanceTestRepository
    {
        private readonly IDbConnection _connection;

        public MaintenanceTestRepository(IDbConnection connection)
        {
            _connection = connection;
        }
    }

    #endregion
}
