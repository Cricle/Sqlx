using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using Sqlx;
using Sqlx.Annotations;
using TodoWebApi.Models;

namespace TodoWebApi.Services;

/// <summary>
/// Demonstrates dynamic ORDER BY clause with string interpolation optimization.
/// Shows 3 ways to build sorting queries.
/// </summary>
public interface IDynamicOrderByRepository
{
    // ========================================
    // 1. Static ORDER BY (compile-time known)
    // ========================================
    /// <summary>Sort by priority descending - most efficient.</summary>
    [SqlxAttribute("SELECT {{columns}} FROM {{table}} {{orderby priority --desc}}")]
    Task<List<Todo>> GetByPriorityAsync();
    
    /// <summary>Multiple column sort - static definition.</summary>
    [SqlxAttribute("SELECT {{columns}} FROM {{table}} ORDER BY priority DESC, created_at DESC")]
    Task<List<Todo>> GetSortedAsync();
    
    // ========================================
    // 2. DynamicSql ORDER BY (runtime sorting)
    // ========================================
    /// <summary>Dynamic sorting - user-defined sort order.</summary>
    /// <remarks>
    /// ⚠️ Use with caution! Validates ORDER BY clause at runtime.
    /// 
    /// Allowed:
    /// - Column names (alphanumeric + underscore)
    /// - ASC, DESC keywords
    /// - NULLS FIRST, NULLS LAST
    /// - Multiple columns (comma-separated)
    /// 
    /// Forbidden:
    /// - DROP, TRUNCATE, ALTER, CREATE
    /// - SQL comments (--, /*)
    /// - Semicolons (;)
    /// 
    /// Usage:
    /// <code>
    /// // Single column
    /// await repo.GetWithDynamicSortAsync("priority DESC");
    /// 
    /// // Multiple columns
    /// await repo.GetWithDynamicSortAsync("priority DESC, created_at ASC, title");
    /// 
    /// // With NULLS handling
    /// await repo.GetWithDynamicSortAsync("due_date DESC NULLS LAST");
    /// </code>
    /// 
    /// Generated code (optimized with string interpolation):
    /// <code>
    /// // Validate ORDERBY fragment: orderBy
    /// if (!SqlValidator.IsValidFragment(orderBy.AsSpan()))
    ///     throw new ArgumentException("Invalid SQL fragment...");
    /// var __orderbyClause_0__ = orderBy;
    /// 
    /// // Zero Replace calls - direct string interpolation
    /// __cmd__.CommandText = $@"SELECT * FROM todos ORDER BY {__orderbyClause_0__}";
    /// </code>
    /// </remarks>
    [SqlxAttribute("SELECT {{columns}} FROM {{table}} ORDER BY {{orderby @orderBy}}")]
    Task<List<Todo>> GetWithDynamicSortAsync([DynamicSql(Type = DynamicSqlType.Fragment)] string orderBy);
    
    // ========================================
    // 3. Combined: WHERE + Dynamic ORDER BY
    // ========================================
    /// <summary>Search with dynamic sorting.</summary>
    [SqlxAttribute("SELECT {{columns}} FROM {{table}} WHERE {{where}} ORDER BY {{orderby @orderBy}}")]
    Task<List<Todo>> SearchWithSortAsync(
        [ExpressionToSql] ExpressionToSqlBase whereExpression,
        [DynamicSql(Type = DynamicSqlType.Fragment)] string orderBy);
    
    // ========================================
    // 4. Pagination with Dynamic ORDER BY
    // ========================================
    /// <summary>Paginated results with custom sorting.</summary>
    [SqlxAttribute("SELECT {{columns}} FROM {{table}} ORDER BY {{orderby @orderBy}} LIMIT @limit OFFSET @offset")]
    Task<List<Todo>> GetPagedAsync(
        [DynamicSql(Type = DynamicSqlType.Fragment)] string orderBy,
        int limit,
        int offset);
}

[TableName("todos")]
[SqlDefine(SqlDefineTypes.SQLite)]
[RepositoryFor(typeof(IDynamicOrderByRepository))]
public partial class DynamicOrderByRepository(SqliteConnection connection) : IDynamicOrderByRepository
{
    // Implementation auto-generated by Sqlx
    
    // Optional: monitor generated SQL
    partial void OnExecuting(string operationName, global::System.Data.IDbCommand command)
    {
        System.Diagnostics.Debug.WriteLine($"[{operationName}] SQL: {command.CommandText}");
    }
}

