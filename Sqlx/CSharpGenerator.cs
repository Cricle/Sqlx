// -----------------------------------------------------------------------
// <copyright file="CSharpGenerator.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Sqlx;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

/// <summary>
/// Stored procedures generator for C#.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class CSharpGenerator : AbstractGenerator
{
    private const string CSharpAttributeSource = @"// <auto-generated>
// Code generated by Sqlx Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable

using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace Sqlx.Annotations
{
    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    sealed class SqlxAttribute : global::System.Attribute
    {
        public SqlxAttribute()
            => StoredProcedureName = string.Empty;

        public SqlxAttribute(string name)
            => StoredProcedureName = name;

        public string StoredProcedureName { get; }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter| global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class RawSqlAttribute : global::System.Attribute
    {
        public RawSqlAttribute() { }
        public RawSqlAttribute(global::System.String sql) { }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class ExecuteNoQueryAttribute : global::System.Attribute { }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method
        | global::System.AttributeTargets.Class
        | global::System.AttributeTargets.Field
        | global::System.AttributeTargets.Property
        | global::System.AttributeTargets.Method
        | global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class TimeoutAttribute : global::System.Attribute
    {
        public TimeoutAttribute() { }

        public TimeoutAttribute(int timeout) => Timeout = timeout;

        public int Timeout { get; }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class DbColumnAttribute : global::System.Attribute
    {
        public DbColumnAttribute() { }

        public DbColumnAttribute(string? name) => Name = name;

        public string? Name { get; }

        public byte Precision { get; }
        public byte Scale { get; }
        public byte Size { get; }
        public global::System.Data.ParameterDirection Direction { get; }
    }

    /// <summary>
    /// Tag to paramter make it as <see cref=""Func{DbDataReader, Task}""/> or <see cref=""Action{DbDataReader}""/> for read data
    /// </summary>
    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class ReadHandlerAttribute : global::System.Attribute { }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    sealed class DbSetTypeAttribute : global::System.Attribute
    {
        public DbSetTypeAttribute(global::System.Type type) => Type = type;


        public global::System.Type Type { get; }
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method | global::System.AttributeTargets.Class, AllowMultiple = false)]
    sealed class SqlDefineAttribute : global::System.Attribute
    {
        public SqlDefineAttribute(SqlDefineTypes type) { }

        public SqlDefineAttribute(global::System.String columnLeft,
                                  global::System.String columnRight,
                                  global::System.String stringLeft,
                                  global::System.String stringRight,
                                  global::System.String ParamterPrefx) { }
    }

    enum SqlDefineTypes
    {
        MySql = 0,
        SqlServer = 1,
        Postgresql = 2,
    }

    [global::System.Diagnostics.Conditional(""DEBUG"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false)]
    sealed class SqlExecuteTypeAttribute : global::System.Attribute
    {
        public SqlExecuteTypeAttribute(SqlExecuteTypes Type, string TableName) { }
    }

    internal enum SqlExecuteTypes
    {
        Select = 0,
        Update = 1,
        Insert = 2,
        Delete = 3,
    }
}
";

    /// <inheritdoc/>
    public override void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization((pi) =>
        {
            pi.AddSource("SqlxAttribute.g.cs", SourceText.From(CSharpAttributeSource, Encoding.UTF8));
        });
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    internal class SyntaxReceiver : ISqlxSyntaxReceiver
    {
        public List<IMethodSymbol> Methods { get; } = new List<IMethodSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is MethodDeclarationSyntax methodDeclarationSyntax)
            {
                // Get the symbol being declared by the field, and keep it if its annotated
                if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not IMethodSymbol methodSymbol) return;

                if (methodSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "Sqlx.Annotations.SqlxAttribute"))
                {
                    Methods.Add(methodSymbol);
                }
            }
        }
    }
}
