// -----------------------------------------------------------------------
// <copyright file="SourceGeneratorEdgeCasesTests.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Sqlx.Tests.Core
{
    [TestClass]
    public class SourceGeneratorEdgeCasesTests
    {
        [TestMethod]
        public void EdgeCases_DiverseSignatures_GenerateWithoutCrash()
        {
            var source = @"using System; using System.Collections.Generic; using System.Data.Common; using System.Threading; using System.Threading.Tasks; using Sqlx.Annotations;
namespace NS {
  public enum E1:int { A=0, B=1 }
  [TableName(""users"")] public record R1(int Id, string Name);
  [RepositoryFor(typeof(IRepo))]
  public partial class Repo : IRepo { private readonly DbConnection connection; public Repo(DbConnection c){connection=c;} }
  public interface IRepo {
    // Scalar
    [RawSql(""SELECT COUNT(*) FROM users"")] Task<int> CountAsync();
    // Collection of primitives
    [RawSql(""SELECT id FROM users"")] Task<IList<int>> GetIdsAsync();
    // Record mapping path
    [RawSql(""SELECT id, name FROM users"")] Task<IList<R1>> GetRecordsAsync();
    // Enum parameter
    [RawSql(""SELECT COUNT(*) FROM users WHERE id = @id AND @e >= 0"")] Task<int> ByEnumAsync(int id, E1 e);
    // CancellationToken path
    [RawSql(""SELECT 1"")] Task<int> WithTokenAsync(CancellationToken cancellationToken);
    // Batch without table name should be acceptable only for BatchCommand
    [SqlExecuteType(SqlExecuteTypes.BatchCommand, "")] int RunBatch(IEnumerable<int> ids);
  }
}";

            var (compilation, diagnostics, generated) = Generate(source);

            // No generator crash
            Assert.IsNotNull(compilation);
            // Should produce at least some generated sources
            Assert.IsTrue(generated.Any());
            // Soft check: generated code exists and contains repository name
            var code = string.Join("\n", generated);
            Assert.IsTrue(code.Contains("Repo"));
        }

        private static (Compilation Compilation, IEnumerable<Diagnostic> Diagnostics, List<string> Generated) Generate(string sourceCode)
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
            var references = new List<MetadataReference>
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Data.Common.DbConnection).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.CancellationToken).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.Tasks.Task).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Collections.Generic.List<>).Assembly.Location)
            };

            var compilation = CSharpCompilation.Create(
                "EdgeAsm",
                new[] { syntaxTree },
                references,
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            var generator = new CSharpGenerator();
            var driver = CSharpGeneratorDriver.Create(generator);
            driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diags);

            var generated = new List<string>();
            foreach (var tree in newCompilation.SyntaxTrees)
            {
                var text = tree.ToString();
                if (text.Contains("// <auto-generated>") || string.IsNullOrEmpty(tree.FilePath))
                    generated.Add(text);
            }

            return (newCompilation, diags, generated);
        }
    }
}


