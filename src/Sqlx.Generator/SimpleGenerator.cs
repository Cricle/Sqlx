// -----------------------------------------------------------------------
// <copyright file="SimpleGenerator.cs" company="Cricle">
// Copyright (c) Cricle. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Sqlx.Generator;

/// <summary>
/// Simple source generator for testing basic functionality.
/// </summary>
[Generator]
public class SimpleGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register for syntax notifications
        context.RegisterForSyntaxNotifications(() => new SimpleSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Add a test file to verify the generator is working
        var testSource = @"// Generated by Sqlx Simple Generator
namespace Sqlx.Generated
{
    public static class GeneratedTest
    {
        public static string Message => ""Simple Generator is working!"";
    }
}";
        context.AddSource("GeneratedTest.g.cs", SourceText.From(testSource, Encoding.UTF8));

        // Get the syntax receiver
        if (context.SyntaxReceiver is not SimpleSyntaxReceiver receiver)
            return;

        // Group methods by class and deduplicate by method signature to avoid duplicates
        var methodsByClass = receiver.Methods
            .GroupBy(method => method.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault())
            .Where(group => group.Key != null);

        foreach (var group in methodsByClass)
        {
            // Deduplicate methods by their signature (name + parameters)
            var uniqueMethods = group.GroupBy(m => m.Identifier.ValueText + m.ParameterList.ToString())
                                    .Select(g => g.First())
                                    .ToList();
            GenerateClassImplementation(context, group.Key!, uniqueMethods);
        }
    }

    private void GenerateClassImplementation(GeneratorExecutionContext context, ClassDeclarationSyntax classNode, List<MethodDeclarationSyntax> methods)
    {
        var namespaceName = GetNamespace(classNode);
        var className = classNode.Identifier.ValueText;

        var methodBodies = string.Join("\n\n        ", methods.Select(GenerateMethodBody));

        // Generate a simple implementation with necessary using statements
        var source = $@"// <auto-generated />
#nullable enable
using System;
using System.Threading.Tasks;
using System.Linq.Expressions;
using Microsoft.Data.Sqlite;
using SqlxDemo.Models;

namespace {namespaceName}
{{
    partial class {className}
    {{
        {methodBodies}
    }}
}}";

        var fileName = $"{className}.Sqlx.g.cs";
        context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
    }

    private string GenerateMethodBody(MethodDeclarationSyntax method)
    {
        var returnType = method.ReturnType.ToString();
        var methodName = method.Identifier.ValueText;
        
        // Handle extension methods by preserving the 'this' keyword on the first parameter
        var parameters = method.ParameterList.Parameters.Select((p, index) => 
        {
            var paramStr = $"{p.Type} {p.Identifier}";
            if (index == 0 && p.Modifiers.Any(m => m.ValueText == "this"))
            {
                paramStr = $"this {paramStr}";
            }
            return paramStr;
        });
        var parameterString = string.Join(", ", parameters);
        
        // Extract access modifiers from the original method
        var modifiers = string.Join(" ", method.Modifiers.Where(m => !m.ValueText.Equals("partial")).Select(m => m.ValueText));
        
        var body = "";
        if (returnType == "void")
        {
            body = "{ /* Generated implementation */ }";
        }
        else if (returnType.StartsWith("Task<"))
        {
            var innerType = returnType.Substring(5, returnType.Length - 6);
            body = $"{{ return Task.FromResult(default({innerType})); }}";
        }
        else if (returnType == "Task")
        {
            body = "{ return Task.CompletedTask; }";
        }
        else
        {
            body = $"{{ return default({returnType}); }}";
        }

        return $"{modifiers} partial {returnType} {methodName}({parameterString}) {body}";
    }

    private string GetNamespace(SyntaxNode node)
    {
        var namespaceNode = node.Ancestors().OfType<NamespaceDeclarationSyntax>().FirstOrDefault();
        if (namespaceNode != null)
            return namespaceNode.Name.ToString();

        var fileScoped = node.Ancestors().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
        if (fileScoped != null)
            return fileScoped.Name.ToString();

        return "GlobalNamespace";
    }
}

/// <summary>
/// Simple syntax receiver that collects methods with Sqlx attributes.
/// </summary>
public class SimpleSyntaxReceiver : ISyntaxReceiver
{
    public List<MethodDeclarationSyntax> Methods { get; } = new List<MethodDeclarationSyntax>();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is MethodDeclarationSyntax method && method.Modifiers.Any(m => m.ValueText == "partial"))
        {
            // Check if method has potential Sqlx attributes
            foreach (var attributeList in method.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    var name = attribute.Name.ToString();
                    if (name.Contains("Sqlx") || name.Contains("SqlExecuteType"))
                    {
                        Methods.Add(method);
                        break;
                    }
                }
            }
        }
    }
}
