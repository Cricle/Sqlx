# Sqlx Quick Actions (快速操作)

> **功能**: 代码生成和重构工具  
> **状态**: ✅ 实现完成  
> **优先级**: P0

---

## 📋 功能概述

Quick Actions 提供了一套基于 Roslyn 的代码重构工具，帮助开发者快速生成 Sqlx 仓储代码和 CRUD 方法。

---

## 🚀 功能列表

### 1. 生成仓储 (Generate Repository)

**触发条件**: 在实体类上右键

**功能**: 自动生成完整的仓储接口和实现类

**生成内容**:
- 仓储接口 (`I{Entity}Repository`)
- 仓储实现类 (`{Entity}Repository`)
- 8个基础 CRUD 方法

**示例**:

```csharp
// 原始实体
public class User
{
    public long Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}

// 右键点击 User 类 → "Generate Sqlx Repository for 'User'"

// 生成: IUserRepository.cs
[SqlDefine(SqlDefineTypes.SQLite)]
[RepositoryFor(typeof(User))]
public interface IUserRepository
{
    Task<User?> GetByIdAsync(long id, CancellationToken ct = default);
    Task<List<User>> GetAllAsync(CancellationToken ct = default);
    Task<long> InsertAsync(User entity, CancellationToken ct = default);
    Task<int> UpdateAsync(User entity, CancellationToken ct = default);
    Task<int> DeleteAsync(long id, CancellationToken ct = default);
    Task<List<User>> QueryAsync(Expression<Func<User, bool>> predicate, CancellationToken ct = default);
    Task<int> CountAsync(CancellationToken ct = default);
    Task<bool> ExistsAsync(long id, CancellationToken ct = default);
}

// 生成: UserRepository.cs
public partial class UserRepository(DbConnection connection) : IUserRepository
{
    private readonly DbConnection _connection = connection;
    // Implementation is auto-generated by Sqlx source generator
}
```

---

### 2. 添加 CRUD 方法 (Add CRUD Methods)

**触发条件**: 在仓储接口上右键

**功能**: 向现有仓储接口添加 CRUD 方法

**可选方法**:
- `Add GetById method` - 根据ID获取
- `Add GetAll method` - 获取所有
- `Add Insert method` - 插入
- `Add Update method` - 更新
- `Add Delete method` - 删除
- `Add Query method (Expression)` - 表达式查询
- `Add Count method` - 计数
- `Add all CRUD methods` - 一次添加所有方法

**示例**:

```csharp
// 原始接口
[SqlDefine(SqlDefineTypes.SQLite)]
[RepositoryFor(typeof(Product))]
public interface IProductRepository
{
    // 空接口
}

// 右键点击接口名 → "Add all CRUD methods"

// 结果：自动添加所有方法
public interface IProductRepository
{
    [SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE id = @id")]
    Task<Product?> GetByIdAsync(TKey id, CancellationToken ct = default);

    [SqlTemplate("SELECT {{columns}} FROM {{table}}")]
    Task<List<Product>> GetAllAsync(CancellationToken ct = default);

    [SqlTemplate("INSERT INTO {{table}} {{values}}")]
    [ReturnInsertedId]
    Task<TKey> InsertAsync(Product entity, CancellationToken ct = default);

    [SqlTemplate("UPDATE {{table}} {{set}} WHERE id = @id")]
    Task<int> UpdateAsync(Product entity, CancellationToken ct = default);

    [SqlTemplate("DELETE FROM {{table}} WHERE id = @id")]
    Task<int> DeleteAsync(TKey id, CancellationToken ct = default);

    [SqlTemplate("SELECT {{columns}} FROM {{table}} {{where}}")]
    Task<List<Product>> QueryAsync([ExpressionToSql] Expression<Func<Product, bool>> predicate, CancellationToken ct = default);

    [SqlTemplate("SELECT COUNT(*) FROM {{table}}")]
    Task<int> CountAsync(CancellationToken ct = default);
}
```

---

## 🎯 使用场景

### 场景 1: 快速创建新仓储

```csharp
// 步骤1: 创建实体
public class Order
{
    public long Id { get; set; }
    public DateTime OrderDate { get; set; }
    public decimal TotalAmount { get; set; }
}

// 步骤2: 右键 Order 类
// 选择: "Generate Sqlx Repository for 'Order'"

// 步骤3: 自动生成 IOrderRepository 和 OrderRepository
```

### 场景 2: 扩展现有仓储

```csharp
// 已有基础仓储
public interface ICustomerRepository
{
    Task<Customer?> GetByIdAsync(long id);
}

// 右键接口名
// 选择: "Add Query method (Expression)"

// 自动添加:
[SqlTemplate("SELECT {{columns}} FROM {{table}} {{where}}")]
Task<List<Customer>> QueryAsync([ExpressionToSql] Expression<Func<Customer, bool>> predicate, CancellationToken ct = default);
```

---

## 🔧 技术实现

### 架构

```
QuickActions/
├── GenerateRepositoryCodeAction.cs      // 生成仓储
├── AddCrudMethodsCodeAction.cs          // 添加方法
└── README.md                            // 本文档
```

### 关键技术

#### 1. Roslyn Code Refactoring

```csharp
[ExportCodeRefactoringProvider(LanguageNames.CSharp)]
public class GenerateRepositoryCodeAction : CodeRefactoringProvider
{
    public override async Task ComputeRefactoringsAsync(CodeRefactoringContext context)
    {
        // 1. 获取语法节点
        var node = root.FindNode(context.Span);
        
        // 2. 检测上下文（是否在实体类上）
        var classDeclaration = node as ClassDeclarationSyntax;
        
        // 3. 注册代码操作
        context.RegisterRefactoring(action);
    }
}
```

#### 2. 语义分析

```csharp
// 获取类的符号信息
var semanticModel = await document.GetSemanticModelAsync(cancellationToken);
var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

// 分析属性找到主键
var idProperty = classSymbol.GetMembers()
    .OfType<IPropertySymbol>()
    .FirstOrDefault(p => p.Name == "Id" || p.Name.EndsWith("Id"));
```

#### 3. 代码生成

```csharp
// 生成接口代码
private string GenerateInterfaceCode(string entityName, string interfaceName, string keyType)
{
    return $@"
    [SqlDefine(SqlDefineTypes.SQLite)]
    [RepositoryFor(typeof({entityName}))]
    public interface {interfaceName}
    {{
        // Generated methods...
    }}";
}
```

---

## 📝 生成的代码模板

### 接口模板

```csharp
[SqlDefine(SqlDefineTypes.SQLite)] // 可配置数据库类型
[RepositoryFor(typeof(TEntity))]
public interface I{Entity}Repository
{
    // GetById
    [SqlTemplate("SELECT {{columns}} FROM {{table}} WHERE id = @id")]
    Task<TEntity?> GetByIdAsync(TKey id, CancellationToken ct = default);

    // GetAll
    [SqlTemplate("SELECT {{columns}} FROM {{table}}")]
    Task<List<TEntity>> GetAllAsync(CancellationToken ct = default);

    // Insert
    [SqlTemplate("INSERT INTO {{table}} {{values}}")]
    [ReturnInsertedId]
    Task<TKey> InsertAsync(TEntity entity, CancellationToken ct = default);

    // Update
    [SqlTemplate("UPDATE {{table}} {{set}} WHERE id = @id")]
    Task<int> UpdateAsync(TEntity entity, CancellationToken ct = default);

    // Delete
    [SqlTemplate("DELETE FROM {{table}} WHERE id = @id")]
    Task<int> DeleteAsync(TKey id, CancellationToken ct = default);

    // Query
    [SqlTemplate("SELECT {{columns}} FROM {{table}} {{where}}")]
    Task<List<TEntity>> QueryAsync([ExpressionToSql] Expression<Func<TEntity, bool>> predicate, CancellationToken ct = default);

    // Count
    [SqlTemplate("SELECT COUNT(*) FROM {{table}}")]
    Task<int> CountAsync(CancellationToken ct = default);

    // Exists
    [SqlTemplate("SELECT COUNT(*) FROM {{table}} WHERE id = @id")]
    Task<bool> ExistsAsync(TKey id, CancellationToken ct = default);
}
```

### 实现类模板

```csharp
public partial class {Entity}Repository(DbConnection connection) : I{Entity}Repository
{
    private readonly DbConnection _connection = connection;

    // Implementation is auto-generated by Sqlx source generator
    // No manual code needed - the [SqlTemplate] attributes drive code generation
}
```

---

## 🎯 设计原则

### 1. 智能检测

- **实体类检测**: 自动识别可能的实体类
- **主键识别**: 自动检测 Id 属性
- **类型推断**: 根据主键类型生成相应代码

### 2. 灵活配置

- **数据库类型**: 默认 SQLite，可手动修改
- **命名空间**: 使用占位符，需手动调整
- **方法选择**: 可单独添加或批量添加

### 3. 代码质量

- **完整注释**: 每个方法都有 XML 文档注释
- **参数默认值**: CancellationToken 默认值
- **返回类型**: 明确的 Task 返回类型

---

## 💡 最佳实践

### 1. 使用时机

✅ **适合使用**:
- 新建实体需要CRUD操作
- 快速原型开发
- 标准化仓储结构

❌ **不适合使用**:
- 复杂业务逻辑
- 需要自定义SQL
- 多表关联查询（但可以作为起点）

### 2. 生成后的调整

生成的代码通常需要以下调整：

```csharp
// 1. 修改命名空间
namespace YourNamespace.Repositories  // ← 改为实际命名空间

// 2. 修改数据库类型
[SqlDefine(SqlDefineTypes.SQLite)]  // ← 改为实际数据库

// 3. 根据需要添加自定义方法
Task<List<User>> GetActiveUsersAsync(CancellationToken ct = default);

// 4. 调整泛型类型（如果需要）
Task<User?> GetByIdAsync(long id, ...)  // ← 根据实际主键类型调整
```

### 3. 命名约定

- **实体**: `User`, `Product`, `Order`
- **接口**: `IUserRepository`, `IProductRepository`
- **实现**: `UserRepository`, `ProductRepository`
- **主键**: `Id` 或 `{Entity}Id`

---

## 🚀 性能考虑

### 代码生成性能

- **触发时间**: < 100ms
- **生成时间**: < 200ms
- **对 IDE 影响**: 最小

### 优化措施

1. **延迟计算**: 只在需要时才计算重构
2. **缓存检测**: 避免重复的语法分析
3. **异步操作**: 所有操作都是异步的

---

## 🐛 已知限制

### 1. 命名空间

**问题**: 生成的代码使用占位符命名空间  
**解决**: 手动修改为实际命名空间  
**影响**: 低（一次性修改）

### 2. 主键检测

**问题**: 只检测名为 `Id` 或以 `Id` 结尾的属性  
**解决**: 如果主键名不同，手动调整代码  
**影响**: 低（罕见情况）

### 3. 复杂类型

**问题**: 不支持复合主键  
**解决**: 生成后手动调整  
**影响**: 中等（需要一些修改）

---

## 📊 使用统计（预期）

| 指标 | 目标值 |
|------|--------|
| **节省时间** | 每个仓储 5-10 分钟 |
| **代码行数** | 每个仓储 50-100 行 |
| **使用频率** | 每天 5-20 次 |
| **用户满意度** | 90%+ |

---

## 🔮 未来改进

### 短期（v0.6.0）

- [ ] 支持自定义模板
- [ ] 智能命名空间检测
- [ ] 更多数据库类型选项

### 中期（v0.7.0）

- [ ] 复合主键支持
- [ ] 批量操作方法生成
- [ ] 软删除支持

### 长期（v0.8.0+）

- [ ] 关联查询生成
- [ ] DTO 映射生成
- [ ] 单元测试生成

---

## 📞 相关资源

### 代码

- [GenerateRepositoryCodeAction.cs](GenerateRepositoryCodeAction.cs)
- [AddCrudMethodsCodeAction.cs](AddCrudMethodsCodeAction.cs)

### 文档

- [VS Extension Plan](../../../docs/VSCODE_EXTENSION_PLAN.md)
- [Build Instructions](../BUILD.md)

### 外部链接

- [Roslyn Code Refactorings](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/tutorials/how-to-write-csharp-analyzer-code-fix)
- [VS SDK Documentation](https://docs.microsoft.com/en-us/visualstudio/extensibility/)

---

**状态**: ✅ 实现完成  
**版本**: 0.5.0-dev  
**最后更新**: 2025-10-29

