// <copyright file="ParameterBinderGenerator.cs" company="Sqlx">
// Copyright (c) Sqlx. All rights reserved.
// </copyright>

namespace Sqlx;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

/// <summary>
/// Source generator that creates IParameterBinder implementations for classes marked with [SqlxParameter].
/// </summary>
/// <remarks>
/// <para>
/// This generator produces AOT-compatible, reflection-free parameter binding code that:
/// </para>
/// <list type="bullet">
/// <item><description>Creates DbParameter instances for each entity property</description></item>
/// <item><description>Handles nullable types and DBNull conversion</description></item>
/// <item><description>Respects [Column] attribute for custom parameter names</description></item>
/// <item><description>Excludes properties marked with [IgnoreDataMember]</description></item>
/// </list>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public class ParameterBinderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,
                transform: static (ctx, _) => GetTarget(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static ClassDeclarationSyntax? GetTarget(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        foreach (var attrList in classDecl.AttributeLists)
        {
            foreach (var attr in attrList.Attributes)
            {
                var name = attr.Name.ToString();
                if (name is "SqlxParameter" or "SqlxParameterAttribute")
                    return classDecl;
            }
        }
        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty) return;

        var sqlxParamAttr = compilation.GetTypeByMetadataName("Sqlx.Annotations.SqlxParameterAttribute");
        if (sqlxParamAttr is null) return;

        var ignoreAttr = compilation.GetTypeByMetadataName("System.Runtime.Serialization.IgnoreDataMemberAttribute");
        var columnAttr = compilation.GetTypeByMetadataName("System.ComponentModel.DataAnnotations.Schema.ColumnAttribute");

        foreach (var classDecl in classes.Distinct())
        {
            if (classDecl is null) continue;

            var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol typeSymbol) continue;

            var hasAttr = typeSymbol.GetAttributes().Any(a =>
                SymbolEqualityComparer.Default.Equals(a.AttributeClass, sqlxParamAttr));
            if (!hasAttr) continue;

            var source = GenerateSource(typeSymbol, ignoreAttr, columnAttr);
            context.AddSource($"{typeSymbol.Name}.ParameterBinder.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateSource(INamedTypeSymbol typeSymbol, INamedTypeSymbol? ignoreAttr, INamedTypeSymbol? columnAttr)
    {
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace ? null : typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;
        var fullTypeName = typeSymbol.ToDisplayString();

        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic && p.GetMethod is not null)
            .Where(p => ignoreAttr is null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace " + (ns ?? "Global") + ";");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Data.Common;");
        sb.AppendLine();

        sb.AppendLine($"public sealed class {typeName}ParameterBinder : global::Sqlx.IParameterBinder<{fullTypeName}>");
        sb.AppendLine("{");
        sb.AppendLine($"    public static {typeName}ParameterBinder Default {{ get; }} = new();");
        sb.AppendLine();
        sb.AppendLine($"    public void BindEntity(DbCommand command, {fullTypeName} entity, string parameterPrefix = \"@\")");
        sb.AppendLine("    {");

        foreach (var prop in properties)
        {
            var columnName = GetColumnName(prop, columnAttr);
            var isNullable = IsNullable(prop);

            sb.AppendLine("        {");
            sb.AppendLine("            var p = command.CreateParameter();");
            sb.AppendLine($"            p.ParameterName = parameterPrefix + \"{columnName}\";");

            if (isNullable || prop.Type.IsReferenceType)
                sb.AppendLine($"            p.Value = entity.{prop.Name} ?? (object)DBNull.Value;");
            else
                sb.AppendLine($"            p.Value = entity.{prop.Name};");

            sb.AppendLine("            command.Parameters.Add(p);");
            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetColumnName(IPropertySymbol prop, INamedTypeSymbol? columnAttr)
    {
        if (columnAttr is not null)
        {
            var attr = prop.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, columnAttr));
            if (attr?.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is string name)
                return name;
        }
        return ToSnakeCase(prop.Name);
    }

    private static string ToSnakeCase(string name)
    {
        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (char.IsUpper(c) && i > 0) sb.Append('_');
            sb.Append(char.ToLowerInvariant(c));
        }
        return sb.ToString();
    }

    private static bool IsNullable(IPropertySymbol prop)
    {
        if (prop.NullableAnnotation == NullableAnnotation.Annotated) return true;
        if (prop.Type.IsValueType && prop.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T) return true;
        return false;
    }
}
