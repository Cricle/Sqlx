# Sqlx 追踪开销性能测试结果

测试日期：2025-10-22  
测试环境：AMD Ryzen 7 5800H, .NET 8.0.21

---

## 📊 测试结果汇总

### 单行查询性能对比

| 方法 | 平均耗时 | 相对基准 | 相对比例 | 内存分配 | 相对基准 |
|------|----------|----------|----------|----------|----------|
| **Raw ADO.NET (基准)** | 6.414 μs | 1.00x | - | 904 B | 1.00x |
| **Dapper** | 8.111 μs | 1.26x | 慢 26% | 1,776 B | 1.96x (多96%) |
| **Sqlx 零追踪** | 14.675 μs | 2.29x | 慢 129% | 1,240 B | 1.37x (多37%) |
| **Sqlx 只有指标** | 15.106 μs | 2.36x | 慢 136% | 1,240 B | 1.37x (多37%) |
| **Sqlx 完整追踪** | 15.320 μs | 2.39x | 慢 139% | 1,240 B | 1.37x (多37%) |

#### 🔍 追踪开销分析（单行查询）

| 配置 | 耗时 | 开销 | 占比 |
|------|------|------|------|
| 零追踪（基准） | 14.675 μs | 0 μs | 0% |
| + Stopwatch | 15.106 μs | **+0.431 μs** | **+2.9%** |
| + Activity | 15.320 μs | **+0.214 μs** | **+1.4%** |
| **总追踪开销** | 15.320 μs | **+0.645 μs** | **+4.4%** |

---

### 多行查询性能对比（10条记录）

| 方法 | 平均耗时 | 相对基准 | 相对比例 | 内存分配 | 相对基准 |
|------|----------|----------|----------|----------|----------|
| **Raw ADO.NET (基准)** | 16.14 μs | 1.00x | - | 3,264 B | 1.00x |
| **Dapper** | 16.24 μs | 1.01x | 慢 1% | 4,680 B | 1.43x (多43%) |
| **Sqlx 零追踪** | 30.19 μs | 1.87x | 慢 87% | 3,952 B | 1.21x (多21%) |
| **Sqlx 只有指标** | 30.34 μs | 1.88x | 慢 88% | 3,952 B | 1.21x (多21%) |
| **Sqlx 完整追踪** | 30.20 μs | 1.87x | 慢 87% | 3,952 B | 1.21x (多21%) |

#### 🔍 追踪开销分析（多行查询）

| 配置 | 耗时 | 开销 | 占比 |
|------|------|------|------|
| 零追踪（基准） | 30.19 μs | 0 μs | 0% |
| + Stopwatch | 30.34 μs | **+0.15 μs** | **+0.5%** |
| + Activity | 30.20 μs | **-0.14 μs** | **±0%** (误差范围) |
| **总追踪开销** | 30.34 μs | **+0.15 μs** | **+0.5%** |

---

## ✅ 关键发现

### 1. 追踪和指标开销极低 🎉

**单行查询：**
- **Stopwatch 开销**: 0.431 μs (约 **3%**)
- **Activity 开销**: 0.214 μs (约 **1.4%**)
- **总开销**: 0.645 μs (约 **4.4%**)

**多行查询：**
- **Stopwatch 开销**: 0.15 μs (约 **0.5%**)
- **Activity 开销**: < 0.15 μs (**可忽略**)
- **总开销**: 0.15 μs (约 **0.5%**)

**结论**：
- ✅ 条件编译设计 **完美工作**
- ✅ `[EnableTracing(false)]` 和 `[EnableMetrics(false)]` **真正实现零开销**
- ✅ 追踪功能的性能影响 **可以忽略不计**（<5%）
- ✅ 数据量越大，追踪开销占比越小（多行查询只有0.5%）

---

### 2. 内存效率优于 Dapper ✅

**单行查询：**
- Sqlx: 1,240 B
- Dapper: 1,776 B
- **Sqlx 比 Dapper 少 30%**

**多行查询（10条）：**
- Sqlx: 3,952 B
- Dapper: 4,680 B
- **Sqlx 比 Dapper 少 15.5%**

**结论**：
- ✅ Sqlx 内存效率优于 Dapper
- ✅ 追踪功能 **不增加** 内存分配（零追踪、只有指标、完整追踪内存完全相同）

---

### 3. Sqlx 核心性能需要优化 ⚠️

**单行查询：**
- Sqlx 零追踪: 14.675 μs
- Dapper: 8.111 μs
- **Sqlx 比 Dapper 慢 81%**

**多行查询：**
- Sqlx 零追踪: 30.19 μs
- Dapper: 16.24 μs
- **Sqlx 比 Dapper 慢 86%**

**这是核心性能问题，与追踪无关！**

**可能的优化方向：**
1. ✅ 已优化：直接序号访问 (GetInt32(0) 而不是 GetOrdinal)
2. ❓ 待检查：参数化查询的性能
3. ❓ 待检查：对象创建和初始化
4. ❓ 待检查：连接状态检查的开销
5. ❓ 待检查：生成代码的IL质量

---

## 📈 性能对比图表

### 单行查询性能梯度

```
Raw ADO.NET (基准)    ████████ 6.4 μs  
Dapper               ██████████ 8.1 μs (+26%)
Sqlx 零追踪           ████████████████████ 14.7 μs (+129%)
Sqlx 只有指标          █████████████████████ 15.1 μs (+136%)
Sqlx 完整追踪          █████████████████████ 15.3 μs (+139%)
```

### 多行查询性能梯度

```
Raw ADO.NET (基准)    ████████ 16.1 μs  
Dapper               ████████ 16.2 μs (+1%)
Sqlx 零追踪           ███████████████ 30.2 μs (+87%)
Sqlx 只有指标          ███████████████ 30.3 μs (+88%)
Sqlx 完整追踪          ███████████████ 30.2 μs (+87%)
```

### 追踪开销占比

**单行查询：**
```
核心性能开销 (vs Dapper)  ████████████████████████████ 6.6 μs (93%)
追踪开销                  ██ 0.6 μs (7%)
```

**多行查询：**
```
核心性能开销 (vs Dapper)  ███████████████████████████████ 14.0 μs (99%)
追踪开销                  █ 0.2 μs (1%)
```

**结论**：
- 追踪开销只占总性能差距的 **1-7%**
- **核心性能优化** 才是关键，而不是追踪

---

## 🎯 结论和建议

### ✅ 成功之处

1. **追踪特性设计成功**
   - `[EnableTracing]` 和 `[EnableMetrics]` 特性工作完美
   - 条件编译真正实现零开销
   - 禁用追踪时，生成的代码不包含任何追踪逻辑

2. **内存效率优秀**
   - 比 Dapper 少分配 15-30% 内存
   - 追踪功能不增加内存开销

3. **可观测性完整**
   - 支持 .NET Activity 标准
   - 支持 Stopwatch 精确计时
   - 支持 Partial 方法自定义拦截

### ⚠️ 需要改进

1. **核心性能优化**
   - Sqlx 零追踪版本仍比 Dapper 慢 80-90%
   - 这是 **主要问题**，与追踪无关
   - 需要深入分析生成代码和执行路径

2. **性能优化优先级**
   ```
   1. 核心性能优化（预期提升：50-80%）
   2. 参数化查询优化（预期提升：10-20%）
   3. 对象初始化优化（预期提升：5-10%）
   4. 追踪代码优化（预期提升：<5%）← 优先级最低
   ```

### 💡 使用建议

**根据场景选择配置：**

1. **极致性能场景**（高频查询，QPS > 1000）
   ```csharp
   [EnableTracing(false)]
   [EnableMetrics(false)]
   ```

2. **生产环境 - APM集成**
   ```csharp
   [EnableTracing(true, LogSql = false)]  // Activity追踪但不记录SQL
   [EnableMetrics(false)]
   ```

3. **生产环境 - 慢查询监控**
   ```csharp
   [EnableTracing(false)]
   [EnableMetrics(true)]  // 只要执行时间，不要Activity
   ```

4. **开发和调试**
   ```csharp
   [EnableTracing(true, LogSql = true, LogParameters = true)]
   [EnableMetrics(true)]
   ```

**方法级别优化示例：**

```csharp
[RepositoryFor(typeof(IUserRepository))]
public partial class UserRepository : IUserRepository
{
    // 高频查询：禁用所有追踪
    [EnableTracing(false)]
    [EnableMetrics(false)]
    [Sqlx("SELECT {{columns}} FROM {{table}} WHERE id = @id")]
    User? GetByIdSync(int id);  // 每秒1000+次调用

    // 低频但重要：启用完整追踪
    [EnableTracing(true)]
    [EnableMetrics(true)]
    [Sqlx("INSERT INTO {{table}} ...")]
    int InsertSync(...);  // 每秒<10次调用
}
```

---

## 📋 测试详情

**测试环境：**
- CPU: AMD Ryzen 7 5800H
- 运行时: .NET 8.0.21 (X64 RyuJIT AVX2)
- GC: Concurrent Server
- 编译模式: Release
- 数据库: SQLite (内存模式)

**测试方法：**
- 使用 BenchmarkDotNet 0.14.0
- 预热：6-10 次迭代
- 实际测试：13-15 次迭代
- 置信区间：99.9%
- 内存诊断：已启用

**测试数据：**
- 单行查询：1 条记录
- 多行查询：10 条记录
- 数据库预填充：100 条测试数据
- 每条记录：8 个字段（int, string, decimal, bool, DateTime）

---

## 🔗 相关文档

- [追踪和指标特性控制](../../docs/TRACING_AND_METRICS_ATTRIBUTES.md)
- [追踪开销测试指南](./TRACING_OVERHEAD_BENCHMARKS.md)
- [Partial 方法指南](../../docs/PARTIAL_METHODS_GUIDE.md)
- [性能优化计划](../../PERFORMANCE_ANALYSIS.md)

---

## 📌 下一步行动

### 立即执行（高优先级）

1. **核心性能优化**
   - [ ] 分析生成的IL代码
   - [ ] 对比 Dapper 的IL代码
   - [ ] 优化对象创建路径
   - [ ] 优化参数绑定

2. **性能测试**
   - [x] 单行查询追踪开销测试
   - [x] 多行查询追踪开销测试
   - [ ] 复杂查询追踪开销测试
   - [ ] CRUD操作追踪开销测试

### 后续优化（低优先级）

3. **追踪功能优化**（预期提升 <5%）
   - [ ] Activity 创建优化
   - [ ] Stopwatch 使用优化
   - [ ] Partial 方法调用优化

4. **文档更新**
   - [x] 性能测试结果文档
   - [ ] 最佳实践指南
   - [ ] FAQ 和故障排查

---

**测试完成时间**: 2025-10-22 14:45  
**报告生成**: 自动生成  
**数据来源**: BenchmarkDotNet 实际测试结果

